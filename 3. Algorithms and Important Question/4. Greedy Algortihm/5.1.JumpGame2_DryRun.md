# Dry run 1 — reachable example

`nums = [2, 3, 1, 1, 4]`
`n = 5` (last index = 4)

Initial:

```
jumps = 0
l = 0, r = 0   // current range of indices reachable with 'jumps' jumps
```

We loop while `r < n-1` (while we haven't reached last index).

| Iter | current range \[l..r] | indices considered (i) | i + nums\[i] values considered | farthest (after scanning range) | new l | new r | jumps (after update) | comment                                            |
| ---- | --------------------: | ---------------------: | -----------------------------: | ------------------------------: | ----: | ----: | -------------------: | -------------------------------------------------- |
| 1    |               \[0..0] |                  i = 0 |   0 + nums\[0] = 0 + 2 = **2** |                farthest = **2** |     1 |     2 |                    1 | From index 0 we can reach up to 2                  |
| 2    |               \[1..2] |               i = 1, 2 |  i=1 → 1+3=**4** ; i=2 → 2+1=3 |   farthest = max(2,4,3) = **4** |     3 |     4 |                    2 | From indices 1..2 max reach becomes 4 (last index) |

```
After iteration 2 r == 4 which is n-1 → we stop and return jumps = 2
```

So the **minimum number of jumps = 2** (you jump from index 0 to some index ≤2, then from there to the end).

---

# Dry run 2 — unreachable example (shows problem and fix)

`nums = [3, 2, 1, 0, 4]`
`n = 5`

Initial:

```
jumps = 0
l = 0, r = 0
```

| Iter | \[l..r] | indices i |   i+nums\[i] values |   farthest | new l | new r |   jumps |
| ---- | ------: | --------: | ------------------: | ---------: | ----: | ----: | ------: |
| 1    | \[0..0] |       i=0 |         0+3 = **3** | farthest=3 |   l=1 |   r=3 | jumps=1 |
| 2    | \[1..3] |   i=1,2,3 | 1+2=3, 2+1=3, 3+0=3 | farthest=3 |   l=4 |   r=3 | jumps=2 |

After iteration 2 we set `l = r+1 = 4` and `r = farthest = 3`. Now `l > r`. The next `for (int i = l; i <= r; ++i)` will **not iterate** (no indices to inspect), `farthest` stays whatever you initialize it to (in your code you reinitialize to 0 each loop — that causes problems), and the loop repeats forever because `r` remains `3` (< `n-1`) and never grows.

**Conclusion:** the algorithm as written can get stuck (infinite loop) if the last index is unreachable.

---

## Small defensive fix (recommended)

After computing `farthest` for the current range, check whether you actually made progress. If not, you cannot reach the end — break / return.

Change the inner logic slightly (one safe variant):

```cpp
while (r < n - 1) {
    int farthest = r;                      // start with current r
    for (int i = l; i <= r; ++i) {
        farthest = max(farthest, i + nums[i]);
    }
    if (farthest == r) return -1;          // can't progress further → unreachable
    l = r + 1;
    r = farthest;
    ++jumps;
}
```

* Using `farthest = r` ensures `farthest == r` if no index in `[l..r]` extends reach; then you can return `-1` or some sentinel.
* If the problem guarantees reachability (LeetCode Jump Game II often assumes you can always reach the last index), you can omit this check; otherwise include it to avoid infinite loops.

---
