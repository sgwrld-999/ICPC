## **Intuition**

* You start at index `0` and can jump up to `nums[i]` steps from position `i`.
* We keep track of **`maxIdx`** → the **farthest index** we can reach so far.
* If at any point `i > maxIdx`, it means we’ve reached a **gap** we can’t cross → return `false`.
* If `maxIdx` reaches or goes beyond the last index, return `true`.

---

## **Code + Dry Run**

Example:

```
nums = [2, 3, 1, 1, 4]
```

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    bool canJump(vector<int>& nums) {
        int maxIdx = 0; // farthest reachable index so far

        for (int i = 0; i < nums.size(); i++) {
            // If our current index is beyond the farthest point we can reach
            if (i > maxIdx) return false;

            // Update farthest reachable index
            maxIdx = max(maxIdx, i + nums[i]);

            // Dry run:
            /*
            i = 0: nums[0] = 2
                maxIdx = max(0, 0+2) = 2

            i = 1: nums[1] = 3
                maxIdx = max(2, 1+3) = 4 (we can already reach last index here → true)

            */

            if (maxIdx >= nums.size() - 1) return true;
        }

        return maxIdx >= nums.size() - 1;
    }
};

int main() {
    vector<int> nums = {2, 3, 1, 1, 4};
    Solution obj;
    cout << boolalpha << obj.canJump(nums) << "\n"; // true
}
```

---

## **Dry Run Table**

| i | nums\[i] | maxIdx before | i > maxIdx? | maxIdx after  | Can reach end? |
| - | -------- | ------------- | ----------- | ------------- | -------------- |
| 0 | 2        | 0             | No          | max(0, 0+2)=2 | No             |
| 1 | 3        | 2             | No          | max(2, 1+3)=4 | Yes (4 ≥ last) |

We stop early and return `true`.

---

This is already **O(n)** time and **O(1)** space — there’s no faster way because we must at least check each position until we either get stuck or reach the end.

---

