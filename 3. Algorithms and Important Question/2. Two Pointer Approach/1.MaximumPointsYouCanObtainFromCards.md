
# Maximum Points You Can Obtain from Cards

### Problem link:
[Link to the problem](https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/)

Original code:

```cpp
class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {
        int n = cardPoints.size();
        if(n == 1)return cardPoints[0];
        if(n == 2 & k == 2){ return (cardPoints[0] + cardPoints[1]);
        }else{
            return (cardPoints[0] > cardPoints[1] ? cardPoints[0] : cardPoints[1]);
        }
        int i = 0 ; 
        int j = n - 1;
        int sum = 0 ;
        while((k > 0) & i <= j){
            if(cardPoints[i] > cardPoints[j]){
                sum += cardPoints[i];
                i++;
            }
            else if(cardPoints[i] <= cardPoints[j]){
                sum += cardPoints[j];
                j--;
            }
            else if(cardPoints[i] == cardPoints[j]){
                if((i != j) &&(cardPoints[i+1] > cardPoints[j-1])){
                    sum += cardPoints[i];
                    i++;
                }
                else if((i != j) &&(cardPoints[i+1] < cardPoints[j-1]))
                    sum += cardPoints[i];
                    j--;
            }  else{
                sum += cardPoints[i];
                i++;
            } 
            k--;
        }
        return sum;
    }
};
```


Let’s break this down in **two parts**:

1. **What goes wrong if we think in the wrong direction**
2. **How to think about the correct pattern from scratch**

---

## **1. The Wrong Direction**

A common first instinct is:

> “We can take a card from the start or end, so let's try all combinations.”

That leads to:

* Using **DFS / backtracking** to test all pick sequences → **O(2^k)** (too slow)
* Or dynamic programming over `left` and `right` picks → **O(k²)** or more

The problem?

* Constraints are **n ≤ 10⁵** → brute force is impossible
* We don’t need the sequence of picks — only the **sum** matters

---

## **2. The Right Thought Process (Pattern)**

### **Step 1 — Restate the problem in your own words**

We can pick exactly `k` cards, either from the left or right end.
We want **maximum sum**.

Instead of thinking "pick from both ends" →
Think: **At the end of k picks, we will have discarded exactly `n - k` consecutive cards somewhere in the middle**.

---

### **Step 2 — Reverse the perspective**

If we keep `k` cards from both ends, the remaining `n - k` cards form a **contiguous subarray** in the middle.
So:

* **Max sum of picked cards = Total sum of all cards - Min sum of `n - k` consecutive cards**.

---

### **Step 3 — Apply the sliding window**

Now it becomes:

1. Find total sum `totalSum`.
2. Use a sliding window of length `n - k` to find `minWindowSum`.
3. Answer = `totalSum - minWindowSum`.

**Time complexity** → O(n)
**Space complexity** → O(1)

---

### **Step 4 — Pattern recognition**

This is a **“choose from ends” → “find window in middle”** trick.
It shows up in:

* Problems where you take items from ends only (`n - k` window trick)
* Maximize kept elements = Total sum - Min sum of removed elements

---


## **Problem Restatement**

You have an array `cardPoints[]` and you must pick exactly `k` cards **from either end**.
Find the **maximum points** you can obtain.

---

## **Thought Process Recap**

Instead of thinking “pick from left or right,”
we think **“what’s left in the middle after k picks”**.

* Length of array = `n`
* You pick `k` cards → You **don’t pick** `n - k` cards (they’re consecutive in the middle)
* **Max sum of picked = Total sum - Min sum of n - k window**.

---

## **Code Implementation in C++**

```cpp
class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {
        int n = cardPoints.size();
        int totalSum = 0;
        
        // Step 1: Total sum of all cards
        for (int point : cardPoints) {
            totalSum += point;
        }

        // Special case: if k == n, we take all cards
        if (k == n) return totalSum;

        // Step 2: Find min sum of a subarray of length n - k
        int windowSize = n - k;
        int currentSum = 0;

        // Initial window
        for (int i = 0; i < windowSize; i++) {
            currentSum += cardPoints[i];
        }
        int minWindowSum = currentSum;

        // Sliding the window
        for (int i = windowSize; i < n; i++) {
            currentSum += cardPoints[i] - cardPoints[i - windowSize];
            minWindowSum = min(minWindowSum, currentSum);
        }

        // Step 3: Max score = totalSum - minWindowSum
        return totalSum - minWindowSum;
    }
};
```

---

## **Dry Run Example**

### Input:

```
cardPoints = [1, 2, 3, 4, 5, 6, 1], k = 3
n = 7, n - k = 4
```

**Step 1:**
`totalSum = 1 + 2 + 3 + 4 + 5 + 6 + 1 = 22`

**Step 2:**
Find min sum of a subarray of length `4`:

* Initial window (first 4 cards):
  `1 + 2 + 3 + 4 = 10` → minWindowSum = 10
* Slide: remove 1, add 5 → sum = 14 → min = 10
* Slide: remove 2, add 6 → sum = 18 → min = 10
* Slide: remove 3, add 1 → sum = 12 → min = 10

**Step 3:**
`maxScore = totalSum - minWindowSum = 22 - 10 = 12`

**Check:**
Best pick: `[6, 5, 1]` or `[1, 6, 5]` from ends → sum = 12 ✅

---

## **Pattern Takeaway**

This is the **"remove min middle window to maximize ends"** trick.
It often applies to:

* Take from ends
* Keep `k` elements
* Maximize picked sum by **minimizing discarded middle segment**

---

Alright, here’s the **n–k idea** broken down simply:

---

### 1️⃣ Restating the problem

You have `n` cards.
You can pick exactly `k` cards from **either end** (left or right).

Instead of **choosing which k cards to take**,
you can think about **which (n - k) cards you leave behind**.

---

### 2️⃣ Why does this work?

* You’re taking **k cards** → that means you’re **not taking** the remaining **n - k cards**.
* The chosen cards are from the ends, so the `n - k` cards you **leave behind** must form **one continuous subarray** in the middle.
* If you find the **minimum sum** of any subarray of length `n - k`, then:

  ```
  Max points = Total sum of cards - Minimum sum of (n - k) consecutive cards
  ```

---

### 3️⃣ Example

Cards: `[1, 2, 3, 4, 5, 6, 1]`
n = 7, k = 3 → n - k = 4

* Total sum = `1 + 2 + 3 + 4 + 5 + 6 + 1 = 22`
* We must leave behind `4` consecutive cards with **minimum sum**.

Sliding window of size `4`:

| Subarray   | Sum |
| ---------- | --- |
| \[1,2,3,4] | 10  |
| \[2,3,4,5] | 14  |
| \[3,4,5,6] | 18  |
| \[4,5,6,1] | 16  |

Min sum = **10**

Max points = `22 - 10 = 12` ✅

---

### 4️⃣ Pattern recognition

This **n-k trick** turns the problem into:

> "Find the smallest window of length n - k, subtract its sum from the total."

That’s **O(n)** instead of trying all left/right combinations.

---