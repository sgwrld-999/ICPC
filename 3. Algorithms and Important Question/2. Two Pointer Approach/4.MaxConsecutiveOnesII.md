# Question:  
Max Consecutive Ones II:  
Suppose we have a binary array; we have to find the maximum number of consecutive 1s in this array if we can flip at most one 0.  
For example, if the input is `[1,0,1,1,0]`, the output will be `4` because flipping the first zero yields the longest sequence of consecutive 1s. After flipping, the maximum number of consecutive 1s is 4.

##  Variable Size Sliding Window

```cpp
int left = 0, right = 0, zeroCount = 0, maxLen = 0;
int size = arr.size();

while (right < size) {
    if (arr[right] == 0) zeroCount++;

    // If more than one zero in the window, shrink from the left
    while (zeroCount > 1) {
        if (arr[left] == 0) zeroCount--;
        left++;
    }

    // Update the maximum length found
    maxLen = std::max(maxLen, right - left + 1);

    right++;
}
```

## Original code:

```cpp
class Solution{
    public:
        int findMaxOneAfterFlip(vector<int>nums){
            int n = nums.size();
            if(n == 1) return 1;
            if( n == 2){
                if(nums[0] == 1 && nums[1] == 0) return 2;
                else if(nums[0] == 0 && nums[1] == 1) return 2;
                else if(nums[0] == 0 && nums[1] == 0) return 1;
            }
            
            unordered_map<int,int> freq;
            
            int l = 0 ;
            int r = 0 ;
            
            int maxLen = 0 ;
            
            while(r < n){
                if(freq.size() < 2){
                    freq[nums[r]]++;
                    r++;
                }
                //Now, we need to check the values of the zero should not be greater than 1
                if(freq[0] > 1){
                    //If the freq is more than 1 remove the elements from the left
                    //Now we need to remove the values from the left 
                    freq[l]--;
                    l++;
                    if(freq[l] == 0) freq.remove(0);
                }
                
            }
            
        }
    
};
```
# Solution

Here’s where you missed things and how you could have thought through the rest:

---

## **What you missed**

1. **Condition definition**

   * In the template, `condition` must be a clearly defined property of the current window.
   * For **Max Consecutive Ones II**, the condition is:

     > Number of zeros in the current window ≤ 1
   * In your code, you started using `freq` but didn’t actually define the condition in terms of `freq[0]`.

2. **Shrinking the window**

   * You started writing:

     ```cpp
     if (freq[0] > 1) { ... }
     ```

     but you didn’t correctly shrink it — you used `freq[l]--` instead of `freq[nums[l]]--`.

     * `l` here is an **index**, but you need to remove the element value at that index from the map.

3. **Updating `maxLen`**

   * You didn’t add the step where you update `maxLen` with `(r - l)` or `(r - l + 1)` after expanding/shrinking.
   * This is crucial for sliding window problems.

4. **Ending condition**

   * You never returned anything from your function.

---

## **How you could have thought of the complete solution**

Let’s walk through the thinking process step-by-step:

1. **Reframe the problem**

   * We want the **longest subarray** that contains **at most one zero**.
   * This screams **sliding window** where:

     * **Expand right** while `zeroCount ≤ 1`
     * **Shrink left** while `zeroCount > 1`

2. **Choose what to track**

   * We don’t need a whole frequency map.
   * A single `zeroCount` variable is enough.
   * Every time we move `right`, if `nums[right] == 0` → `zeroCount++`.
   * Every time we move `left`, if `nums[left] == 0` → `zeroCount--`.

3. **Map to the template**

   * `condition = zeroCount`
   * `k = 1` (at most one zero allowed)
   * `if (zeroCount > 1)`, shrink the window from the left.

4. **Update answer**

   * After each valid expansion, update:

     ```cpp
     maxLen = max(maxLen, right - left + 1);
     ```

---

## **Correct code using your template**

```cpp
class Solution {
public:
    int findMaxOneAfterFlip(vector<int>& nums) {
        int n = nums.size();
        int left = 0, right = 0;
        int zeroCount = 0;
        int maxLen = 0;

        while (right < n) {
            if (nums[right] == 0) zeroCount++;

            while (zeroCount > 1) {
                if (nums[left] == 0) zeroCount--;
                left++;
            }

            maxLen = max(maxLen, right - left + 1);
            right++;
        }
        return maxLen;
    }
};
```

---

## **Dry run with `[1,0,1,1,0]`**

| left | right | nums\[right] | zeroCount | maxLen | Window       |
| ---- | ----- | ------------ | --------- | ------ | ------------ |
| 0    | 0     | 1            | 0         | 1      | \[1]         |
| 0    | 1     | 0            | 1         | 2      | \[1,0]       |
| 0    | 2     | 1            | 1         | 3      | \[1,0,1]     |
| 0    | 3     | 1            | 1         | 4      | \[1,0,1,1]   |
| 0    | 4     | 0            | 2         | 4      | \[1,0,1,1,0] |
| 1    | 4     | —            | 1         | 4      | \[0,1,1,0]   |

**Answer = 4**

---


# Brute Force Idea

* Generate **all possible subarrays**.
* For each subarray:

  1. Count the number of zeros.
  2. If the number of zeros ≤ 1, update the maximum length.

---

### Why it works

Because the condition says *“we can flip at most one 0”*, so any valid subarray must have **0 or 1 zero**.

---

### Brute Force Pseudocode

```cpp
int maxConsecutiveOnes(vector<int>& nums) {
    int n = nums.size();
    int maxLen = 0;

    for (int start = 0; start < n; start++) {
        int zeroCount = 0;
        for (int end = start; end < n; end++) {
            if (nums[end] == 0) zeroCount++;

            if (zeroCount <= 1) {
                maxLen = max(maxLen, end - start + 1);
            }
        }
    }

    return maxLen;
}
```

---

### Complexity

* Time: **O(n²)** — checking all subarrays.
* Space: **O(1)** — no extra data structures needed.

---

