Got it — I’ll rewrite this problem in the **exact note-style format** you like, with **thought process**, **brute force idea**, **optimized approach**, and the **final code**.

---

## Problem Statement

You are given a binary array `nums` (containing only 0 and 1).
Find the **maximum number of consecutive 1's** in the array.

---

## Intuition

We want the **longest streak** of `1`s in the array.
A straightforward way is to check every possible segment of the array — but that’s slow.
Instead, we can keep a **running counter** of how many consecutive `1`s we’ve seen so far, and reset it when we hit a `0`.

---

## Thought Process

1. If `nums[i] == 1`, increment a `currentCount`.
2. If `nums[i] == 0`, reset `currentCount` to 0.
3. Keep track of the **maximum count** seen so far.

This works in **one pass** because the array only contains `0` and `1`.

---

## Brute Force Approach

### Idea

* For each index `i`, check how long the streak of `1`s continues until you hit a `0`.
* Keep track of the longest streak.

### Pseudocode

```cpp
maxLen = 0
for i from 0 to n-1:
    if nums[i] == 1:
        length = 0
        for j from i to n-1:
            if nums[j] == 1:
                length++
                maxLen = max(maxLen, length)
            else:
                break
return maxLen
```

### Complexity

* **Time Complexity:** O(n²) — nested loops.
* **Space Complexity:** O(1).

---

## Optimized Approach (One Pass)

1. Initialize `currentCount = 0`, `maxCount = 0`.
2. Iterate through `nums`:

   * If current element is `1`, increment `currentCount` and update `maxCount`.
   * If current element is `0`, reset `currentCount` to `0`.
3. Return `maxCount`.

---

## Complexity Analysis

* **Time Complexity:** O(n) — single pass through the array.
* **Space Complexity:** O(1).

---

## Final Code

```cpp
class Solution {
public:
    int findMaxConsecutiveOnes(vector<int>& nums) {
        int currentCount = 0, maxCount = 0;
        for (int num : nums) {
            if (num == 1) {
                currentCount++;
                maxCount = max(maxCount, currentCount);
            } else {
                currentCount = 0;
            }
        }
        return maxCount;
    }
};
```

---

✅ **Key Pattern to Remember:**
When you need the **longest streak** of something in a single array scan, keep a running counter and reset when the streak breaks.

---
# Dry run 

Let’s do a **step-by-step dry run** for

`nums = [1, 1, 0, 1, 1, 1]`

---

### **Initial values**

```
n = 6
ctr = 0
maxCtr = 0
nums[0] == 1 → ctr = 1
```

---

### **Iteration starts** (i from 1 to 5):

#### **i = 1** → nums\[1] = 1

```
ctr++ → ctr = 2
maxCtr < ctr → 0 < 2 → maxCtr = 2
```

State: `ctr = 2, maxCtr = 2`

---

#### **i = 2** → nums\[2] = 0

```
maxCtr < ctr → 2 < 2 ❌ (no change)
ctr reset → ctr = 0
```

State: `ctr = 0, maxCtr = 2`

---

#### **i = 3** → nums\[3] = 1

```
ctr++ → ctr = 1
maxCtr < ctr → 2 < 1 ❌
```

State: `ctr = 1, maxCtr = 2`

---

#### **i = 4** → nums\[4] = 1

```
ctr++ → ctr = 2
maxCtr < ctr → 2 < 2 ❌
```

State: `ctr = 2, maxCtr = 2`

---

#### **i = 5** → nums\[5] = 1

```
ctr++ → ctr = 3
maxCtr < ctr → 2 < 3 ✅ → maxCtr = 3
```

State: `ctr = 3, maxCtr = 3`

---

### **Loop ends**

`return maxCtr → 3`

---

✅ **Final Answer**: `3`
Meaning the longest streak of consecutive `1`s is length **3** (from indices `3 → 5`).

---
