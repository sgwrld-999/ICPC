# Question:  
[Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/)


##  Variable Size Sliding Window

```cpp
int left = 0, right = 0, zeroCount = 0, maxLen = 0;
int size = arr.size();

while (right < size) {
    if (arr[right] == 0) zeroCount++;

    // If more than one zero in the window, shrink from the left
    while (zeroCount > 1) {
        if (arr[left] == 0) zeroCount--;
        left++;
    }

    // Update the maximum length found
    maxLen = std::max(maxLen, right - left + 1);

    right++;
}
```

## Original code:

```cpp
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int n = nums.size();
        if(n == 1){
            if(nums[0] == 0){
                if(k == 0) return 0;
                else if(k >= 1) return 1;
            }
            else return 1;
        }

        int r = 0 ;
        int l = 0 ;
        int zeroCtr = 0 ;
        int maxLen = 0 ;

        while(r < n){
            if(nums[r] == 0 & zeroCount < k){
                zeroCount++;
            }

            while(zeroCte > 3){
                //Now the value is greater than k remove the left element
                left++;
                zeroCtr--;
            }

            maxLen = max(maxLen,r+l-1);
            right++;
        }
        return maxLen;
    }
};
```
# Solution

Your code for **longestOnes** is close in concept, but it has several correctness and syntax issues.
Let’s go through it step-by-step and fix it.

---

## **Issues in your code**

1. **Variable naming mismatches**

   * You used `zeroCtr` and `zeroCount` inconsistently.
   * You also used `left`/`l` and `right`/`r` interchangeably, which will break compilation.

2. **Bitwise `&` instead of logical `&&`**

   * In

     ```cpp
     if(nums[r] == 0 & zeroCount < k)
     ```

     you used bitwise `&` instead of logical `&&`. This will give wrong results.

3. **Logic error in shrinking the window**

   * You wrote:

     ```cpp
     while(zeroCte > 3)
     ```

     This seems hardcoded to `3` instead of using `k`.
     Also `zeroCte` is a typo.

4. **Incorrect max length calculation**

   * You wrote:

     ```cpp
     maxLen = max(maxLen, r + l - 1);
     ```

     This formula is wrong — it should be `(r - l + 1)` to get the window size.

5. **Base case for `n == 1` is overcomplicated**

   * You don’t actually need special handling for `n == 1`, the sliding window naturally covers it.

---

## **Correct & Clean Version**

Here’s how I’d rewrite it using your style:

```cpp
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int n = nums.size();
        int left = 0, right = 0;
        int zeroCount = 0;
        int maxLen = 0;

        while (right < n) {
            if (nums[right] == 0) zeroCount++;

            // Shrink window until we have at most k zeros
            while (zeroCount > k) {
                if (nums[left] == 0) zeroCount--;
                left++;
            }

            maxLen = max(maxLen, right - left + 1);
            right++;
        }

        return maxLen;
    }
};
```

---

## **Why this works**

* **Expanding window:** Move `right` forward, count zeros.
* **Shrinking window:** If `zeroCount > k`, move `left` until the constraint is satisfied.
* **Tracking answer:** Update `maxLen` with the current valid window size.

---

## **Complexity**

* **Time:** `O(n)` — each element is visited at most twice.
* **Space:** `O(1)` — no extra space used.

---