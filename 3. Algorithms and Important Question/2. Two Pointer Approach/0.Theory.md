## **1. Introduction to Two-Pointer Approach**

### **What It Is**

* The **Two-Pointer technique** uses **two indices (pointers)** to traverse an array or string in a coordinated way.
* Instead of nested loops (`O(n²)`), we move these pointers intelligently to achieve **O(n)** or **O(n log n)** time.

### **Why It’s Useful**

* Reduces time complexity by avoiding re-processing of elements.
* Ideal when dealing with **sorted arrays**, **subarray/substring problems**, and **pair/triplet problems**.

### **Two-Pointer vs Sliding Window**

| **Two-Pointer**                                                                        | **Sliding Window**                                                                         |
| -------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| General concept: two indices moving through the data.                                  | Special case of two-pointer where the segment between pointers is treated as a **window**. |
| Often used for **pair problems** (sum, difference, etc.).                              | Mostly for problems involving **contiguous subarrays/strings**.                            |
| No strict rule that both pointers move forward; sometimes one moves backward.          | Usually both pointers move forward.                                                        |
| Not always "window-based" (e.g., finding two numbers in a sorted array that sum to X). | Always considers a continuous chunk of elements (window).                                  |

---

## **2. General Templates**

### **Generic Two-Pointer Template**

```pseudo
left = 0
right = n - 1  // or 0, depending on the problem

while (left < right):
    // Perform calculations with arr[left] and arr[right]
    
    if condition satisfied:
        update answer
        move one or both pointers intelligently
    else:
        adjust pointers based on logic
```

**Example use case**: Pair sum in a sorted array.

---

### **Generic Sliding Window Template (Variable Size)**

```pseudo
left = 0
for right in range(0, n):
    // Include arr[right] in current window

    while condition is violated:
        // Shrink window from left
        remove arr[left] from current window
        left++

    // At this point, condition is satisfied
    update answer if needed
```

---

### **Generic Sliding Window Template (Fixed Size k)**

```pseudo
left = 0
for right in range(0, n):
    // Add arr[right] to window

    if (right - left + 1 == k):
        update answer using current window
        // Slide window forward
        remove arr[left]
        left++
```

---

## **3. Patterns of Two-Pointer Problems**

---

### **A. Constant Window (Fixed Size)**

**Definition**

* Window size is fixed (`k`).
* Move right pointer to expand window, then slide both pointers.

**Example**:

> Find the maximum sum of any subarray of size `k`.

---

**Brute Force** →
Check all subarrays of size `k`. **O(n\*k)**.

**Optimal (Sliding Window)** →

* Keep track of sum of current window.
* When sliding, subtract outgoing element, add incoming element.

---

**Dry Run** (arr = `[1, 3, 2, 5, 1, 1, 2, 3]`, k = 3)

```
Window: [1, 3, 2] sum=6 → max=6  
Slide: remove 1, add 5 → sum=10 → max=10  
Slide: remove 3, add 1 → sum=8 → max=10  
Slide: remove 2, add 1 → sum=7 → max=10  
...
```

**Complexity**: O(n) time, O(1) space.
**Pitfalls**: Forgetting to remove the outgoing element when sliding.

---

### **B. Longest Subarray When `<condition>`**

**Definition**:
Find the longest contiguous subarray that satisfies a condition.

**Example**:

> Longest subarray with sum ≤ K.

---

**Brute Force** →
Check all subarrays, sum them. O(n²).

**Better (Two-Pointer)** →

* Expand right pointer.
* If condition is violated, shrink from left until valid.

---

**Dry Run** (arr = `[1, 2, 1, 0, 1, 1, 0]`, K = 4)

```
right=0 sum=1 maxLen=1
right=1 sum=3 maxLen=2
right=2 sum=4 maxLen=3
right=3 sum=4 maxLen=4
right=4 sum=5 > K → remove left=1 → sum=4 maxLen=4
...
```

**Complexity**: O(n) time, O(1) space.
**Pitfalls**:

* Shrinking too much (lose potential longer valid window).
* Not updating max length after shrinking.

---

### **C. Number of Subarrays Where `<condition>`**

**Definition**:
Count all subarrays satisfying a condition (e.g., at most K distinct numbers).

**Key Trick**:

* For each `right`, if window is valid, **all subarrays ending at right are valid**: count += (right - left + 1).

---

**Dry Run** (arr = `[1,2,1]`, K = 2 distinct)

```
right=0 valid → count += 1  
right=1 valid → count += 2  
right=2 valid → count += 3  
Total = 6
```

**Complexity**: O(n).
**Pitfalls**:

* Confusing between counting and finding length.
* Forgetting that subarrays share elements (no need to recompute).

---

### **D. Shortest / Minimum Window Where `<condition>`**

**Definition**:
Find the smallest subarray satisfying a condition.

**Example**:

> Minimum length subarray with sum ≥ K.

---

**Approach**:

* Expand `right` until condition is met.
* Then **shrink from left as much as possible** while still valid.
* Keep track of min length.

---

**Dry Run** (arr = `[2,3,1,2,4,3]`, K=7)

```
right=0 sum=2  
right=1 sum=5  
right=2 sum=6  
right=3 sum=8 ≥K → shrink → length=4 → minLen=4  
...
```

**Complexity**: O(n).
**Pitfalls**:

* Not shrinking when possible (miss minimum).
* Forgetting to update min length after shrinking.

---

## **4. Common Pitfalls (General)**

* Moving only one pointer when both should move.
* Not handling **empty array / k > n** cases.
* Forgetting to handle **negative numbers** (can break some sum-based assumptions).
* In counting problems, mixing up **"length"** vs **"number of subarrays"**.

---