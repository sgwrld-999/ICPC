# **Minimum Bit Flips to Convert Number**

**Problem Link:** [LeetCode 2220](https://leetcode.com/problems/minimum-bit-flips-to-convert-number/)

---

## **Problem Statement**

Given two integers `start` and `goal`, return the minimum number of bit flips required to convert `start` to `goal`.

**Example:**

```
start = 10, goal = 7
10 (binary) = 1010
7  (binary) = 0111
→ Different bits = 3 → Answer = 3
```

---

## **Key Idea**

* To find which bits are different between `start` and `goal`, use **XOR**:

  * `1 ^ 1 = 0` (same bits → no change needed)
  * `0 ^ 0 = 0`
  * `1 ^ 0 = 1` (different bits → flip needed)
  * `0 ^ 1 = 1`
* Once we have the XOR result, **count the number of 1's** — each 1 means a flip is required.

---

## **Approach**

1. **Find XOR** of `start` and `goal`.
2. **Count the set bits (1's)** in the XOR result.
3. Return the count.

---

## **Code**

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int minBitFlips(int start, int goal) {
        int ans = start ^ goal; // Step 1: Find differing bits
        int count = 0;

        // Step 2: Count set bits using Brian Kernighan’s algorithm
        while(ans > 0) {
            count++;
            ans = ans & (ans - 1); // Remove last set bit
        }

        return count;
    }
};

int main() {
    Solution s;
    cout << s.minBitFlips(2, 6) << endl; // Example
    return 0;
}
```

---

## **Dry Run**

Example: `start = 2, goal = 6`

```
start = 2  -> 0010
goal  = 6  -> 0110
XOR         = 0100  (Only 1 bit differs)

Step 1: ans = start ^ goal = 0100
Step 2: Count set bits:
   Iteration 1: ans = 0100 → count = 1 → ans & (ans - 1) = 0000 → stop.

Result: 1 flip needed.
```

---

## **Time Complexity**

* **XOR:** O(1)
* **Counting set bits (Brian Kernighan):** O(k) where k = number of set bits
  Worst case k ≤ number of bits in integer → O(log n)

---

## **Alternate Ways to Count Set Bits**

1. Using built-in:

```cpp
return __builtin_popcount(start ^ goal);
```

2. Bitwise shift method:

```cpp
while(ans > 0) {
    count += ans & 1;
    ans >>= 1;
}
```

---

# Intuition

The intuition comes directly from **what XOR does at the bit level**.

---

## **Step 1: What XOR really means**

For two bits $a$ and $b$:

```
a b | a ^ b
0 0 | 0   (same → no flip)
0 1 | 1   (different → flip needed)
1 0 | 1   (different → flip needed)
1 1 | 0   (same → no flip)
```

So, **XOR outputs 1 exactly when the bits differ**.
That’s why XOR is often called the *odd ones detector* — it checks if exactly one of the bits is 1.

---

## **Step 2: Connecting it to bit flips**

* If a bit is the same in `start` and `goal`, **no flip is needed** → XOR = 0.
* If a bit is different, **one flip is needed** → XOR = 1.

Example:

```
start = 1010
goal  = 0111
XOR   = 1101
```

Here, the `1`s in the XOR result mark exactly where the two numbers differ.

---

## **Step 3: Why counting 1's works**

Each `1` in the XOR result represents **one bit position that must change** to turn `start` into `goal`.
So the **number of flips = number of 1's in (start ^ goal)**.

---

## **Step 4: Visual analogy**

Think of `start` and `goal` as two light switches in a row:

* If a switch is already the same position in both → no action.
* If a switch is different → flip it once.
  Counting 1’s in XOR is like counting how many switches are in the "different" position.

---

**Key takeaway:**

> XOR finds differences, and counting set bits tells us how many differences there are — that’s exactly the number of bit flips required.

---

When you do:

```cpp
int diff = start ^ goal;
```

* You’re creating a **difference map** between `start` and `goal`.
* Every `1` in `diff` means *"this bit position is different, so it must be changed"*.
* Counting those `1`s tells you **how many changes (bit flips)** are needed.

It’s basically:

**Step 1:** *Find where they differ* (XOR).
**Step 2:** *Count how many differences* (count set bits).

---


