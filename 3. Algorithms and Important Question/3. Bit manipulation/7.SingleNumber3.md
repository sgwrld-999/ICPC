## **260. Single Number III**

**Problem Link:** [https://leetcode.com/problems/single-number-iii/](https://leetcode.com/problems/single-number-iii/)

---

### **Problem Statement**

Given an integer array `nums` where exactly **two elements appear only once** and **all the other elements appear exactly twice**, return the two elements that appear only once.
Order of the output does not matter.

---

### **Approach 1: Hash Map (Frequency Count)**

**Steps**:

1. Create a frequency map of numbers.
2. Return numbers with frequency = 1.

**Time Complexity:** `O(n)`
**Space Complexity:** `O(n)`

---

### **Approach 2: Bit Manipulation (No extra space)** ✅

**Core Idea:**

* XOR of two same numbers = 0, XOR of a number with 0 = number.
* If we XOR all numbers, all duplicates cancel out, leaving `xorResult = num1 ^ num2` (the two unique numbers).
* The rightmost set bit in `xorResult` indicates a position where `num1` and `num2` differ.
* Use this bit to split numbers into two groups and XOR separately to find each number.

---

**Finding Rightmost Set Bit**
Two ways:

1. `rightmostSetBit = xorResult & (-xorResult)`  ✅ (Uses two’s complement)
2. `rightmostSetBit = (xorResult & (xorResult - 1)) ^ xorResult`

**Why it works:**

* `xorResult & (-xorResult)` isolates the lowest set bit by taking two's complement and ANDing.
* Second method removes the lowest set bit, then XORs with original to get only that bit.

---

### **Algorithm Steps**

1. XOR all numbers → `xorResult = num1 ^ num2`.
2. Find `setBit` = rightmost set bit of `xorResult`.
3. Initialize `grpA = 0, grpB = 0`.
4. For each `num`:

   * If `(num & setBit) != 0` → `grpA ^= num`
   * Else → `grpB ^= num`
5. Return `{grpA, grpB}`.

---

### **Dry Run Example**

#### Input:

```
nums = [1, 2, 1, 3, 2, 5]
```

#### Step 1: XOR all numbers

```
result = 0
result ^= 1 → 1
result ^= 2 → 3
result ^= 1 → 2
result ^= 3 → 1
result ^= 2 → 3
result ^= 5 → 6
```

```
xorResult = 6 (binary: 110) = 3 ^ 5
```

#### Step 2: Find rightmost set bit

```
setBit = xorResult & (-xorResult)
       = 110 & (010) 
       = 010 (binary) = 2
```

Rightmost set bit is at **position 1** (0-indexed).

---

#### Step 3: Split into two groups and XOR

| num | binary | setBit (010) set? | Group | grpA | grpB |
| --- | ------ | ----------------- | ----- | ---- | ---- |
| 1   | 001    | No                | B     | 0    | 1    |
| 2   | 010    | Yes               | A     | 2    | 1    |
| 1   | 001    | No                | B     | 2    | 0    |
| 3   | 011    | Yes               | A     | 1    | 0    |
| 2   | 010    | Yes               | A     | 3    | 0    |
| 5   | 101    | No                | B     | 3    | 5    |

---

#### Step 4: Result

```
grpA = 3
grpB = 5
return {3, 5}
```

✅ Output matches expected.

---

### **Complexity**

* **Time:** `O(n)` (Single pass through array)
* **Space:** `O(1)` (No extra storage)

---

### **Code**

```cpp
class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        long long result = 0;
        for (int num : nums) {
            result ^= num;
        }
        
        long long setBit = result & (-result); 
        // Alternatively: (result & (result - 1)) ^ result

        int grpA = 0, grpB = 0;
        for (int num : nums) {
            if (num & setBit) {
                grpA ^= num;
            } else {
                grpB ^= num;
            }
        }

        return {grpA, grpB};
    }
};
```

---
