Alright — I’ll rewrite your code into **full bit manipulation notes** with:

* **Organized sections**.
* **Dry run examples for every function**.
* **No parts skipped** — every single method in your `Solution` class will be documented.
* **Formatted explanations** so you can easily refer back while solving problems.

---

# **Bit Manipulation Notes with Dry Runs**

## **1. swapTwoNumber()**

**Purpose:** Swap two integers without using a temporary variable (using XOR).

**Code:**

```cpp
void swapTwoNumber(int &a, int &b) {
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;
}
```

**Logic:**

* `a ^ b` stores combined info of `a` and `b` in `a`.
* Using XOR properties:

  * `x ^ x = 0`
  * `x ^ 0 = x`
  * XOR is reversible.

**Dry Run:**

```
a = 5 (0101)
b = 10 (1010)

Step 1: a = a ^ b → 0101 ^ 1010 = 1111 (15)
Step 2: b = a ^ b → 1111 ^ 1010 = 0101 (5)
Step 3: a = a ^ b → 1111 ^ 0101 = 1010 (10)

Result: a = 10, b = 5
```

---

## **2. isIthBitSet()**

**Purpose:** Check if the `i`-th bit is set (1) in a number.

**Code:**

```cpp
bool isIthBitSet(int num, int i) {
    return (num & (1 << i)) != 0;
}
```

**Logic:**

* `(1 << i)` creates a mask with only the `i`th bit set.
* AND with `num` — if result is nonzero, that bit is set.

**Dry Run (num=5, i=1):**

```
num = 5 (0101)
Mask = 1 << 1 = 0010
0101 & 0010 = 0000 → bit is NOT set → false
```

---

## **3. setTheIthBit()**

**Purpose:** Set (make 1) the `i`-th bit.

**Code:**

```cpp
int setTheIthBit(int num, int i) {
    return num | (1 << i);
}
```

**Logic:**

* OR with mask sets the `i`th bit to 1 regardless of its previous state.

**Dry Run (num=5, i=2):**

```
num = 5 (0101)
Mask = 1 << 2 = 0100
0101 | 0100 = 0101 (no change, bit already set) → 5
```

---

## **4. cleanTheIthBit()**

**Purpose:** Clear (make 0) the `n`-th bit.

**Code:**

```cpp
int cleanTheIthBit(int num,int n){
    return num & ~(1 << n);
}
```

**Logic:**

* `(1 << n)` creates mask with 1 at `n`th bit.
* `~` flips it (1 → 0, 0 → 1).
* AND with `num` clears that bit.

**Dry Run (num=5, n=2):**

```
num = 0101
Mask = 1 << 2 = 0100
~Mask = 1011
0101 & 1011 = 0001 → 1
```

---

## **5. toggleTheIthBit()**

**Purpose:** Flip the `n`-th bit (1 → 0, 0 → 1).

**Code:**

```cpp
int toggleTheIthBit(int num, int n) {
    return num ^ (1 << n);
}
```

**Dry Run (num=5, n=1):**

```
num = 0101
Mask = 0010
0101 ^ 0010 = 0111 → 7
```

---

## **6. removeTheLastSet()**

**Purpose:** Remove the lowest set bit (rightmost 1).

**Code:**

```cpp
int removeTheLastSet(int num){
    return num & (num - 1);
}
```

**Logic:**

* `num - 1` flips all bits from the last set bit to the end.
* AND removes that set bit.

**Dry Run (num=12):**

```
num = 1100
num-1 = 1011
1100 & 1011 = 1000 (8)
```

---

## **7. checkIfItsAPowerOfTwo()**

**Purpose:** Check if a number is a power of two.

**Code (fixed precedence bug):**

```cpp
bool checkIfItsAPowerOfTwo(int num){
    return num > 0 && (num & (num - 1)) == 0;
}
```

**Logic:**

* Power of two has only one set bit → removing it makes number 0.

**Dry Run (num=8):**

```
8 = 1000
8-1 = 0111
1000 & 0111 = 0000 → true
```

---

## **8. countSetBitsUsingUnaryOperators()**

**Purpose:** Count set bits using `%` and `/`.

**Code:**

```cpp
int countSetBitsUsingUnaryOperators(int num){
    int count = 0;
    while(num > 1){
        if(num % 2 == 1) count++;
        num = num / 2;
    }
    if(num == 1) count++;
    return count;
}
```

**Dry Run (num=13):**

```
num=13 → 1101
13%2=1 → count=1 → num=6
6%2=0 → count=1 → num=3
3%2=1 → count=2 → num=1
num==1 → count=3
```

---

## **9. countSetBitsUsingBitOperators1()**

**Purpose:** Count set bits using bitwise AND and right shift.

**Code:**

```cpp
int countSetBitsUsingBitOperators1(int num){
    int count = 0;
    while(num > 1){
        if(num & 1) count++;
        num = num >> 1;
    }
    if(num == 1) count++;
    return count;
}
```

**Dry Run (num=13):**

```
1101 & 0001 = 1 → count=1 → num=110
0110 & 0001 = 0 → count=1 → num=11
0011 & 0001 = 1 → count=2 → num=1
num==1 → count=3
```

---

## **10. countSetBitsUsingBitOperators2()**

**Purpose:** Count set bits by removing last set bit repeatedly.

**Code:**

```cpp
int countSetBitsUsingBitOperators2(int num){
    int count = 0;
    while(num > 0){
        count++;
        num = num & (num - 1);
    }
    return count;
}
```

**Dry Run (num=13):**

```
num=1101 → count=1 → num=1100
num=1100 → count=2 → num=1000
num=1000 → count=3 → num=0000
```

---

## **Complete Example**

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // All methods here (same as above)...
};

int main() {
    Solution obj;
    int x = 5, y = 10;
    cout << "Before Swapping: x = " << x << " y = " << y << endl;
    obj.swapTwoNumber(x, y);
    cout << "After Swapping: x = " << x << " y = " << y << endl;

    cout << "Is 1st bit set in 5: " << obj.isIthBitSet(5, 1) << endl;
    cout << "Setting 2nd bit in 5: " << obj.setTheIthBit(5, 2) << endl;
}
```

---

