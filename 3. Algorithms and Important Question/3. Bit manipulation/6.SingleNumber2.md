## **Problem:** 137. Single Number II

**Link:** [https://leetcode.com/problems/single-number-ii/](https://leetcode.com/problems/single-number-ii/)

**Statement:**
Given an integer array `nums` where every element appears exactly three times except for one, which appears exactly once, return the single element.

---

## **Approaches**

### **1. Hash Map (Frequency Count)**

* **Idea:** Store frequency of each number in an unordered\_map and return the one with frequency `1`.
* **Time:** $O(N)$
* **Space:** $O(U)$ where $U$ = unique numbers.

```cpp
int singleNumber(vector<int>& nums) {
    unordered_map<int,int> freq;
    for (auto x : nums) freq[x]++;
    for (auto &p : freq) if (p.second == 1) return p.first;
    return -1;
}
```

---

### **2. Bit Counting**

* **Idea:**

  * For each of 32 bits, count how many numbers have that bit set.
  * If count % 3 != 0 → that bit belongs to the single number.
* **Time:** $O(32 \times N)$ ≈ $O(N)$
* **Space:** $O(1)$

```cpp
int singleNumber2(vector<int>& nums) {
    int ans = 0;
    for (int bit = 0; bit < 32; bit++) {
        int count = 0;
        for (int num : nums) {
            if (num & (1 << bit)) count++;
        }
        if (count % 3) ans |= (1 << bit);
    }
    return ans;
}
```

---

### **3. Sorting + Linear Scan**

* **Idea:** Sort, then check in steps of 3.
* **Time:** $O(N\log N)$
* **Space:** $O(1)$

```cpp
int singleNumber3(vector<int>& nums) {
    sort(nums.begin(), nums.end());
    int n = nums.size();
    if (n == 1) return nums[0];
    if (nums[0] != nums[1]) return nums[0];
    if (nums[n-1] != nums[n-2]) return nums[n-1];
    for (int i = 1; i < n-1; i += 3) {
        if (nums[i] != nums[i-1] && nums[i] != nums[i+1]) return nums[i];
    }
    return -1;
}
```

---

### **4. Bitmask Variables (`ones`, `twos`)**

* **Idea:** Track bits appearing once and twice using two variables:

  * `ones` → bits seen exactly once.
  * `twos` → bits seen exactly twice.
  * Third occurrence automatically clears bits from both.
* **Time:** $O(N)$
* **Space:** $O(1)$

```cpp
int singleNumber4(vector<int>& nums) {
    int ones = 0, twos = 0;
    for (int num : nums) {
        ones = (ones ^ num) & ~twos;
        twos = (twos ^ num) & ~ones;
    }
    return ones;
}
```

---

### **Why Approach 4 Works**

* **First pass:** number goes to `ones` (seen once).
* **Second pass:** number goes to `twos` (seen twice).
* **Third pass:** cleared from both (`seen thrice`).
* Only the unique number stays in `ones`.

---

✅ **Best Choice:**

* If space matters → **Approach 4 (bitmask)** or **Approach 2 (bit counting)**.
* If clarity matters → **Approach 1 (hash map)**.

---

# Dry run
Alright — let’s dry run **all 4 approaches** for `nums = [2, 2, 3, 2]` where `3` is the single number.

---

## **Approach 1: Hash Map**

```cpp
nums = [2, 2, 3, 2]
freq = {}

Iteration:
- num = 2 → freq[2] = 1
- num = 2 → freq[2] = 2
- num = 3 → freq[3] = 1
- num = 2 → freq[2] = 3

freq = { 2: 3, 3: 1 }

Traverse freq:
- freq[2] = 3 → skip
- freq[3] = 1 → return 3
```

**Output:** 3

---

## **Approach 2: Bit Counting**

```cpp
nums = [2, 2, 3, 2]
Binary forms:
2 → 0 1 0
3 → 0 1 1

For each bit position (0 to 31):
bit 0: count = (2:0) + (2:0) + (3:1) + (2:0) = 1 → 1 % 3 = 1 → set bit 0 in ans → ans = 001
bit 1: count = (2:1) + (2:1) + (3:1) + (2:1) = 4 → 4 % 3 = 1 → set bit 1 in ans → ans = 011
bit 2+: all counts divisible by 3 → no change

Final ans = binary(011) = 3
```

**Output:** 3

---

## **Approach 3: Sorting + Linear Scan**

```cpp
nums = [2, 2, 3, 2]
Sorted: [2, 2, 2, 3]

n = 4
Check edges:
- nums[0] != nums[1]? (2 != 2) → no
- nums[n-1] != nums[n-2]? (3 != 2) → yes → return 3
```

**Output:** 3

---

## **Approach 4: Bitmask (`ones`, `twos`)**

```cpp
nums = [2, 2, 3, 2]
ones = 0, twos = 0

i=0, num=2 (10):
ones = (0 ^ 10) & ~0  = 10 & 11 = 10
twos = (0 ^ 10) & ~10 = 10 & 01 = 00

i=1, num=2 (10):
ones = (10 ^ 10) & ~00 = 00 & 11 = 00
twos = (00 ^ 10) & ~00 = 10 & 11 = 10

i=2, num=3 (11):
ones = (00 ^ 11) & ~10 = 11 & 01 = 01
twos = (10 ^ 11) & ~01 = 01 & 10 = 00

i=3, num=2 (10):
ones = (01 ^ 10) & ~00 = 11 & 11 = 11
twos = (00 ^ 10) & ~11 = 10 & 00 = 00

Final:
ones = 11 (binary) = 3
```

**Output:** 3

---



# DFA diagram 

```plantUML
@startuml
!theme plain
title Single Number II - Bitmask DFA (Bit-level State Machine)

[*] --> S0 : Initialize
S0 --> S1 : Encounter bit\n(1st occurrence)
S1 --> S2 : Encounter bit\n(2nd occurrence)  
S2 --> S0 : Encounter bit\n(3rd occurrence)\n<color:red>(Reset cycle)</color>

state "State 0" as S0 {
  S0 : **Bit Count: 0 mod 3**
  S0 : ones = 0, twos = 0
  S0 : <color:green>Bit not present or reset</color>
}

state "State 1" as S1 {
  S1 : **Bit Count: 1 mod 3**
  S1 : ones = 1, twos = 0
  S1 : <color:blue>Bit seen once (contributes to result)</color>
}

state "State 2" as S2 {
  S2 : **Bit Count: 2 mod 3**
  S2 : ones = 0, twos = 1
  S2 : <color:orange>Bit seen twice (will reset next)</color>
}

note right of S0
  Initial state for each bit position
  Also the reset state after 3 occurrences
  Final answer comes from bits in this state
end note

note right of S1
  Tracks first occurrence of bit
  These bits form the unique number
  (appears only once while others appear 3 times)
end note

note right of S2
  Tracks second occurrence of bit
  Temporary state before reset
  Prevents bit from appearing in final result
end note

note bottom
  **Algorithm Logic:**
  For each bit position, track occurrences mod 3
  ones ^= (num & ~twos)
  twos ^= (num & ~ones)
end note
@enduml
```