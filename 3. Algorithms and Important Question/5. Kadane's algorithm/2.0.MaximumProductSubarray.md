## **Problem Statement**

Given an integer array `arr[]`, find the contiguous subarray (containing at least one number) which has the **largest product** and return the product.

Example:

```
Input: arr = [-2, 6, -3, -10, 0, 2]
Output: 180
Explanation: The subarray [6, -3, -10] has product 180.
```

---

## **Approach 1 â€“ Brute Force**

### **Intuition**

* Check **all possible subarrays**.
* Calculate the product of each subarray.
* Keep track of the **maximum product** found.

This is the direct way: no special tricks, just multiply all combinations.

---

### **Algorithm**

1. Initialize `maxProd = arr[0]`.
2. For every starting index `i`:

   * Set `mul = 1`.
   * For every ending index `j â‰¥ i`:

     * Multiply `mul` by `arr[j]`.
     * Update `maxProd` if `mul` is greater.
3. Return `maxProd`.

---

### **Code**

```cpp
int maxProduct(vector<int> &arr) {
    int n = arr.size();
    int maxProd = arr[0];
    for (int i = 0; i < n; i++) {
        int mul = 1;
        for (int j = i; j < n; j++) {
            mul *= arr[j];
            maxProd = max(maxProd, mul);
        }
    }
    return maxProd;
}
```

---

### **Complexity**

* **Time:** O(nÂ²) â€” double loop.
* **Space:** O(1).

---

## **Approach 2 â€“ Dynamic Programming (Kadaneâ€™s Variant)**

### **Intuition**

* **Why Kadaneâ€™s variant?** Because negative numbers flip signs:

  * A large **negative min** can become a **large positive** if multiplied by another negative.
* So, at each index:

  * Maintain **max product ending here**.
  * Maintain **min product ending here**.
* Swap roles when negatives appear.

---

### **Key Idea**

At each position, decide:

* **Extend** the previous subarray (multiply current element with `maxSoFar` or `minSoFar`)
* **Or start fresh** from the current element

Why track `minSoFar`?

* A negative number can turn the smallest product into the largest when multiplied.

Keep updating:

* `maxSoFar` â†’ maximum product ending at current index
* `minSoFar` â†’ minimum product ending at current index (for handling negatives)
* `result` â†’ overall maximum product found so far

---

### **Algorithm**

1. Initialize:

   * `currMax = arr[0]` (max product ending at current position)
   * `currMin = arr[0]` (min product ending at current position)
   * `maxProd = arr[0]` (overall max)
2. Loop from `i = 1` to `n-1`:

   * Store temporary max:
     `temp = max(arr[i], arr[i] * currMax, arr[i] * currMin)`
   * Update `currMin = min(arr[i], arr[i] * currMax, arr[i] * currMin)`
   * Set `currMax = temp`
   * Update `maxProd = max(maxProd, currMax)`
3. Return `maxProd`.

---

### **Code**

```cpp
int maxProduct(vector<int> &arr) {
    int n = arr.size();
    int currMax = arr[0], currMin = arr[0], maxProd = arr[0];
    for (int i = 1; i < n; i++) {
        int temp = max({arr[i], arr[i] * currMax, arr[i] * currMin});
        currMin = min({arr[i], arr[i] * currMax, arr[i] * currMin});
        currMax = temp;
        maxProd = max(maxProd, currMax);
    }
    return maxProd;
}
```

---

### **Complexity**

* **Time:** O(n) â€” single pass.
* **Space:** O(1).

---

## **Approach 3 â€“ Prefix/Suffix Scan**

### **Intuition**

* Idea: If we scan left-to-right and right-to-left, we catch all possible subarrays:

  * Negative numbers can flip sign, so scanning both ways covers all.
  * Zeros reset the product (start fresh).
* Keep track of the product in both directions.

---

### **Algorithm**

1. Initialize:

   * `leftToRight = 1`, `rightToLeft = 1`, `maxProd = INT_MIN`
2. Loop `i` from `0` to `n-1`:

   * If `leftToRight == 0` â†’ reset to `1`
   * If `rightToLeft == 0` â†’ reset to `1`
   * Multiply:

     * `leftToRight *= arr[i]`
     * `rightToLeft *= arr[n-i-1]`
   * Update `maxProd = max(maxProd, leftToRight, rightToLeft)`
3. Return `maxProd`.

---

### **Code**

```cpp
int maxProduct(vector<int> &arr) {
    int n = arr.size();
    int maxProd = INT_MIN, leftToRight = 1, rightToLeft = 1;
    for (int i = 0; i < n; i++) {
        if (leftToRight == 0) leftToRight = 1;
        if (rightToLeft == 0) rightToLeft = 1;
        leftToRight *= arr[i];
        rightToLeft *= arr[n - i - 1];
        maxProd = max({maxProd, leftToRight, rightToLeft});
    }
    return maxProd;
}
```

---

### **Complexity**

* **Time:** O(n)
* **Space:** O(1)

---

âœ… **Summary Table**

| Approach                 | Idea                    | Time  | Space | Notes               |
| ------------------------ | ----------------------- | ----- | ----- | ------------------- |
| 1. Brute Force           | Try all subarrays       | O(nÂ²) | O(1)  | Easy but slow       |
| 2. DP (Kadaneâ€™s Variant) | Track currMax & currMin | O(n)  | O(1)  | Most common         |
| 3. Prefix/Suffix         | Two scans, catch flips  | O(n)  | O(1)  | Clean and intuitive |

---

# Dry Run
**Approach 2 (Kadane-like)** and **Approach 3 (Two-direction scan)** step-by-step with the given array:

`arr = { -2, 6, -3, -10, 0, 2 }`

---

## **ðŸ”¹ Approach 2: Kadane-like with max & min tracking**

We keep:

* `currMax` â†’ maximum product ending at current index
* `currMin` â†’ minimum product ending at current index (needed because a negative Ã— negative can become positive)
* `maxProd` â†’ overall maximum product so far

**Initialization**:

```
currMax = -2
currMin = -2
maxProd = -2
```

**i = 1 â†’ arr\[i] = 6**

```
temp = max(6, 6 * -2, 6 * -2) = max(6, -12, -12) = 6
currMin = min(6, 6 * -2, 6 * -2) = min(6, -12, -12) = -12
currMax = temp = 6
maxProd = max(-2, 6) = 6
```

**i = 2 â†’ arr\[i] = -3**

```
temp = max(-3, -3 * 6, -3 * -12) = max(-3, -18, 36) = 36
currMin = min(-3, -3 * 6, -3 * -12) = min(-3, -18, 36) = -18
currMax = temp = 36
maxProd = max(6, 36) = 36
```

**i = 3 â†’ arr\[i] = -10**

```
temp = max(-10, -10 * 36, -10 * -18) = max(-10, -360, 180) = 180
currMin = min(-10, -10 * 36, -10 * -18) = min(-10, -360, 180) = -360
currMax = temp = 180
maxProd = max(36, 180) = 180
```

**i = 4 â†’ arr\[i] = 0**

```
temp = max(0, 0 * 180, 0 * -360) = 0
currMin = min(0, 0 * 180, 0 * -360) = 0
currMax = temp = 0
maxProd = max(180, 0) = 180
```

**i = 5 â†’ arr\[i] = 2**

```
temp = max(2, 2 * 0, 2 * 0) = 2
currMin = min(2, 2 * 0, 2 * 0) = 0
currMax = temp = 2
maxProd = max(180, 2) = 180
```

âœ… **Final Answer (Approach 2)** = **180**

---

## **ðŸ”¹ Approach 3: Two-direction product scan**

We track:

* `leftToRight` â†’ product scanning from left to right
* `rightToLeft` â†’ product scanning from right to left
* Reset product to `1` if we hit zero

**Initialization**:

```
maxProd = INT_MIN
leftToRight = 1
rightToLeft = 1
```

---

**i = 0**

```
leftToRight *= arr[0] = 1 * -2 = -2
j = 5 â†’ rightToLeft *= arr[5] = 1 * 2 = 2
maxProd = max(-2, 2, INT_MIN) = 2
```

**i = 1**

```
leftToRight *= 6 â†’ -2 * 6 = -12
j = 4 â†’ rightToLeft *= 0 â†’ 2 * 0 = 0
maxProd = max(-12, 0, 2) = 2
```

**i = 2**

```
leftToRight *= -3 â†’ -12 * -3 = 36
j = 3 â†’ rightToLeft == 0 â†’ set to 1 â†’ 1 * -10 = -10
maxProd = max(36, -10, 2) = 36
```

**i = 3**

```
leftToRight *= -10 â†’ 36 * -10 = -360
j = 2 â†’ rightToLeft *= -3 â†’ -10 * -3 = 30
maxProd = max(-360, 30, 36) = 36
```

**i = 4**

```
leftToRight *= 0 â†’ -360 * 0 = 0
j = 1 â†’ rightToLeft *= 6 â†’ 30 * 6 = 180
maxProd = max(0, 180, 36) = 180
```

**i = 5**

```
leftToRight == 0 â†’ reset to 1 â†’ 1 * 2 = 2
j = 0 â†’ rightToLeft *= -2 â†’ 180 * -2 = -360
maxProd = max(2, -360, 180) = 180
```

âœ… **Final Answer (Approach 3)** = **180**

---
