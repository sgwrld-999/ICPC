## **Kadane’s Algorithm – Theory Note**

### **Problem Statement**

Find the **maximum sum of a contiguous subarray** in a given array.

---

## **1. Brute Force Approach**

**Idea**

* Try all possible subarrays and compute their sums.
* Keep track of the maximum sum found.

**Steps**

1. Start from each index `i`.
2. For each `i`, extend to index `j` and calculate sum.
3. Keep updating the maximum sum.

**Code Complexity**

* **Time Complexity**: $O(n^2)$ (two nested loops)
* **Space Complexity**: $O(1)$ (no extra space used)

**Example Dry Run**:
Array: `[2, 3, -8, 7, -1, 2, 3]`

* Try all subarrays → max sum = **11** (from subarray `[7, -1, 2, 3]`).

---

**Code – Brute Force**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int maxSubarraySum(vector<int> &arr) {
    int res = arr[0];
  
    // Outer loop for starting point of subarray
    for (int i = 0; i < arr.size(); i++) {
        int currSum = 0;
      
        // Inner loop for ending point of subarray
        for (int j = i; j < arr.size(); j++) {
            currSum += arr[j];
            res = max(res, currSum);
        }
    }
    return res;
}

int main() {
    vector<int> arr = {2, 3, -8, 7, -1, 2, 3};
    cout << maxSubarraySum(arr);
    return 0;
}
```

## **2. Kadane’s Algorithm**

**Need for Kadane’s**

* Brute force is slow for large `n` (up to $10^5$ or more).
* Kadane’s finds the answer in **O(n)** time.

---

### **Key Idea**

At each position, decide:

* **Extend** the previous subarray (add current element)
* **Or start fresh** from the current element

This decision is made using:

$$
\text{maxEndingHere} = \max(\text{arr[i]}, \text{maxEndingHere} + \text{arr[i]})
$$

Then update:

$$
\text{maxSoFar} = \max(\text{maxSoFar}, \text{maxEndingHere})
$$

---

### **Algorithm Steps**

1. Initialize:

   * `maxEndingHere = arr[0]`
   * `maxSoFar = arr[0]`
2. Loop from `i = 1` to `n-1`:

   * Update `maxEndingHere`
   * Update `maxSoFar`
3. Return `maxSoFar`

---

**Code – Kadane’s**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int maxSubarraySum(vector<int> &arr) {
    int res = arr[0];         // Stores the result (max sum so far)
    int maxEnding = arr[0];   // Max sum of subarray ending here

    for (int i = 1; i < arr.size(); i++) {
        maxEnding = max(arr[i], maxEnding + arr[i]);
        res = max(res, maxEnding);
    }
    return res;
}

int main() {
    vector<int> arr = {2, 3, -8, 7, -1, 2, 3};
    cout << maxSubarraySum(arr); 
    return 0;
}
```

---

### **Dry Run Example**

Array: `[2, 3, -8, 7, -1, 2, 3]`

* **Initial**: `maxEndingHere = 2`, `maxSoFar = 2`
* i=1 → `maxEndingHere = max(3, 2+3) = 5` → `maxSoFar = 5`
* i=2 → `maxEndingHere = max(-8, 5-8) = -3` → `maxSoFar = 5`
* i=3 → `maxEndingHere = max(7, -3+7) = 7` → `maxSoFar = 7`
* i=4 → `maxEndingHere = max(-1, 7-1) = 6` → `maxSoFar = 7`
* i=5 → `maxEndingHere = max(2, 6+2) = 8` → `maxSoFar = 8`
* i=6 → `maxEndingHere = max(3, 8+3) = 11` → `maxSoFar = 11`

**Result** = **11**

---

### **Complexity**

* **Time**: $O(n)$
* **Space**: $O(1)$

---

### **Advantages**

* Works in **linear time** → suitable for large arrays.
* No extra space.
* Can be modified to track subarray indices.

---

### **Applications**

* **Stock market analysis** → max profit in a single buy-sell (if modified).
* **Game development** → max consecutive gain/loss streak.
* **Data analytics** → longest period of positive trends.
* **Dynamic programming problems** → base for variations like circular subarray sum.

---

