## **1. Problem Recap**

We have a number (e.g., `2736`) and can swap **at most one pair of digits** to get the maximum possible number.
We need to find **which two digits to swap**.

---

## **2. Naive thinking**

If we try **all pairs of swaps** and pick the max, it’s

* Time: $O(n^2)$ (too slow for large n)
* Not elegant.

Instead, notice:

* The **best swap** is one where a **larger digit** appears later in the number, and we bring it forward.

---

## **3. Key Intuition**

When scanning **from left to right**:

* At each position `i`, ask:

  > “Is there a larger digit **somewhere after me**?”
  > If yes, swapping with the **rightmost occurrence** of that largest digit gives the biggest number.

Why **rightmost**?

* If there are multiple same large digits, swapping with the farthest one changes later digits as little as possible — keeping the earlier digits bigger for the result.

---

## **4. How the code works**

### Step 1 — Record last occurrence of each digit

```cpp
vector<int> lastOcc(10, -1);  
for (int i = 0; i < n; i++) {
    lastOcc[numStr[i] - '0'] = i;
}
```

Example:
For `2736`,

```
Digit:   0 1 2 3 4 5 6 7 8 9
Index:  -1 -1 0 2 -1 -1 3 1 -1 -1
```

Meaning: digit `2` last seen at index 0, digit `7` at index 1, digit `6` at index 3, etc.

---

### Step 2 — Scan left to right

```cpp
for (int i = 0; i < n; i++) {
    for (int digit = 9; digit > numStr[i] - '0'; digit--) {
        if (lastOcc[digit] > i) {
            swap(numStr[i], numStr[lastOcc[digit]]);
            return stoi(numStr);
        }
    }
}
```

For each position `i`:

1. Look for a **bigger digit** than `numStr[i]` (start from 9 and go down).
2. Check if it **appears later** in the number (`lastOcc[digit] > i`).
3. If yes → swap and return.

---

## **5. Example Walkthrough**

Number: `2736`

* i = 0 → digit = 2

  * Look for 9,8,7,…
  * Found: digit 7 at index 1 → swap → `7236` → done.

Number: `98368`

* i = 0 → digit = 9

  * No bigger digit (skip).
* i = 1 → digit = 8

  * Found: digit 8 later, but same → skip (need strictly greater).
* i = 2 → digit = 3

  * Found: digit 8 at index 4 → swap → `98863`.

---

## **6. Why this is Optimal**

* The **first** swap found during left→right scan maximizes the *most significant position* first.
* Choosing the **rightmost occurrence** of the bigger digit ensures minimal harm to later digits.
* Runs in $O(n)$ since the inner loop is constant 10 checks.

---

## **7. Complexity**

* Time: $O(n)$ (n is length of number)
* Space: $O(1)$ extra space (lastOcc is always size 10)

---
Got it — this Java code uses a **math-based approach** that avoids string conversions, and it works in **O(log₁₀n)** time because it processes digits directly.

Let’s first **convert it to C++** and then I’ll explain the **working + intuition** step-by-step.

---

## **C++ Version**

```cpp
class Solution {
public:
    int maximumSwap(int num) {
        int num2 = num;           // Copy to work with
        int steps = 0;            // Position counter (units = 0, tens = 1, etc.)
        int digit = -1;           // Largest digit seen so far from the right
        int digitStep = -1;       // Position of that largest digit
        int res = 0;              // Result after swap

        while (num2 != 0) {
            int r = num2 % 10;    // Current digit from right to left
            int pow10 = (int)pow(10, steps);        // 10^steps
            int digitPow10 = (int)pow(10, digitStep); // 10^digitStep

            if (digit > r) {
                // Found a place to swap: swap current digit r with largest digit seen later
                res = num + (digit - r) * (pow10 - digitPow10);
            } 
            else if (digit < r) {
                // Update largest digit seen so far
                digit = r;
                digitStep = steps;
            }

            num2 /= 10;  // Move to next digit (leftwards)
            steps++;
        }

        return max(num, res);
    }
};
```

---

## **How it works (Intuition)**

### **1. Core Idea**

Instead of converting to a string, we:

* Process digits from **right to left** (units place → highest place).
* Track:

  * `digit`: the **largest digit seen so far** from the right side.
  * `digitStep`: its **position** (distance from right, 0-based).
* If we find a digit that’s **smaller** than the largest digit to its right,
  → That’s a swap opportunity to maximize the number.

---

### **2. Step-by-step on example**

Example: **`2736`**

#### Initial:

```
num   = 2736
steps = 0
digit = -1
digitStep = -1
res   = 0
```

---

#### Iteration 1: steps = 0 → r = 6

* `digit < r` → update `digit = 6`, `digitStep = 0`.

---

#### Iteration 2: steps = 1 → r = 3

* `digit (6) > r (3)` → swap opportunity:

  ```
  pow10 = 10^1 = 10
  digitPow10 = 10^0 = 1
  res = num + (6 - 3) * (10 - 1)
      = 2736 + 3 * 9
      = 2736 + 27
      = 2763
  ```

---

#### Iteration 3: steps = 2 → r = 7

* `digit (6) < r (7)` → update `digit = 7`, `digitStep = 2`.

---

#### Iteration 4: steps = 3 → r = 2

* `digit (7) > r (2)` → swap opportunity:

  ```
  pow10 = 10^3 = 1000
  digitPow10 = 10^2 = 100
  res = 2736 + (7 - 2) * (1000 - 100)
      = 2736 + 5 * 900
      = 2736 + 4500
      = 7236  ✅ (better)
  ```

---

At the end: `max(num, res)` → `max(2736, 7236) = 7236`.

---

### **3. Why `(pow10 - digitPow10)` works**

We’re adding:

$$
(\text{digit} - r) \times (10^{\text{steps}} - 10^{\text{digitStep}})
$$

* `10^steps` → place value of current digit (`r`)
* `10^digitStep` → place value of best digit to swap with
* Subtracting them adjusts both positions in one go.

---

### **4. Complexity**

* Time: $O(\log_{10} n)$ → because we iterate through each digit once
* Space: $O(1)$

---

