## **1. Problem Recap**

We have a number (e.g., `2736`) and can swap **at most one pair of digits** to get the maximum possible number.
We need to find **which two digits to swap**.

---

## **2. Naive thinking**

If we try **all pairs of swaps** and pick the max, it’s

* Time: $O(n^2)$ (too slow for large n)
* Not elegant.

Instead, notice:

* The **best swap** is one where a **larger digit** appears later in the number, and we bring it forward.

---

## **3. Key Intuition**

When scanning **from left to right**:

* At each position `i`, ask:

  > “Is there a larger digit **somewhere after me**?”
  > If yes, swapping with the **rightmost occurrence** of that largest digit gives the biggest number.

Why **rightmost**?

* If there are multiple same large digits, swapping with the farthest one changes later digits as little as possible — keeping the earlier digits bigger for the result.

---

## **4. How the code works**

### Step 1 — Record last occurrence of each digit

```cpp
vector<int> lastOcc(10, -1);  
for (int i = 0; i < n; i++) {
    lastOcc[numStr[i] - '0'] = i;
}
```

Example:
For `2736`,

```
Digit:   0 1 2 3 4 5 6 7 8 9
Index:  -1 -1 0 2 -1 -1 3 1 -1 -1
```

Meaning: digit `2` last seen at index 0, digit `7` at index 1, digit `6` at index 3, etc.

---

### Step 2 — Scan left to right

```cpp
for (int i = 0; i < n; i++) {
    for (int digit = 9; digit > numStr[i] - '0'; digit--) {
        if (lastOcc[digit] > i) {
            swap(numStr[i], numStr[lastOcc[digit]]);
            return stoi(numStr);
        }
    }
}
```

For each position `i`:

1. Look for a **bigger digit** than `numStr[i]` (start from 9 and go down).
2. Check if it **appears later** in the number (`lastOcc[digit] > i`).
3. If yes → swap and return.

---

## **5. Example Walkthrough**

Number: `2736`

* i = 0 → digit = 2

  * Look for 9,8,7,…
  * Found: digit 7 at index 1 → swap → `7236` → done.

Number: `98368`

* i = 0 → digit = 9

  * No bigger digit (skip).
* i = 1 → digit = 8

  * Found: digit 8 later, but same → skip (need strictly greater).
* i = 2 → digit = 3

  * Found: digit 8 at index 4 → swap → `98863`.

---

## **6. Why this is Optimal**

* The **first** swap found during left→right scan maximizes the *most significant position* first.
* Choosing the **rightmost occurrence** of the bigger digit ensures minimal harm to later digits.
* Runs in $O(n)$ since the inner loop is constant 10 checks.

---

## **7. Complexity**

* Time: $O(n)$ (n is length of number)
* Space: $O(1)$ extra space (lastOcc is always size 10)

---
