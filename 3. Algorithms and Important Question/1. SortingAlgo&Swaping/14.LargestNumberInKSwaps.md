
Original Code:

Here’s the note for your **Previous Permutation With One Swap** code in the same style as your example.

---

## **1. Restating the problem**

We have:

* An array of integers (values can be more than 9, so not just digits)
* We can perform **at most one swap** of two elements
* We want the **largest possible permutation that is smaller than the current one**

---

## **2. Why “drop point from right” comes into play**

The main insight:

* If we scan from **right to left**, the first place where the sequence stops being non-decreasing (i.e. `A[i] > A[i+1]`) is where we can make it smaller.
* We should swap this element with the **largest number on its right that is still less than it**.
* If duplicates exist, pick the **leftmost occurrence** of that candidate to ensure the result is the immediate previous permutation.

Example:

```
A = [3, 2, 1]
From right: drop point at i = 0 (3 > 2)
Right side candidates < 3: {2, 1}, largest is 2 → swap → [2, 3, 1]
```

---

## **3. The “pattern” that leads to this**

This problem is the “previous permutation” counterpart to next permutation:

**Pattern:**

* From right to left, find the **first decrease** → index `i`.
* On the right side of `i`, choose the **max element less than A\[i]**.
* Handle duplicates by moving left to the first occurrence of that chosen value.
* Swap and return.

This guarantees the result is:

* **Just smaller** than the original
* **Largest possible** among smaller permutations

---

## **4. Correct logic**

General approach:

1. Traverse from right to left to find first index `i` where `A[i] > A[i+1]`.
2. If no such `i`, the array is the smallest permutation → return as is.
3. Find `j` in `A[i+1...n-1]` that has the largest value `< A[i]`.
4. If duplicates of `A[j]` exist, pick the **leftmost** such `j` to avoid over-decreasing.
5. Swap `A[i]` and `A[j]`.
6. Return array.

---

## **5. Final C++ code**

```cpp
class Solution {
public:
    vector<int> prevPermOpt1(vector<int>& A) {
        int n = A.size();
        int i = n - 2;

        // 1) find first decreasing element from the right
        while (i >= 0 && A[i] <= A[i + 1]) --i;
        if (i < 0) return A; // already smallest

        // 2) find rightmost element less than A[i]
        int j = n - 1;
        while (A[j] >= A[i]) --j;

        // 3) move left if there are duplicates of A[j]
        while (j - 1 > i && A[j - 1] == A[j]) --j;

        // 4) swap once
        swap(A[i], A[j]);
        return A;
    }
};
```

---

## **6. Example dry run**

`A = [3, 1, 1, 3]`

* Step 1 — find `i`:

  ```
  Compare from right: 1 < 3 → drop at i = 2? No, 1 == 1; keep going
  Found at i = 0 (3 > 1)
  ```
* Step 2 — find largest less than `A[0]` (=3) to the right:

  ```
  Candidates: {1, 1, 3} → largest < 3 is 1 at index 2
  ```
* Step 3 — duplicates? index 1 and 2 both have 1 → pick leftmost (index 1)
* Step 4 — swap:

  ```
  Swap A[0] and A[1] → [1, 3, 1, 3]
  ```

---

## **7. How to think from the start**

Instead of:

> “I’ll use last occurrence like digit problems.”

You should ask:

* “What is the first place from the right where the array decreases?”
* “What’s the largest possible number I can put there to make it just smaller?”
* “If there are duplicates, which occurrence do I choose to stay closest to the original?”


---

## **Step-by-step dry run**

### **Iteration 1 — i = 0**

* `num[0] = '1'`
* Search for the largest digit in positions `1...8`:

  ```
  Right side: 2, 9, 8, 1, 4, 9, 9, 9
  Largest digit: '9'
  Rightmost occurrence: index 8
  ```
* Since `'9' > '1'`, swap index 0 and 8:

```
Before swap: 1 2 9 8 1 4 9 9 9
After swap : 9 2 9 8 1 4 9 9 1
k = 3
```

---

### **Iteration 2 — i = 1**

* `num[1] = '2'`
* Search in positions `2...8`:

  ```
  Right side: 9, 8, 1, 4, 9, 9, 1
  Largest digit: '9'
  Rightmost occurrence: index 6
  ```
* `'9' > '2'` → swap index 1 and 6:

```
Before swap: 9 2 9 8 1 4 9 9 1
After swap : 9 9 9 8 1 4 2 9 1
k = 2
```

---

### **Iteration 3 — i = 2**

* `num[2] = '9'`
* Search in positions `3...8`:

  ```
  Right side: 8, 1, 4, 2, 9, 1
  Largest digit: '9'
  Rightmost occurrence: index 7
  ```
* `'9' == '9'` → no beneficial swap (same value at earlier place).
* **No swap made.**
  `k` stays `2`.

---

### **Iteration 4 — i = 3**

* `num[3] = '8'`
* Search in positions `4...8`:

  ```
  Right side: 1, 4, 2, 9, 1
  Largest digit: '9'
  Rightmost occurrence: index 7
  ```
* `'9' > '8'` → swap index 3 and 7:

```
Before swap: 9 9 9 8 1 4 2 9 1
After swap : 9 9 9 9 1 4 2 8 1
k = 1
```

---

### **Iteration 5 — i = 4**

* `num[4] = '1'`
* Search in positions `5...8`:

  ```
  Right side: 4, 2, 8, 1
  Largest digit: '8'
  Rightmost occurrence: index 7
  ```
* `'8' > '1'` → swap index 4 and 7:

```
Before swap: 9 9 9 9 1 4 2 8 1
After swap : 9 9 9 9 8 4 2 1 1
k = 0  ✅
```

We’re out of swaps.

---

## **Final result**

```
"999984211"
```

---

### **Key observations from the dry run**

1. At each step, we **picked the largest possible digit from the right**, choosing the **rightmost** one for minimal disturbance later.
2. We **stopped when k = 0**, even if more beneficial swaps existed.
3. This approach is **greedy**, always maximizing the leftmost position first → ensures global max number in minimal swaps.

---
