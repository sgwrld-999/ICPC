
Original Code:

```cpp
class Solution {
public:
    vector<int> prevPermOpt1(vector<int>& nums) {
        int n = nums.size();
        if(n == 1 || n == 2) return nums;
        vector<int> idxVec(10,-1);

        last occurence
        for(int i = 0; i < n ; i++){
            idxVec[nums[i]] = i ;
        }

        for(int i = 1 ; i < n ; i++){
            for(int i = 9 ; i >= 0 ; i++){
                if(idxVec[nums[i]] > i){
                    swap(nums[idxVec[nums[i]]],nums[i]);
                    return nums;
                }
            }
        }
        return nums;
    }
};
```

## **1. The bug in your current approach**

You did:

```cpp
vector<int> idxVec(10, -1);
```

This assumes **every element in `nums` is a single digit (0–9)**, but in the problem, elements can be larger (e.g., 123, 54).

When you do:

```cpp
idxVec[nums[i]] = i;
```

If `nums[i] > 9`, this will write **outside the vector bounds** → **heap overflow**.

---

## **2. Why the “last occurrence of digits” logic doesn’t apply here**

That “last occurrence” method works for **maximum swap problems with digits**, because:

* Digits are in a fixed range (0–9)
* You can pre-store positions in a size 10 array

But here, `nums` can contain **any integers**, so you can’t index directly by their value.
Even more importantly:
The **goal** here is **Previous Permutation with One Swap**, which is not “swap with last occurrence of larger number” — it’s a different pattern.

---

## **3. Correct way to think from the start**

Let’s break down the **intended problem logic**:

We want the **largest possible permutation that is smaller than the current one**, by swapping exactly one pair.

That’s basically:

* Find the **first index from the right** where the sequence stops being non-decreasing — this is the "drop point" where we can make the number smaller.
* Find the **largest number to the right** of that index which is still **less** than it, but **pick the leftmost occurrence** of that number (to avoid multiple swaps giving the same permutation).
* Swap and return.

---

## **4. Step-by-step algorithm**

Example:

```
nums = [3, 2, 1]
```

### Step 1 — Find the drop index

We move from right to left until we find `nums[i] > nums[i+1]`.

```cpp
for (i = n - 2; i >= 0; i--) {
    if (nums[i] > nums[i + 1]) break;
}
```

If no such `i` → already smallest permutation → return nums.

---

### Step 2 — Find the best candidate to swap

We want the **largest** number in `nums[i+1...n-1]` that is `< nums[i]`.
But careful: if duplicates exist, **pick the leftmost** occurrence among those duplicates.

---

### Step 3 — Swap and return

This ensures only **one swap** and the result is the immediate previous permutation.

---

## **5. Correct C++ solution**

```cpp
class Solution {
public:
    vector<int> prevPermOpt1(vector<int>& nums) {
        int n = nums.size();
        
        // Step 1: find first decreasing element from the right
        int i = n - 2;
        while (i >= 0 && nums[i] <= nums[i + 1]) {
            i--;
        }
        if (i < 0) return nums; // already smallest
        
        // Step 2: find largest number < nums[i] to the right
        int j = n - 1;
        int maxIndex = -1;
        for (int k = n - 1; k > i; k--) {
            if (nums[k] < nums[i]) {
                if (maxIndex == -1 || nums[k] > nums[maxIndex]) {
                    maxIndex = k;
                }
                // Avoid duplicates: stop at leftmost largest
                while (k > i + 1 && nums[k] == nums[k - 1]) {
                    k--;
                }
                break;
            }
        }
        
        // Step 3: swap
        swap(nums[i], nums[maxIndex]);
        return nums;
    }
};
```

---

## **6. How you should have thought about it**

Instead of:

> “I’ll use last occurrence array like in digit problems.”

You should have asked:

* **What makes a permutation smaller than the current one?**
* Answer: Swap a bigger number on the left with a smaller number on the right — but as far to the left as possible to minimize change.
* Then:

  1. Find first drop index from right.
  2. Find largest smaller element to the right.
  3. Handle duplicates carefully.
  4. Swap once.

That’s a **pattern for "previous permutation with one swap"** problems.

---

# Dry Run:

**Full dry run** of the **`prevPermOpt1`** algorithm on:

```
[2, 34, 5, 2, 523, 4, 5, 23]
```

---

## **Step 0 — Problem restatement**

We want the **largest permutation smaller than the current one**, with exactly **one swap**.

---

## **Step 1 — Find the first drop index `i` (right to left)**

We scan from `n-2` downwards:

Array indices:

```
0   1   2   3    4    5   6    7
[2, 34, 5, 2, 523, 4, 5, 23]
```

Start:

```
i = 6 → nums[6] = 5, nums[7] = 23 → 5 <= 23 ✅ keep going
i = 5 → nums[5] = 4, nums[6] = 5  → 4 <= 5  ✅ keep going
i = 4 → nums[4] = 523, nums[5] = 4 → 523 > 4 ❌ stop here
```

**Found**: `i = 4` (value = `523`) → This is the **drop point**.

Meaning: from index 5 to the end, the numbers are already in **increasing** order from right to left, so swapping something before index 5 will make the number smaller.

---

## **Step 2 — Find largest number < nums\[i] in the right side**

We look in `nums[5...7]`:

```
nums[i] = 523
Right side = [4, 5, 23]
```

* We need the **largest value < 523**.
* Candidates: `4`, `5`, `23` → max is `23`.

Now **find the leftmost occurrence** of `23` from the right side:

* Rightmost to left: index 7 → 23 < 523 ✅ choose this.

**maxIndex = 7** (value `23`).

---

## **Step 3 — Swap**

Swap `nums[i]` and `nums[maxIndex]`:

```
Before: [2, 34, 5, 2, 523, 4, 5, 23]
Swap i=4 (523) with maxIndex=7 (23)
After:  [2, 34, 5, 2, 23, 4, 5, 523]
```

---

## **Step 4 — Return result**

Final result:

```
[2, 34, 5, 2, 23, 4, 5, 523]
```

---

### **Full dry run table**

| Step           | i | nums\[i] | Right side considered | Candidate chosen | maxIndex | Swap result                   |
| -------------- | - | -------- | --------------------- | ---------------- | -------- | ----------------------------- |
| Find i         | 4 | 523      | \[4, 5, 23]           | —                | —        | —                             |
| Pick candidate | 4 | 523      | \[4, 5, 23]           | 23               | 7        | —                             |
| Swap           | — | —        | —                     | —                | —        | \[2, 34, 5, 2, 23, 4, 5, 523] |

---

