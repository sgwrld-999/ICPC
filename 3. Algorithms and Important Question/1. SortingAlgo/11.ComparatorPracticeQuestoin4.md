# Problem statement Explanation

Given an array of points on a 2D plane, find the `k` closest points to the origin `(0, 0)`. The distance between two points `(x, y)` and `(0, 0)` is given by:

$$
\text{distance} = \sqrt{x^2 + y^2}
$$

Return the result in any order.

Example:

```
Input: points = [[3,3],[5,-1],[-2,4]], k = 2
Output: [[3,3],[-2,4]]
```

---

# Intuition

* To decide which points are closest to the origin, we only need to compare their distances.
* Since $\sqrt{}$ is monotonic, comparing **distance squared** is enough — avoids unnecessary floating-point operations.
* Two main strategies:

  1. **Sort** all points by distance and take the first `k`.
  2. **Heap** to keep only the `k` closest points during traversal (more efficient when `k << n`).

---

# Approach

### **Approach 1: Sort-based (`O(n log n)`)**

1. Compute distance² for each point from the origin.
2. Store `(index, distance²)` in a vector.
3. Sort the vector by distance² in ascending order.
4. Take the first `k` points from the sorted vector.

---

### **Approach 2: Max Heap (`O(n log k)`)**

1. Use a **max heap** to store `(distance², index)` for up to `k` closest points.
2. Iterate over all points:

   * Push `(distance², index)` into the heap.
   * If heap size exceeds `k`, remove the farthest point.
3. At the end, the heap contains the `k` closest points.

---

# Complexity

**Approach 1 (Sort):**

* Time complexity: $O(n \log n)$
* Space complexity: $O(n)$

**Approach 2 (Heap):**

* Time complexity: $O(n \log k)$
* Space complexity: $O(k)$

---

# Code

### **Approach 1: Sort-based**

```cpp
class Solution {
public:
    int calEdDist(int x, int y) {
        return x * x + y * y; // squared distance
    }

    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        vector<pair<int,int>> pairVec; // <index, distance²>
        int n = points.size();

        for (int i = 0; i < n; i++) {
            int dist = calEdDist(points[i][0], points[i][1]);
            pairVec.push_back({i, dist});
        }

        sort(pairVec.begin(), pairVec.end(),
             [](const pair<int,int>& a, const pair<int,int>& b) {
                 return a.second < b.second;
             });

        vector<vector<int>> res;
        for (int i = 0; i < k; i++) {
            res.push_back(points[pairVec[i].first]);
        }

        return res;
    }
};
```

---

### **Approach 2: Heap-based**

```cpp
class Solution {
public:
    int calEdDist(int x, int y) {
        return x * x + y * y; // squared distance
    }

    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        priority_queue<pair<int, int>> maxHeap; // <distance², index>

        for (int i = 0; i < points.size(); i++) {
            int dist = calEdDist(points[i][0], points[i][1]);
            maxHeap.push({dist, i});
            if (maxHeap.size() > k) {
                maxHeap.pop();
            }
        }

        vector<vector<int>> res;
        while (!maxHeap.empty()) {
            res.push_back(points[maxHeap.top().second]);
            maxHeap.pop();
        }

        return res;
    }
};
```

---
