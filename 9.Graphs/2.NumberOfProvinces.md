# Number of Provinces 

---

## Question

**Number of Provinces**

We are given an adjacency matrix `adj` of size `V x V` representing cities and direct connections between them.

* `adj[i][j] = 1` → city `i` is directly connected to city `j`.
* A **province** is a group of directly or indirectly connected cities.

We need to return the **number of provinces** (connected components).

**Example:**

* Input:

  ```
  V = 3
  adj = [[1,1,0],
         [1,1,0],
         [0,0,1]]
  ```
* Output: `2`
  Explanation: `{0,1}` form one province, `{2}` is another.

---

## Approach

1. Convert adjacency matrix into adjacency list for easier traversal.
2. Maintain a `visited[]` array to mark visited nodes.
3. For each node `i`:

   * If not visited → start a DFS/BFS from it.
   * Increment province count.
   * DFS will mark all connected nodes as visited.
4. Return count.

---

## Pattern

**Graph Pattern – Connected Components using DFS**

* Hint: *"Whenever we want to find groups/clusters of connected elements in a graph, we use DFS/BFS."*
* Why?

  * Stack/recursion in DFS explores the full component before moving to the next.
  * Ensures each node is visited exactly once.

---

## Time & Space Complexity

* **Time Complexity:** O(V²) (adjacency matrix traversal).
* **Space Complexity:** O(V) for `visited[]`.

---

## Dry Run

**Input:**

```
V = 3
adj = [[1,1,0],
       [1,1,0],
       [0,0,1]]
```

* visited = \[false,false,false], ctr=0
* i=0: not visited → DFS(0)

  * visit 0 → DFS(1) → visit 1 → (0 already visited). Done.
  * Province count = 1.
* i=1: already visited → skip.
* i=2: not visited → DFS(2) → visit 2. Done.

  * Province count = 2.

Output = 2.

---

## Correct C++ Code

```cpp
#include <iostream>
#include <vector>
using namespace std;

class Solution {
public:
    void dfs(vector<vector<int>>& adj, int V, vector<bool>& visited, int node) {
        visited[node] = true;

        for (int j = 0; j < V; j++) {
            if (adj[node][j] == 1 && !visited[j]) {
                dfs(adj, V, visited, j);
            }
        }
    }

    int numProvinces(vector<vector<int>> adj, int V) {
        vector<bool> visited(V, false);
        int ctr = 0;

        for (int i = 0; i < V; i++) {
            if (!visited[i]) {
                ctr++;
                dfs(adj, V, visited, i);
            }
        }
        return ctr;
    }
};

int main() {
    Solution sol;
    vector<vector<int>> adj = {
        {1, 1, 0},
        {1, 1, 0},
        {0, 0, 1}
    };
    cout << sol.numProvinces(adj, 3) << endl; // Output: 2
    return 0;
}
```

---
