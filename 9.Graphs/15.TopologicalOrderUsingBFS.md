Kahn's algorithm is a popular method for finding a **topological sort** of a **Directed Acyclic Graph (DAG)**. It follows a simple, intuitive idea: repeatedly find nodes that have no incoming edges (no prerequisites) and add them to the sorted list.

 The best analogy is a university course schedule. You start by identifying all courses with no prerequisites. Once you complete one of these courses, you've fulfilled a prerequisite for other, more advanced courses, potentially "unlocking" them. You continue this process until all courses are completed.

-----

## Algorithm Steps

The algorithm uses a queue and relies on the concept of **in-degree**â€”the number of incoming edges a vertex has.

1.  **Compute In-Degrees**

      * First, traverse the graph to calculate the in-degree for every vertex. A vertex with an in-degree of 0 has no prerequisites.

2.  **Initialize the Queue**

      * Find all vertices with an in-degree of 0 and add them to a queue. These are the starting points of our sort.

3.  **Process the Queue**

      * While the queue is not empty:
          * Dequeue a vertex, let's call it `u`. Add `u` to your final topologically sorted list.
          * For each neighbor `v` that `u` points to:
              * Decrement the in-degree of `v` by 1 (since prerequisite `u` is now "completed").
              * If the in-degree of `v` becomes 0, it means all its prerequisites have been met. Add `v` to the queue.

4.  **Validate the Result**

      * After the loop finishes, if the count of nodes in your sorted list is less than the total number of nodes in the graph, it means the graph contains a cycle. In this case, a topological sort is not possible.

-----

## C++ Implementation

Here is a C++ implementation of Kahn's algorithm.

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

// Function to perform Topological Sort using Kahn's Algorithm
vector<int> topologicalSort(int V, const vector<vector<int>>& adj) {
    // 1. Compute in-degrees
    vector<int> in_degree(V, 0);
    for (int u = 0; u < V; ++u) {
        for (int v : adj[u]) {
            in_degree[v]++;
        }
    }

    // 2. Initialize the queue with all nodes having an in-degree of 0
    queue<int> q;
    for (int i = 0; i < V; ++i) {
        if (in_degree[i] == 0) {
            q.push(i);
        }
    }

    vector<int> topo_order;
    int count = 0; // To count processed nodes for cycle detection

    // 3. Process the queue
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        topo_order.push_back(u);
        count++;

        // For each neighbor, reduce its in-degree
        for (int v : adj[u]) {
            in_degree[v]--;
            // If in-degree becomes 0, enqueue it
            if (in_degree[v] == 0) {
                q.push(v);
            }
        }
    }

    // 4. Validate the result (check for cycles)
    if (count != V) {
        cout << "Graph has a cycle! Topological sort is not possible." << endl;
        return {}; // Return an empty vector
    }

    return topo_order;
}

int main() {
    int V = 6;
    vector<vector<int>> adj(V);
    adj[2].push_back(3);
    adj[3].push_back(1);
    adj[4].push_back(0);
    adj[4].push_back(1);
    adj[5].push_back(0);
    adj[5].push_back(2);

    vector<int> result = topologicalSort(V, adj);

    if (!result.empty()) {
        cout << "Topological Sort: ";
        for (int node : result) {
            cout << node << " ";
        }
        cout << endl; // Expected output: 4 5 0 2 3 1 (or 5 4 2 0 3 1, etc.)
    }

    return 0;
}
```