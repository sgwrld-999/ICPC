## **Problem Name:** Course Schedule II

**Problem Link:** [LeetCode](https://leetcode.com/problems/course-schedule-ii/)

### **1. Problem Understanding**

This problem is a follow-up to "Course Schedule I".

We are given:

  * An integer `numCourses`, representing courses labeled `0` to `numCourses - 1`.
  * A list of `prerequisites`, where `[a, b]` means course `b` must be taken before course `a`.

**Task:**
Return one possible **order** of courses you can take to finish all of them. If it's impossible to finish all courses (due to a cycle), return an **empty array**.

**Example:**

  * `numCourses = 4`, `prerequisites = [[1,0],[2,0],[3,1],[3,2]]`
  * **Output:** `[0, 2, 1, 3]` (or `[0, 1, 2, 3]`, as multiple valid orders can exist).
  * **Explanation:** You must take course `0` first. After that, you can take `1` and `2`. Finally, after taking both `1` and `2`, you can take `3`.

-----

### **2. When to Think of Topological Sort**

This problem is an even clearer signal for Topological Sort than the first one.

1.  **Explicit Ordering:** The prompt directly asks for "an order of courses". This is the exact definition of a **topological sort**: a linear ordering of nodes such that for every directed edge from node `u` to node `v`, `u` comes before `v` in the ordering.
2.  **Dependency Graph:** As before, the course-prerequisite structure is a classic **directed graph**, where an impossible scenario corresponds to a **cycle**.
3.  **The Goal:** The task is not just to detect a cycle but to produce the valid sequence if one exists. This is the primary purpose of a topological sorting algorithm.

-----

### **3. Why Kahn's Algorithm is a Perfect Fit**

Kahn's algorithm is ideal here because the sequence in which it processes nodes is, by its very nature, a valid topological order.

  * **Constructive Approach:** The algorithm starts with courses that have no prerequisites (in-degree 0). These are the first courses you can possibly take.
  * **Building the Order:** As it "completes" these courses, it reduces the prerequisite count for subsequent courses. When a new course's prerequisite count drops to zero, it's added to the queue, ready to be taken next.
  * **The Result:** By simply recording the nodes in the order they are removed from the queue, we construct a valid step-by-step plan to complete all the courses.

-----

### **4. Algorithm (Kahn's Algorithm)**

**Step-by-step:**

1.  **Build Graph Representation:**
      * Create an **adjacency list** `adj` where `adj[i]` stores courses that depend on course `i`.
      * Create an `in_degree` array to count prerequisites for each course.
2.  **Populate Structures:**
      * For each prerequisite `[a, b]` (meaning `b -> a`), add `a` to `adj[b]` and increment `in_degree[a]`.
3.  **Initialize Queue and Result:**
      * Create a queue and add all courses `i` where `in_degree[i] == 0`.
      * Create an empty `result` vector to store the final course order.
4.  **Process Courses and Build Order:**
      * While the queue is not empty:
          * Dequeue a course `u`.
          * **Add `u` to the `result` vector.**
          * For each neighbor `v` in `adj[u]`:
              * Decrement `in_degree[v]`.
              * If `in_degree[v]` becomes `0`, enqueue `v`.
5.  **Validate and Return:**
      * After the loop, if the size of the `result` vector equals `numCourses`, all courses were successfully ordered. Return the `result`.
      * Otherwise, the graph has a cycle, and it's impossible to finish. Return an **empty vector**.

-----

### **5. Complexity Analysis**

Let **V** be `numCourses` and **E** be the number of prerequisites.

  * **Time Complexity:** $O(V + E)$
      * The overall logic is identical to Course Schedule I. Building the graph, populating in-degrees, and processing each vertex and edge once all contribute to a linear time complexity relative to the size of the graph.
  * **Space Complexity:** $O(V + E)$
      * The adjacency list (`O(V + E)`), in-degree array (`O(V)`), queue (`O(V)`), and result vector (`O(V)`) dominate the space requirements.

-----

### **6. Code**

```cpp
class Solution {
private:
    vector<int> isPossible(vector<vector<int>>& adj, int V) {
        vector<int> in_degree(V, 0);

        // Calculate in-degrees for all vertices
        for (int i = 0; i < V; i++) {
            for (int v : adj[i]) {
                in_degree[v]++;
            }
        }

        queue<int> que;
        // Add all nodes with 0 in-degree to the queue
        for (int i = 0; i < V; i++) {
            if (in_degree[i] == 0) {
                que.push(i);
            }
        }

        vector<int> topological_order;

        // Process nodes from the queue
        while (!que.empty()) {
            int node = que.front();
            que.pop();
            topological_order.push_back(node); // Add node to our final order

            // Process all neighbors of the current node
            for (int neighbor : adj[node]) {
                in_degree[neighbor]--; // Fulfill one prerequisite

                // If all prerequisites are met, add to queue
                if (in_degree[neighbor] == 0) {
                    que.push(neighbor);
                }
            }
        }
        
        // If the number of nodes in our order equals total courses, return the order
        if (topological_order.size() == V) {
            return topological_order;
        }
        
        // Otherwise, a cycle exists, so return an empty vector
        return {};
    }

public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        vector<vector<int>> adj(numCourses);

        // Build adjacency list: v -> u means v is a prereq for u
        for (const auto& p : prerequisites) {
            int u = p[0];
            int v = p[1];
            adj[v].push_back(u);
        }

        // Generate and return the topological order
        return isPossible(adj, numCourses);
    }
};
```

-----

### **7. Dry Run Example**

**Input:** `numCourses = 4`, `prerequisites = [[1,0], [2,0], [3,1], [3,2]]`

1.  **Graph & In-Degree:**

      * Edges: `0->1`, `0->2`, `1->3`, `2->3`
      * `in_degree` = `{0:0, 1:1, 2:1, 3:2}`

2.  **Initialize:**

      * `queue` = `[0]`
      * `topological_order` = `[]`

3.  **Processing Loop:**

      * **Dequeue `0`:**
          * `topological_order` = `[0]`
          * Neighbors of `0` are `1` and `2`.
          * `in_degree[1]` -\> `0`. Enqueue `1`.
          * `in_degree[2]` -\> `0`. Enqueue `2`.
          * `queue` = `[1, 2]`
      * **Dequeue `1`:**
          * `topological_order` = `[0, 1]`
          * Neighbor of `1` is `3`.
          * `in_degree[3]` -\> `1`.
          * `queue` = `[2]`
      * **Dequeue `2`:**
          * `topological_order` = `[0, 1, 2]`
          * Neighbor of `2` is `3`.
          * `in_degree[3]` -\> `0`. Enqueue `3`.
          * `queue` = `[3]`
      * **Dequeue `3`:**
          * `topological_order` = `[0, 1, 2, 3]`
          * No neighbors.
          * `queue` is empty. Loop ends.

4.  **Final Check:**

      * `topological_order.size()` (4) == `numCourses` (4).
      * âœ… **Return `[0, 1, 2, 3]`**.

-----

### **8. Key Takeaways**

1.  **Direct Application:** This problem is a direct implementation of topological sort, where the output is the sorted sequence itself.
2.  **Kahn's Algorithm's Output:** The order in which nodes are dequeued in Kahn's algorithm is a valid topological sort. You just need to store them in a list as you go.
3.  **Cycle Detection is Implicit:** The check (`result.size() == V`) is a clean and effective way to validate that the entire graph was processed, implicitly confirming it's a DAG.