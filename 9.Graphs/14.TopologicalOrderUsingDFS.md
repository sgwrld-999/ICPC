###  What's the Big Idea? (The Intuition)

Imagine you're getting dressed in the morning. You have a set of tasks: put on socks, put on shoes, put on a shirt, put on a jacket. Some tasks depend on others.

* You **must** put on socks **before** you put on shoes.
* You **must** put on a shirt **before** you put on a jacket.

A topological sort is simply an algorithm that finds a **valid order** to complete these tasks. For example, `socks -> shirt -> shoes -> jacket` is a valid order. `shoes -> socks -> ...` is not.

In computer science:
* **Tasks** are the **vertices** (nodes) of the graph.
* **Dependencies** are the **directed edges**. An edge from `socks` to `shoes` means "socks must come before shoes."

The graph must be a **Directed Acyclic Graph (DAG)**. If you had a cycle (e.g., you must wear shoes before socks, and socks before shoes), you'd be stuck forever! That's why topological sort only works for DAGs.

---
## ⚙️ How the Code Works (Step-by-Step)

Your code uses a Depth First Search (DFS) approach. Let's trace it to see how it works and, most importantly, why the stack is used.

### 1. The Deep Dive (DFS)

The `DFS` function's job is to explore a path of dependencies as far as it can go.

Imagine the graph `shirt -> jacket`.
1.  The main loop starts the `DFS` at `shirt`.
2.  Inside `DFS(shirt)`, it sees its neighbor is `jacket`.
3.  Since `jacket` hasn't been visited, it makes a recursive call: `DFS(jacket)`.
4.  Now we're inside `DFS(jacket)`. `jacket` has no neighbors to visit. The deep dive from this path is over.

### 2. Why Use a Stack? The Magic of Reversal

This is the most important part of the algorithm.

> The function pushes a node to the stack **only after** it has finished exploring all of its dependencies.

Let's continue the `shirt -> jacket` example:
1.  Inside `DFS(jacket)`, after checking all of its (zero) neighbors, the line `st.push(jacket);` is executed. The task that has no further dependencies is finished first.
    * **Stack:** `[jacket]`
2.  The `DFS(jacket)` call returns. We are now back inside `DFS(shirt)`.
3.  The loop in `DFS(shirt)` has now finished (it only had one neighbor, `jacket`). So, the line `st.push(shirt);` is executed.
    * **Stack:** `[jacket, shirt]`

### 3. The Final Result

The main loop finishes, and the stack contains all the nodes. Notice the order they went in: the tasks that were *finished last* in the DFS are at the *top* of the stack.

When you empty the stack to build your `ans` vector:
1.  `shirt` is popped. `ans = [shirt]`
2.  `jacket` is popped. `ans = [shirt, jacket]`

The stack, with its **Last-In, First-Out (LIFO)** behavior, perfectly reverses the "finishing order" into the correct "starting order." The task that was the deepest dependency (and thus finished first) comes out last, and the task that started it all comes out first.

---
## ✅ What's the Use in the Real World?

Topological sort is incredibly useful for any problem that involves ordering and dependencies.
* **Task Scheduling**: In project management or operating systems, it can determine the order in which to execute jobs that depend on each other.
* **Course Prerequisites**: Universities use it to figure out a valid sequence of courses for a student, given that some courses are prerequisites for others.
* **Software Build Systems**: When compiling code, some files must be compiled before others. A build system like `make` uses topological sort to find the correct compilation order.
* **Package Managers**: When you install a software package (e.g., using `pip` or `npm`), it often has dependencies. A topological sort is used to install the packages in the right order.

---

```cpp
#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>

using namespace std;

// Recursive helper function for DFS-based topological sort
void dfs(int u, const vector<vector<int>>& adj, vector<bool>& visited, stack<int>& st) {
    visited[u] = true;

    for (int v : adj[u]) {
        if (!visited[v]) {
            dfs(v, adj, visited, st);
        }
    }
    // After visiting all descendants, push the current node to the stack
    st.push(u);
}

// Function to perform Topological Sort using DFS
vector<int> topologicalSortDFS(int V, const vector<vector<int>>& adj) {
    stack<int> st;
    vector<bool> visited(V, false);

    for (int i = 0; i < V; ++i) {
        if (!visited[i]) {
            dfs(i, adj, visited, st);
        }
    }

    vector<int> topo_order;
    while (!st.empty()) {
        topo_order.push_back(st.top());
        st.pop();
    }

    return topo_order;
}
```