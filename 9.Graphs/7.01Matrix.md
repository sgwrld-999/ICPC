# 01 Matrix Problem

---

## Question

**01 Matrix Problem**

Given a binary matrix (only 0s and 1s), find the distance of each cell from the nearest `0`. The distance between two adjacent cells is `1`.

**Example 1:**
Input:

```
matrix = [[0,0,0],
          [0,1,0],
          [1,1,1]]
```

Output:

```
[[0,0,0],
 [0,1,0],
 [1,2,1]]
```

**Example 2:**
Input:

```
matrix = [[0,1,1],
          [1,1,1],
          [1,1,0]]
```

Output:

```
[[0,1,2],
 [1,2,1],
 [2,1,0]]
```

---

## Approach

1. This problem requires finding the **shortest distance to the nearest 0** for each cell.
2. Instead of running BFS from every cell with `1` (inefficient), we:

   * Start BFS from all `0` cells simultaneously (multi-source BFS).
   * Push all zero-cells into a queue with distance = 0.
   * Mark all other cells as `UNVISITED (-1)`.
3. Perform BFS:

   * Pop a cell from queue.
   * For all 4 directions (up, down, left, right):

     * If the neighbor is unvisited, set its distance as currentDistance + 1 and push it to queue.
4. Continue until queue is empty.
5. Return the distance matrix.

---

## Pattern

**Queue/BFS Pattern – Multi-source BFS**

* Hint: *"Whenever we want the shortest distance from multiple sources in a grid, we use BFS with a queue initialized with all sources. That is finding something from every node to a specific target"*
* Why Queue?

  * BFS explores level by level, ensuring the first time we reach a cell is the **shortest distance**.
  * In this problem, the **sources are all the cells with value 0**, so we push them all initially.
  * This avoids redundant BFS calls and ensures `O(n*m)` time complexity.
  * 

---

## Time & Space Complexity

* **Time Complexity:** `O(n * m)`

  * Each cell is processed at most once.
* **Space Complexity:** `O(n * m)`

  * Distance matrix + BFS queue in the worst case.

---

## Dry Run

**Input:**

```
matrix = [[0,0,0],
          [0,1,0],
          [1,1,1]]
```

Initialization:

* All 0’s → distance = 0 → push into queue.
* All 1’s → distance = -1.

Queue initially: `(0,0), (0,1), (0,2), (1,0), (1,2)`

Processing:

* Pop (0,0): check neighbors → (1,0) already 0, skip.
* Pop (0,1): neighbors → (1,1) = -1 → set = 1, push.
* Pop (0,2): neighbors → (1,2) already 0.
* Pop (1,0): neighbor (2,0) = -1 → set = 1, push.
* Pop (1,2): neighbor (2,2) = -1 → set = 1, push.
* Pop (1,1): neighbor (2,1) = -1 → set = 2, push.

Final distance matrix:

```
[[0,0,0],
 [0,1,0],
 [1,2,1]]
```

---

## Correct C++ Code

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

class Solution {
private:
    static constexpr int UNVISITED = -1;
    static constexpr int DIRECTIONS = 4;
    
    const vector<int> ROW_OFFSETS = {-1, 1, 0, 0};
    const vector<int> COL_OFFSETS = {0, 0, -1, 1};
    
    bool isValidCell(int row, int col, int maxRows, int maxCols) const {
        return row >= 0 && row < maxRows && col >= 0 && col < maxCols;
    }
    
    void initializeZeroCells(const vector<vector<int>>& matrix, 
                           vector<vector<int>>& distances, 
                           queue<pair<int, int>>& bfsQueue) const {
        int rows = matrix.size();
        int cols = matrix[0].size();
        
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                if (matrix[i][j] == 0) {
                    distances[i][j] = 0;
                    bfsQueue.push({i, j});
                }
            }
        }
    }
    
    void performBFS(vector<vector<int>>& distances, queue<pair<int, int>>& bfsQueue) const {
        int rows = distances.size();
        int cols = distances[0].size();
        
        while (!bfsQueue.empty()) {
            auto [currentRow, currentCol] = bfsQueue.front();
            bfsQueue.pop();
            
            int currentDistance = distances[currentRow][currentCol];
            
            for (int dir = 0; dir < DIRECTIONS; ++dir) {
                int newRow = currentRow + ROW_OFFSETS[dir];
                int newCol = currentCol + COL_OFFSETS[dir];
                
                if (isValidCell(newRow, newCol, rows, cols) && 
                    distances[newRow][newCol] == UNVISITED) {
                    
                    distances[newRow][newCol] = currentDistance + 1;
                    bfsQueue.push({newRow, newCol});
                }
            }
        }
    }

public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& matrix) {
        if (matrix.empty() || matrix[0].empty()) {
            return {};
        }
        
        int rows = matrix.size();
        int cols = matrix[0].size();
        
        vector<vector<int>> distances(rows, vector<int>(cols, UNVISITED));
        queue<pair<int, int>> bfsQueue;
        
        initializeZeroCells(matrix, distances, bfsQueue);
        performBFS(distances, bfsQueue);
        
        return distances;
    }
};

int main() {
    Solution sol;
    vector<vector<int>> matrix = {{0,0,0},{0,1,0},{1,1,1}};
    vector<vector<int>> result = sol.updateMatrix(matrix);

    for (auto &row : result) {
        for (int x : row) cout << x << " ";
        cout << endl;
    }
    // Output:
    // 0 0 0
    // 0 1 0
    // 1 2 1
    return 0;
}
```

---

