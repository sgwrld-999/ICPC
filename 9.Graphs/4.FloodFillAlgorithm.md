# Flood fill

-----

## Question

**Flood Fill**
You are given an `m x n` integer grid `image` representing an image, a starting pixel `(sr, sc)`, and an integer `color`. "Flood fill" the image by changing the color of the starting pixel, plus any pixels connected **4-directionally** (up, down, left, right) to the starting pixel with the same original color, to the new `color`.

**Example 1:**

  * Input: `image = [[1,1,1],[1,1,0],[1,0,1]]`, `sr = 1`, `sc = 1`, `color = 2`
  * Output: `[[2,2,2],[2,2,0],[2,0,1]]`
  * **Explanation:** The pixel at (1,1) has color 1. All adjacent pixels with color 1 are changed to 2. The pixel at (2,1) is not changed because it's not connected to the starting pixel by a path of color 1.

-----

## Approach

This is a classic graph traversal problem on a 2D grid. The connected pixels of the same color form a "con+nected component." We can use either BFS or DFS to find and update this component.

### 1\. **Breadth-First Search (BFS) - (Optimal)**

  * Use a **queue** to store pixels that need to be processed. This explores the area level by level.
  * Store the `original_color` of the starting pixel `image[sr][sc]`. If the `original_color` is already the new `color`, no work is needed.
  * Add the starting pixel `(sr, sc)` to the queue and change its color **immediately** to prevent reprocessing it.
  * While the queue is not empty:
      * Dequeue a pixel `(r, c)`.
      * For each of its 4-directional neighbors `(nr, nc)`:
          * If the neighbor is within the grid bounds and still has the `original_color`, change its color and enqueue it.

### 2\. **Depth-First Search (DFS) - (Optimal)**

  * Uses **recursion** to explore one path completely before backtracking. The logic is similar but relies on the call stack instead of a queue.

-----

## Pattern

**Graph Traversal on a 2D Grid/Matrix**

  * **Hint:** "Whenever a problem involves finding a connected area, coloring regions, exploring a maze, or finding paths in a grid, it's a signal to treat the grid as an implicit graph and use traversal algorithms like BFS or DFS."
  * **Why?**
      * A grid is a graph where each cell is a **node**, and adjacent cells are connected by **edges**.
      * **BFS** explores layer by layer, which is useful for finding the shortest path. For flood fill, it explores all pixels at distance 1, then all at distance 2, and so on.
      * **DFS** is also effective and can be more concise to implement recursively. For this problem, both have the same efficiency.

-----

## Time & Space Complexity

Let `m` be the number of rows and `n` be the number of columns.

  * **BFS/DFS (Optimal):**
      * Time Complexity: $O(m \\times n)$
          * In the worst case, we visit every cell in the grid exactly once.
      * Space Complexity: $O(m \\times n)$
          * In the worst case, the queue (for BFS) or the recursion stack (for DFS) could hold all `m * n` cells if the entire grid is one component.

-----

## Dry Run (BFS Approach)

**Input:** `image = [[1,1,1],[1,1,0],[1,0,1]]`, `sr=1`, `sc=1`, `color=2`

  * `originalColor` = `image[1][1]` = **1**.
  * `image[1][1]` is changed to 2. **Queue:** `[(1,1)]`.
    `image` is now `[[1,1,1],[1,2,0],[1,0,1]]`.

<!-- end list -->

1.  **Dequeue (1,1).** Check its neighbors: (0,1), (2,1), (1,0), (1,2).

      * Neighbor (0,1) is 1. Change to 2. **Enqueue (0,1).**
      * Neighbor (2,1) is 0. Ignore.
      * Neighbor (1,0) is 1. Change to 2. **Enqueue (1,0).**
      * Neighbor (1,2) is 0. Ignore.
      * **Queue:** `[(0,1), (1,0)]`. `image` is `[[1,2,1],[2,2,0],[1,0,1]]`.

2.  **Dequeue (0,1).** Check its neighbors: (-1,1), (1,1), (0,0), (0,2).

      * Neighbor (-1,1) is out of bounds.
      * Neighbor (1,1) is 2 (not `originalColor`). Ignore.
      * Neighbor (0,0) is 1. Change to 2. **Enqueue (0,0).**
      * Neighbor (0,2) is 1. Change to 2. **Enqueue (0,2).**
      * **Queue:** `[(1,0), (0,0), (0,2)]`. `image` is `[[2,2,2],[2,2,0],[1,0,1]]`.

3.  **Dequeue (1,0).** Check its neighbors: (0,0), (2,0), (1,-1), (1,1).

      * Neighbor (0,0) is 2. Ignore.
      * Neighbor (2,0) is 1. Change to 2. **Enqueue (2,0).**
      * Neighbor (1,-1) is out of bounds.
      * Neighbor (1,1) is 2. Ignore.
      * **Queue:** `[(0,0), (0,2), (2,0)]`. `image` is `[[2,2,2],[2,2,0],[2,0,1]]`.

4.  **Dequeue (0,0), (0,2), (2,0).** All their valid neighbors have already been colored to 2. No new pixels are enqueued.

5.  The queue becomes empty. The process stops.

<!-- end list -->

  * Final `image`: `[[2,2,2],[2,2,0],[2,0,1]]`.

-----

## Correct C++ Code (BFS Optimal)

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

class Solution {
public:
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {
        int m = image.size();
        int n = image[0].size();
        int originalColor = image[sr][sc];

        // If the starting pixel is already the target color, no work is needed.
        if (originalColor == color) {
            return image;
        }

        queue<pair<int, int>> q;
        q.push({sr, sc});
        image[sr][sc] = color; // Color the starting pixel

        // Delta arrays for 4 directions: Up, Down, Left, Right
        int dRow[] = {-1, 1, 0, 0};
        int dCol[] = {0, 0, -1, 1};

        while (!q.empty()) {
            int r = q.front().first;
            int c = q.front().second;
            q.pop();

            // Check all 4 neighbors
            for (int i = 0; i < 4; i++) {
                int newRow = r + dRow[i];
                int newCol = c + dCol[i];

                // Check if the neighbor is valid
                if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && 
                    image[newRow][newCol] == originalColor) {
                    
                    image[newRow][newCol] = color;
                    q.push({newRow, newCol});
                }
            }
        }
        return image;
    }
};

void printImage(const vector<vector<int>>& image) {
    for (const auto& row : image) {
        for (int pixel : row) {
            cout << pixel << " ";
        }
        cout << endl;
    }
}

int main() {
    Solution sol;
    vector<vector<int>> image = {{1, 1, 1}, {1, 1, 0}, {1, 0, 1}};
    int sr = 1, sc = 1, newColor = 2;
    
    vector<vector<int>> result = sol.floodFill(image, sr, sc, newColor);
    printImage(result);
    
    return 0;
}
```
