## **Cycle Detection in a Directed Graph using DFS**

Detecting cycles is a fundamental problem in graph theory. For directed graphs, the approach is slightly different than for undirected graphs because the direction of edges matters. The provided code uses a classic and efficient Depth First Search (DFS) based algorithm.

-----

## **1. Problem Understanding**

**Given:**

  * A **directed graph** represented by `V` vertices and a list of edges.

**Task:**

  * Determine if the graph contains at least one cycle. A cycle is a path that starts and ends at the same vertex, following the direction of the edges.

**The Key Idea:**
A cycle exists in a directed graph if, during a DFS traversal, we encounter a "back edge." A back edge is an edge from a node to one of its ancestors in the current recursion path. To detect this, we need to know not just *if* a node has been visited, but if it's currently part of the path we are exploring.

-----

## **2. Core Technique: Depth First Search (DFS)**

DFS is the perfect tool for this job because it explores paths to their absolute depth before backtracking. This "deep dive" approach allows us to easily track the current path of nodes we're on.

To detect a cycle, we maintain two separate "visited" arrays:

1.  `visited[]`: This is a standard visited array. It marks a node as visited for the *entire lifetime* of the algorithm once we've processed it. This prevents us from re-visiting parts of the graph we already know are cycle-free.
2.  `pathVisited[]`: This is the crucial one. It only marks a node as visited *while it is in the current recursive call stack*. When we backtrack from a node, we un-mark it in this array.

A cycle is found when we are at a node `u` and find an edge to a neighbor `v` that is **already in the current recursion path** (i.e., `pathVisited[v]` is true).

-----

## **3. Algorithm Breakdown**

1.  **Graph Representation**: First, convert the given list of edges into an adjacency list for efficient neighbor lookup.
2.  **Initialization**: Create two boolean arrays, `visited` and `pathVisited`, of size `V`, and initialize them to `false`.
3.  **Main Loop**: Iterate through all vertices of the graph from `i = 0` to `V-1`. This loop ensures that we check all components of the graph, even if it's disconnected.
      * If a vertex `i` has not been visited (`!visited[i]`), start a DFS traversal from it.
4.  **DFS Function (`dfsCheck`)**:
      * When the DFS visits a `node`, mark it as true in **both** `visited` and `pathVisited`.
      * Iterate through all `neighbors` of the `node`.
      * For each `neighbor`:
          * **Case 1: Not Visited**. If `!visited[neighbor]`, it's a fresh node. Make a recursive call: `dfsCheck(neighbor, ...)`. If that recursive call ever finds a cycle, it will return `true`, which we must immediately propagate up.
          * **Case 2: Visited and on Current Path**. If the `neighbor` has been visited before (`visited[neighbor]` is true) AND it's also on our current path (`pathVisited[neighbor]` is true), we have found a back edge. This is a cycle. Return `true`.
      * **Backtrack**: After the loop for all neighbors is finished, we are about to return from the recursive call for `node`. At this point, we **un-mark it** from the current path: `pathVisited[node] = false`.
5.  **Result**: If any call to `dfsCheck` in the main loop returns `true`, the graph has a cycle. If the loop finishes without any `dfsCheck` call returning `true`, the graph is acyclic.

-----

## **4. Patterns**

  * **DFS on Graphs**: This is a fundamental graph traversal pattern used for exploring nodes and edges.
  * **State Management with Multiple Visited Arrays**: Using two separate boolean arrays (`visited` and `pathVisited`) is the standard pattern for detecting cycles in **directed graphs**. It cleanly separates the state of "visited at some point" from "is an ancestor in the current path." This is the key difference from cycle detection in undirected graphs.

-----

## **5. Time and Space Complexity**

  * **Time Complexity**: **O(V + E)**, where V is the number of vertices and E is the number of edges. This is because, in the worst case, the DFS algorithm visits every vertex and every edge exactly once.
  * **Space Complexity**: **O(V)**. This space is used for:
      * The adjacency list (`O(V+E)`, but often dominated by V).
      * The `visited` and `pathVisited` arrays (`O(V)`).
      * The recursion call stack, which can go up to `V` levels deep in the worst case (`O(V)`).

-----

## **6. Code with Comments**

Here is your provided code with detailed comments explaining each part.

```cpp
class Solution {
private:
    // Recursive DFS function to check for cycles
    bool dfsCheck(int node, vector<vector<int>>& adj,
                  vector<bool>& visited,
                  vector<bool>& pathVisited) {
        // Mark the current node as visited for the entire algorithm AND for the current path
        visited[node] = true;
        pathVisited[node] = true;

        // Explore all neighbors of the current node
        for (auto neighbor : adj[node]) {
            // Case 1: If the neighbor has not been visited at all
            if (!visited[neighbor]) {
                // Recurse on the neighbor. If it finds a cycle, propagate true up.
                if (dfsCheck(neighbor, adj, visited, pathVisited)) {
                    return true;
                }
            }
            // Case 2: If the neighbor HAS been visited AND is on the CURRENT path
            else if (pathVisited[neighbor]) {
                // A cycle is detected! We've found a back edge.
                return true;
            }
        }

        // Backtrack: The exploration from 'node' is complete. Remove it from the current path.
        pathVisited[node] = false;
        return false;
    }

public:
    // Main function to detect a cycle in a directed graph
    bool isCyclic(int V, vector<vector<int>>& edges) {
        // Build an adjacency list representation of the graph
        vector<vector<int>> adj(V);
        for (auto& edge : edges) {
            int u = edge[0];
            int v = edge[1];
            adj[u].push_back(v);
        }

        // visited[]: keeps track of all visited nodes in the graph
        vector<bool> visited(V, false);
        // pathVisited[]: keeps track of visited nodes in the CURRENT recursion path
        vector<bool> pathVisited(V, false);

        // This loop handles disconnected components in the graph
        for (int i = 0; i < V; i++) {
            if (!visited[i]) {
                // Start a DFS from the unvisited node
                if (dfsCheck(i, adj, visited, pathVisited)) {
                    return true; // Cycle found
                }
            }
        }
        return false; // No cycle found in any component
    }
};
```
```cpp

class Solution {
private:
    bool dfsCheck(int node, vector<vector<int>>& adj, vector<int>& visited) {
        visited[node] = 1; // mark as in recursion stack
        
        for (auto neighbor : adj[node]) {
            if (visited[neighbor] == 0) {
                if (dfsCheck(neighbor, adj, visited)) {
                    return true; // cycle found
                }
            }
            else if (visited[neighbor] == 1) {
                return true; // cycle detected (back edge)
            }
        }
        
        visited[node] = 2; // mark as fully processed
        return false;
    }
    
public:
    bool isCyclic(int V, vector<vector<int>>& edges) {
        // Build adjacency list from edge list
        vector<vector<int>> adj(V);
        for (auto& edge : edges) {
            int u = edge[0];
            int v = edge[1];
            adj[u].push_back(v);
        }
        
        vector<int> visited(V, 0); // 0=unvisited, 1=recStack, 2=done
        
        for (int i = 0; i < V; i++) {
            if (visited[i] == 0) {
                if (dfsCheck(i, adj, visited)) {
                    return true;
                }
            }
        }
        return false;
    }
};


```
-----

## **7. Key Takeaways**

  * Cycle detection in **directed graphs** requires tracking the nodes in the **current recursion path**, which is different from the logic for undirected graphs.
  * The use of two separate boolean arrays (`visited` and `pathVisited`) is a clean and effective way to manage the necessary state.
  * The backtracking step (`pathVisited[node] = false`) is crucial. It correctly signals that a node is no longer an ancestor as the recursion unwinds, allowing it to be part of other, separate paths without falsely triggering a cycle detection.