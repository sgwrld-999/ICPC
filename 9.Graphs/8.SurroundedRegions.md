

# Problem: Surrounded Regions (LeetCode 130)

## Goal

* Given a 2D grid `board` containing `'X'` and `'O'`:

  * Capture all regions surrounded by `'X'`.
  * A region of `'O'` is *captured* if it is fully surrounded by `'X'` (i.e., no `'O'` in the region touches the border).
  * Captured `'O'`s are flipped to `'X'`.

---

## Key Idea

* `'O'`s **connected to the border** cannot be captured.
* Use **BFS (or DFS)** to mark such border-connected `'O'`s as safe.
* Flip all other `'O'`s to `'X'`.

---

## Steps / Algorithm

1. **Initialization**

   * Get number of rows (`rows`) and columns (`cols`).
   * Create a `visited` matrix to track explored cells.

2. **Traverse Borders**

   * Top row and bottom row.
   * Left column and right column.
   * For every `'O'` on the border that is not visited → run BFS to mark it and all its connected `'O'`s as safe.

3. **BFS Function**

   * Start from a border `'O'`.
   * Explore in 4 directions (`up, down, left, right`).
   * Mark all connected `'O'`s as visited.

4. **Flip Step**

   * Traverse the entire grid.
   * If a cell is `'O'` but **not visited**, it means it is surrounded → flip it to `'X'`.

---

## Dry Run Example

Input:

```
X X X X
X O O X
X X O X
X O X X
```

* Step 1: Start from borders.

  * Border `'O'` at `(3,1)` is marked safe.
* Step 2: BFS marks `(3,1)` and its connected `'O'`s (none here).
* Step 3: Remaining `'O'`s `(1,1), (1,2), (2,2)` are not connected to border → flip them.
* Final Output:

```
X X X X
X X X X
X X X X
X O X X
```

---

## Complexity

* **Time Complexity**: `O(rows * cols)`

  * Every cell is visited at most once.
* **Space Complexity**: `O(rows * cols)`

  * For the `visited` matrix + BFS queue.

---

## Interview Pointers

* This problem is about **graph traversal on a grid**.
* Key trick: **Only border-connected `'O'`s survive**.
* Common mistake: Flipping `'O'`s during traversal → should instead mark safe ones and flip later.

---


```cpp
class Solution {
public:
    // This BFS will now correctly explore all 'O's connected to a starting 'O'
    void bfs(int start_row, int start_col, int rows, int cols, vector<vector<char>>& board, vector<vector<bool>>& visited) {
        queue<pair<int, int>> q;
        
        q.push({start_row, start_col});
        visited[start_row][start_col] = true;

        int dir_row[] = {-1, 1, 0, 0};
        int dir_col[] = {0, 0, -1, 1};

        while (!q.empty()) {
            auto [curr_row, curr_col] = q.front();
            q.pop();

            for (int i = 0; i < 4; i++) {
                int new_row = curr_row + dir_row[i];
                int new_col = curr_col + dir_col[i];

                // Check boundaries, if it's an 'O', and if it hasn't been visited
                if (new_row >= 0 && new_row < rows && new_col >= 0 && new_col < cols &&
                    board[new_row][new_col] == 'O' && !visited[new_row][new_col]) {
                    
                    visited[new_row][new_col] = true;
                    q.push({new_row, new_col});
                }
            }
        }
    }

    void solve(vector<vector<char>>& board) {
        int rows = board.size();
        if (rows == 0) return;
        int cols = board[0].size();

        vector<vector<bool>> visited(rows, vector<bool>(cols, false));

        // 1. Mark 'O's connected to the top and bottom borders
        for (int j = 0; j < cols; ++j) {
            if (board[0][j] == 'O' && !visited[0][j]) {
                bfs(0, j, rows, cols, board, visited);
            }
            if (board[rows - 1][j] == 'O' && !visited[rows - 1][j]) {
                bfs(rows - 1, j, rows, cols, board, visited);
            }
        }

        // 2. Mark 'O's connected to the left and right borders
        for (int i = 0; i < rows; ++i) {
            if (board[i][0] == 'O' && !visited[i][0]) {
                bfs(i, 0, rows, cols, board, visited);
            }
            if (board[i][cols - 1] == 'O' && !visited[i][cols - 1]) {
                bfs(i, cols - 1, rows, cols, board, visited);
            }
        }

        // 3. Flip all 'O's that were not visited (i.e., not connected to any border)
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                if (board[i][j] == 'O' && !visited[i][j]) {
                    board[i][j] = 'X';
                }
            }
        }
    }
};
```
