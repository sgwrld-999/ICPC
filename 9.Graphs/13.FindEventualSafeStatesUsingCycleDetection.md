## **Finding Eventual Safe States**

This is an interesting graph problem that combines Depth First Search (DFS) with cycle detection. The core idea is to reframe the problem: instead of proving a node is "safe," we prove it's *not* unsafe.

-----

## **1. Problem Understanding**

**Given:**

  * A directed graph, represented by an adjacency list `graph`.

**Task:**

  * Find and return all the "safe" nodes in the graph.

**Definition of a Safe Node:**

  * A node is considered **safe** if **every possible path** starting from that node eventually leads to a **terminal node**.
  * A **terminal node** is a node with no outgoing edges.
  * Conversely, a node is **unsafe** if there is any path from it that leads to a **cycle**. Any node within a cycle is unsafe, and any node that can reach a cycle is also unsafe.

-----

## **2. Core Technique: DFS with 3-State Visitation**

The problem boils down to detecting which nodes can reach a cycle. A standard DFS for cycle detection in a directed graph is the perfect tool.

The key is to use a `visited` array that can track three distinct states for each node:

  * **State 0 (Unvisited):** We have not encountered this node yet.
  * **State 1 (Visiting):** We have visited this node, and it is currently in our active recursion path (call stack).
  * **State 2 (Visited):** We have fully explored all paths from this node, and it has been confirmed to not lead to any cycles.

A cycle is detected when our DFS encounters a node that is currently in the **"Visiting" (State 1)** state. This means we've found a back edge to an ancestor in our current path.

-----

## **3. Algorithm Breakdown**

1.  **Initialization**:
      * Create a `visited` array of size `V` initialized to `0` (unvisited).
      * Create a `checkSafeNode` array of size `V` initialized to `0`. This will be used to mark nodes as safe (`1`) once they are confirmed.
2.  **Main Loop**: Iterate through every node `i` from `0` to `V-1`. If a node is still unvisited (`visited[i] == 0`), start a DFS traversal from it. This ensures all components of a disconnected graph are checked.
3.  **DFS Function (`dfsCheck`)**: This function's goal is to determine if the starting `node` can reach a cycle. It returns `true` if a cycle is found, and `false` otherwise.
      * Set `visited[node] = 1` (mark as "visiting").
      * For each `neighbor` of the `node`:
          * **Case 1 (Unvisited neighbor):** If `visited[neighbor] == 0`, recurse on it. If the recursive call `dfsCheck(neighbor)` returns `true`, it means the neighbor leads to a cycle. Therefore, our current `node` also leads to a cycle, so we immediately return `true`.
          * **Case 2 (Neighbor is "Visiting"):** If `visited[neighbor] == 1`, the neighbor is an ancestor in our current recursion path. We have found a back edge, which means we've found a cycle. Return `true`.
          * **Case 3 (Neighbor is "Visited"):** If `visited[neighbor] == 2`, we have already fully explored this neighbor and confirmed it's safe. We can safely ignore it and continue.
      * **Mark as Safe**: If the `for` loop completes without returning `true`, it means no path from this `node` leads to a cycle. Therefore, the `node` is safe.
          * We mark `checkSafeNode[node] = 1`.
          * We update its state to fully explored: `visited[node] = 2`.
          * We return `false` (no cycle found from this node).
4.  **Final Result**: After the main loop has finished, iterate through the `checkSafeNode` array and collect the indices of all nodes marked as `1`.

-----

## **4. Patterns**

  * **3-State DFS for Graph Analysis**: Using a tri-state visited array (`unvisited`, `visiting`, `visited`) is a powerful and common pattern for analyzing directed graphs. It elegantly combines the roles of a "globally visited" array and a "current path" array, which is essential for robust cycle detection.
  * **Safe/Unsafe State Propagation**: This problem demonstrates how a property (like being "unsafe") propagates backward through the graph. If a node `v` is found to be unsafe (part of a cycle), any node `u` that can reach `v` is also deemed unsafe by the recursive DFS calls.

-----

## **5. Time and Space Complexity**

  * **Time Complexity**: **O(V + E)**, where V is the number of vertices and E is the number of edges. This is a standard DFS traversal where each vertex and edge is processed a constant number of times.
  * **Space Complexity**: **O(V)**. This space is required for the `visited` and `checkSafeNode` arrays, as well as for the recursion call stack, which can go up to `V` levels deep.

-----

## **6. Code with Comments**

Here is your provided code with detailed comments explaining the logic.

```cpp
class Solution {
private:
    // Recursive DFS function. Returns true if a cycle is detected from 'node'.
    bool dfsCheck(int node, vector<vector<int>>& graph,
                  vector<int>& visited, vector<int>& checkSafeNode) {
        
        // Mark the current node as 'visiting' (part of the current recursion path).
        visited[node] = 1;

        // Explore all neighbors.
        for (auto neighbor : graph[node]) {
            // Case 1: Neighbor is unvisited. Recurse on it.
            if (visited[neighbor] == 0) {
                // If the recursive call finds a cycle, then this node is also unsafe.
                if (dfsCheck(neighbor, graph, visited, checkSafeNode)) {
                    return true;
                }
            }
            // Case 2: Neighbor is already in the 'visiting' state.
            // This means we have found a back edge to an ancestor -> a cycle.
            else if (visited[neighbor] == 1) {
                return true;
            }
            // Case 3 (implicit): visited[neighbor] == 2. The neighbor is already
            // processed and known to be safe, so we can ignore it.
        }

        // If the loop completes, no cycle was found from this node.
        // Therefore, this node is a safe node.
        checkSafeNode[node] = 1;
        // Mark the node as fully 'visited' and processed.
        visited[node] = 2; 
        return false; // No cycle found.
    }

public:
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        int V = graph.size();
        // 0=unvisited, 1=visiting, 2=visited
        vector<int> visited(V, 0);
        // Marks nodes that are confirmed to be safe.
        vector<int> checkSafeNode(V, 0);

        // Iterate through all nodes to handle disconnected components.
        for (int i = 0; i < V; i++) {
            if (visited[i] == 0) {
                dfsCheck(i, graph, visited, checkSafeNode);
            }
        }

        // Collect all nodes that were marked as safe.
        vector<int> safeNodes;
        for (int i = 0; i < V; i++) {
            if (checkSafeNode[i] == 1) {
                safeNodes.push_back(i);
            }
        }
        return safeNodes;
    }
};
```

-----

## **7. Key Takeaways**

  * Many graph problems can be solved by rephrasing them. "Is a node safe?" becomes "Can this node **not** reach a cycle?".
  * A **3-state DFS** is a powerful pattern for cycle detection in directed graphs, superior to using two separate boolean arrays as it's more memory-efficient and keeps the state logic concise.
  * A node is only confirmed to be safe after **all** of its descendants in the DFS tree have been fully explored.