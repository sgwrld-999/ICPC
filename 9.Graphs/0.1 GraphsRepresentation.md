# Graph Representation in C++

A graph is a collection of nodes (or vertices) and edges that connect them. To solve problems with graphs, we first need a way to store them in memory. The two most popular methods are the Adjacency Matrix and the Adjacency List. The best choice between them depends on the graph's density and the operations you need to perform.

## 1. Adjacency Matrix

Think of an adjacency matrix as a simple grid or a spreadsheet. It's a 2D array, let's call it adj, where adj[u][v] tells you if there's a direct edge from node u to node v.

**How it works:** For a graph with N nodes (numbered 0 to N-1 or 1 to N), you create an N x N matrix.

- adj[u][v] = 1 if there is an edge from u to v.
- adj[u][v] = 0 if there is no edge.

For an undirected graph, the matrix is symmetric because an edge (u, v) is the same as (v, u). So, adj[u][v] = adj[v][u].

### C++ Implementation

Your initial code had a slight issue with the vector initialization. For n nodes, we need an (n+1) x (n+1) matrix (assuming 1-based indexing). Here's the corrected version:

```cpp
#include <iostream>
#include <vector>

int main() {
    // n = number of nodes, m = number of edges
    int n, m;
    std::cin >> n >> m;

    // Create an adjacency matrix of size (n+1) x (n+1)
    // Initialize all entries to 0 (no edges)
    std::vector<std::vector<int>> adj(n + 1, std::vector<int>(n + 1, 0));

    std::cout << "Enter " << m << " edges (u v):" << std::endl;
    for (int i = 0; i < m; ++i) {
        int u, v;
        std::cin >> u >> v;
        
        // Mark that an edge exists between u and v
        adj[u][v] = 1;
        
        // For an undirected graph, also mark the edge from v to u
        adj[v][u] = 1; 
        // For a directed graph, you would comment out the line above.
    }

    // Now adj[u][v] is 1 if an edge exists, and 0 otherwise.
    // Example: Check if an edge exists between node 2 and 3
    // if (adj[2][3] == 1) { ... }

    return 0;
}
```

### Pros & Cons

- **Pro:** Checking if an edge exists between any two nodes u and v is super fast: an O(1) operation.
- **Con:** It consumes a lot of memory, O(NÂ²), where N is the number of nodes. This is fine for small N (e.g., up to 2000), but for graphs with 100,000 nodes, it's a disaster! It's especially wasteful for sparse graphs (few edges).

## 2. Adjacency List

This is the most common and efficient way to represent graphs in competitive programming. An adjacency list is an array of lists, where each index u in the array stores a list of nodes that are adjacent to u.

**How it works:** You have a main vector (or array), let's call it adj. adj[u] is itself a vector that contains all the neighbors of node u.

### C++ Implementation

Again, let's fix the initialization. We need a vector of vectors. The outer vector has size n+1, and the inner vectors grow as we add edges.

```cpp
#include <iostream>
#include <vector>

int main() {
    // n = number of nodes, m = number of edges
    int n, m;
    std::cin >> n >> m;

    // Create an adjacency list: a vector of vectors
    // adj[i] will store a list of neighbors for node i
    std::vector<std::vector<int>> adj(n + 1);

    std::cout << "Enter " << m << " edges (u v):" << std::endl;
    for (int i = 0; i < m; ++i) {
        int u, v;
        std::cin >> u >> v;

        // Add v to the list of u's neighbors
        adj[u].push_back(v);

        // For an undirected graph, also add u to v's list
        adj[v].push_back(u);
        // For a directed graph, you would comment out the line above.
    }

    // To iterate over all neighbors of a node 'u':
    // for (int neighbor : adj[u]) {
    //     // do something with 'neighbor'
    // }
    
    return 0;
}
```

### Pros & Cons

- **Pro:** Very space-efficient for sparse graphs. The total memory used is O(N+M), where N is the number of nodes and M is the number of edges.
- **Pro:** Iterating through all neighbors of a node u is efficient, as you only loop through the nodes actually connected to u.
- **Con:** Checking for a specific edge (u, v) is slower than with a matrix. You have to scan the list adj[u], which takes O(degree(u)) time in the worst case.

## 3. Storing Graphs with Edge Weights

Real-world graphs often have weights on their edges (e.g., distance between cities, cost of a flight). We can easily adapt both representations for this.

### Weighted Adjacency Matrix

Instead of storing a 1 to represent an edge, you store its weight. If there's no edge, you can store a special value like 0 (if all weights are positive) or infinity (a very large number).

```cpp
#include <iostream>
#include <vector>
#include <limits>

const int INF = std::numeric_limits<int>::max();

int main() {
    int n, m;
    std::cin >> n >> m;

    // Initialize with 0 or INF depending on the problem
    // Using 0 here, assuming weights are non-zero.
    std::vector<std::vector<int>> adj(n + 1, std::vector<int>(n + 1, 0));

    std::cout << "Enter " << m << " edges (u v weight):" << std::endl;
    for (int i = 0; i < m; ++i) {
        int u, v, weight;
        std::cin >> u >> v >> weight;
        adj[u][v] = weight;
        adj[v][u] = weight; // For undirected
    }
    // Now adj[u][v] stores the weight of the edge between u and v
    return 0;
}
```

### Weighted Adjacency List

This is the standard for algorithms like Dijkstra's or Prim's. Instead of a list of integers, you store a list of pairs. Each pair will contain the neighbor and the weight of the edge to it.

std::pair<int, int> is perfect for this, where the first element is the neighbor and the second is the weight.

```cpp
#include <iostream>
#include <vector>
#include <utility> // For std::pair

int main() {
    int n, m;
    std::cin >> n >> m;

    // adj[i] will store a list of pairs {neighbor, weight}
    std::vector<std::vector<std::pair<int, int>>> adj(n + 1);

    std::cout << "Enter " << m << " edges (u v weight):" << std::endl;
    for (int i = 0; i < m; ++i) {
        int u, v, weight;
        std::cin >> u >> v >> weight;

        adj[u].push_back({v, weight});
        adj[v].push_back({u, weight}); // For undirected
    }

    // To iterate over neighbors of 'u' and get their weights:
    // for (auto const& [neighbor, weight] : adj[u]) {
    //     // neighbor is the adjacent node
    //     // weight is the weight of the edge (u, neighbor)
    // }

    return 0;
}
```
