# Bipartite Graphs

A **bipartite graph** is a graph whose vertices can be divided into two separate sets, let's call them $U$ and $V$, such that every edge connects a vertex in set $U$ to one in set $V$.

Simply put, you can color the graph with just **two colors** (e.g., red and blue) so that no two adjacent vertices share the same color. If this is possible, the graph is bipartite.



The key rule is: **no edge connects two vertices of the same color**.

---

### Special Cases of Bipartite Graphs

* **Linear Graphs (Paths)**: Any simple path is bipartite. You can alternate colors as you walk down the path: red, blue, red, blue, and so on. No two adjacent nodes will have the same color.

* **Even-Length Cycles**: Any cycle with an even number of vertices is bipartite. Just like with a linear graph, you can alternate colors around the cycle (red, blue, red, blue...). The last vertex will be blue, and its neighbor (the starting vertex) will be red, so there's no conflict.

The defining characteristic of a non-bipartite graph is the presence of an **odd-length cycle**. A triangle, for instance, is the simplest non-bipartite graph because you cannot two-color it without a conflict.

---

### ## How to Check if a Graph is Bipartite

The most common way to check for bipartiteness is by trying to "two-color" the graph using a traversal algorithm like **Breadth-First Search (BFS)** or **Depth-First Search (DFS)**.

Here's the algorithm using BFS:

1.  **Initialization**: Start with an uncolored graph. Pick any starting vertex and assign it the first color (e.g., red).
2.  **Traversal**: Put the starting vertex into a queue.
3.  **Coloring Neighbors**: While the queue is not empty, dequeue a vertex (`current`). For each of its uncolored neighbors:
    * Assign them the **opposite color** of `current`.
    * Enqueue them.
4.  **Check for Conflicts**: If you ever find a neighbor that is already colored with the **same color** as the `current` vertex, you have a conflict. This means the graph contains an odd-length cycle and is **not bipartite**.
5.  **Repeat**: If the graph has multiple disconnected components, repeat this process for each component until all vertices are colored.

If you can color the entire graph without any conflicts, it is bipartite.

---

### ## Applications

Bipartite graphs are useful in modeling relationships between two different types of objects.

* **Matching Problems**: Such as matching job applicants to jobs, students to projects, or users to recommended items.
* **Scheduling**: For example, scheduling classes into time slots where no two classes taught by the same professor are at the same time.
* **Network Design**: Used in designing communication networks and data structures.


### Code in CPP

```cpp
class Solution {
public:
    bool check(int src_node,vector<vector<int>>& graph,vector<int>& colour, int V){
        queue<int>que;
        que.push(src_node);

        colour[src_node] = 0 ;

        while(!que.empty()){
            int curr_node = que.front();
            que.pop();


            for(auto neig: graph[curr_node]){

                if(colour[neig] == -1){
                    colour[neig] = !colour[curr_node];
                    que.push(neig);
                }


                else if(colour[neig] == colour[curr_node]){
                    return false;
                }
            }
        }

        return true;
    }
    bool isBipartite(vector<vector<int>>& graph) {
        int V = graph.size();
        vector<int>colour(V,-1);

        for(int i = 0 ;i < V ; i++){
            if(colour[i] == -1 && !check(i,graph,colour,V)){
                return false;
            }
        }

        return true;
    }
};
```