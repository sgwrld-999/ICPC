
# Number of Enclaves

---

## Question

**Number of Enclaves (LeetCode 1020)**

You are given an `m x n` binary matrix `grid` where:

* `1` represents land.
* `0` represents water.

A **land cell** is an **enclave** if it cannot walk off the boundary of the grid. Walking is allowed only in **4 directions**: up, down, left, right.

Return the number of enclave land cells.

**Example:**
Input:

```
grid = [[0,0,0,0],
        [1,0,1,0],
        [0,1,1,0],
        [0,0,0,0]]
```

Output: `3`

Explanation:

* The lands connected to boundary are removed (since they can escape).
* The remaining 3 land cells are enclaves.

---

## Approach

1. Enclaves are land cells (`1`) that are **not connected to the boundary**.
2. To solve:

   * Run **DFS/BFS** from all boundary land cells (`grid[i][0]`, `grid[i][m-1]`, `grid[0][j]`, `grid[n-1][j]`).
   * Mark all land cells connected to the boundary as visited.
3. After marking, count all unvisited land cells inside the grid → those are enclaves.

---

## Pattern

**Graph Traversal Pattern – Flood Fill / DFS on Grids**

* Hint: *"Whenever we need to eliminate connected components from boundaries or count enclosed regions, we use DFS/BFS starting from the boundary cells."*
* Why DFS/BFS?

  * DFS/BFS efficiently explores all connected land cells from a given starting cell.
  * By starting at boundaries, we eliminate all land that can reach the outside world.
  * What remains are only the enclosed (trapped) lands.

---

## Time and Space Complexity

* **Time Complexity:** `O(m * n)`

  * Each cell is visited at most once.
* **Space Complexity:** `O(m * n)`

  * For visited matrix + recursion stack (DFS).

---

## Dry Run

**Input:**

```
grid = [[0,0,0,0],
        [1,0,1,0],
        [0,1,1,0],
        [0,0,0,0]]
```

* Step 1: Start DFS from boundary cells.

  * Top row → all 0s → nothing.
  * Bottom row → all 0s → nothing.
  * Left col → `(1,0) = 1` → DFS marks `(1,0)` visited.
  * Right col → `(1,3)=0, (2,3)=0`.

* Step 2: After DFS from boundaries, visited = `{(1,0)}`.

* Step 3: Traverse all cells:

  * `(1,2)=1` not visited → enclave.
  * `(2,1)=1` not visited → enclave.
  * `(2,2)=1` not visited → enclave.

* Step 4: Count = 3.

Output: `3`

---

## Correct C++ Code

```cpp
#include <iostream>
#include <vector>
using namespace std;

class Solution {
public:
    // Directions: up, right, down, left
    int delRow[4] = {-1, 0, 1, 0};
    int delCol[4] = {0, 1, 0, -1};

    void DFS(int i, int j, vector<vector<bool>>& visited, vector<vector<int>>& grid) {
        int rowGrid = grid.size();
        int colGrid = grid[0].size();
        visited[i][j] = true;

        for (int k = 0; k < 4; k++) {
            int newRow = i + delRow[k];
            int newCol = j + delCol[k];

            if (newRow >= 0 && newRow < rowGrid &&
                newCol >= 0 && newCol < colGrid &&
                !visited[newRow][newCol] && grid[newRow][newCol] == 1) {
                DFS(newRow, newCol, visited, grid);
            }
        }
    }

    int numEnclaves(vector<vector<int>>& grid) {
        int rowGrid = grid.size();
        if (rowGrid == 0) return 0;
        int colGrid = grid[0].size();

        vector<vector<bool>> visited(rowGrid, vector<bool>(colGrid, false));

        // DFS from boundary rows
        for (int i = 0; i < rowGrid; i++) {
            if (!visited[i][0] && grid[i][0] == 1) {
                DFS(i, 0, visited, grid);
            }
            if (!visited[i][colGrid - 1] && grid[i][colGrid - 1] == 1) {
                DFS(i, colGrid - 1, visited, grid);
            }
        }

        // DFS from boundary columns
        for (int j = 0; j < colGrid; j++) {
            if (!visited[0][j] && grid[0][j] == 1) {
                DFS(0, j, visited, grid);
            }
            if (!visited[rowGrid - 1][j] && grid[rowGrid - 1][j] == 1) {
                DFS(rowGrid - 1, j, visited, grid);
            }
        }

        // Count unvisited land cells
        int count = 0;
        for (int i = 0; i < rowGrid; i++) {
            for (int j = 0; j < colGrid; j++) {
                if (!visited[i][j] && grid[i][j] == 1) {
                    count++;
                }
            }
        }

        return count;
    }
};

int main() {
    Solution sol;
    vector<vector<int>> grid = {
        {0,0,0,0},
        {1,0,1,0},
        {0,1,1,0},
        {0,0,0,0}
    };
    cout << sol.numEnclaves(grid) << endl;  // Output: 3
    return 0;
}
```

---

