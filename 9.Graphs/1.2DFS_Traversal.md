

## Depth-First Search (DFS)

**Depth-First Search (DFS)** is a graph traversal algorithm that follows a "go deep" strategy. It starts at a node and explores as far as possible along each branch before **backtracking**.

The best analogy is solving a maze. You follow one path until you hit a dead end. Then, you backtrack to the last junction where you had a choice and try a different path. You repeat this until you've explored all paths from that junction, then you backtrack even further.

Instead of a queue, DFS is most elegantly implemented using **recursion**, which uses the program's internal **call stack** to keep track of the path and handle backtracking automatically.

-----

## The DFS Algorithm

The recursive approach is very intuitive:

1.  **Start:** Begin at a `source` node.
2.  **Mark and Process:** Mark the current node `u` as visited and process it (e.g., print it).
3.  **Explore Deeper:** Go through all the neighbors of `u`.
4.  **Recurse:** For each neighbor `v` that has **not** been visited, immediately make a recursive call `dfs(v)`.
5.  **Backtrack:** When the `dfs(v)` call for a neighbor is completely finished (meaning it has explored its entire branch), the function returns. Your code then simply continues to the next unvisited neighbor of `u`. If there are no more, the function for `u` also finishes, effectively backtracking one level up.

-----

## C++ Implementation

The code for DFS is often simpler and more concise than BFS, thanks to the power of recursion.

```cpp
#include <iostream>
#include <vector>

// Adjacency list to store the graph
vector<vector<int>> adj;
// Visited array to keep track of visited nodes
vector<bool> visited;

// The recursive DFS function
void dfs(int u) {
    // 1. Mark the current node as visited and process it
    visited[u] = true;
    cout << u << " ";

    // 2. Go through all its neighbors
    for (int v : adj[u]) {
        // 3. If a neighbor hasn't been visited, recurse on it
        if (!visited[v]) {
            dfs(v);
        }
    }
    // 4. When the loop finishes, the function returns (automatic backtracking)
}

int main() {
    int n, m; // n = nodes, m = edges
    cout << "Enter number of nodes and edges: ";
    cin >> n >> m;

    adj.resize(n + 1);
    visited.resize(n + 1, false);

    cout << "Enter " << m << " edges (u v):" << endl;
    for (int i = 0; i < m; ++i) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    int start_node = 1;
    cout << "DFS traversal starting from node " << start_node << ": ";
    dfs(start_node);
    cout << endl;

    return 0;
}
```

-----

## DFS Dry Run

Let's use the **exact same graph** from the BFS example to see the difference in the traversal path.

  * **Graph:** Edges are (1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (6, 7).
  * **Start Node:** 1.

We'll trace the **Call Stack** (which functions are currently active), the `visited` array, and the output.

| Action                                | Call Stack                 | Visited `[1..7]`    | Output              | Notes                                                         |
| ------------------------------------- | -------------------------- | ------------------- | ------------------- | ------------------------------------------------------------- |
| **Initial Call `dfs(1)`** | `dfs(1)`                   | `[T, F, F, F, F, F, F]` | `"1 "`                | Mark & print 1. Look at neighbors (2, 3).                   |
| Recurse on neighbor 2                 | `dfs(1) -> dfs(2)`         | `[T, T, F, F, F, F, F]` | `"1 2 "`              | Mark & print 2. Look at neighbors (1, 4, 5).                |
| Recurse on neighbor 4                 | `dfs(1) -> dfs(2) -> dfs(4)` | `[T, T, F, T, F, F, F]` | `"1 2 4 "`            | Mark & print 4. Look at neighbor (2).                       |
| 4's neighbor (2) is visited. **Return**. | `dfs(1) -> dfs(2)`         | `[T, T, F, T, F, F, F]` | `"1 2 4 "`            | `dfs(4)` ends. Resume `dfs(2)`. Next neighbor is 5.           |
| Recurse on neighbor 5                 | `dfs(1) -> dfs(2) -> dfs(5)` | `[T, T, F, T, T, F, F]` | `"1 2 4 5 "`          | Mark & print 5. Look at neighbor (2).                       |
| 5's neighbor (2) is visited. **Return**. | `dfs(1) -> dfs(2)`         | `[T, T, F, T, T, F, F]` | `"1 2 4 5 "`          | `dfs(5)` ends. Resume `dfs(2)`. No more neighbors.         |
| 2 has no more unvisited neighbors. **Return**. | `dfs(1)`                   | `[T, T, F, T, T, F, F]` | `"1 2 4 5 "`          | `dfs(2)` ends. Resume `dfs(1)`. Next neighbor is 3.           |
| Recurse on neighbor 3                 | `dfs(1) -> dfs(3)`         | `[T, T, T, T, T, F, F]` | `"1 2 4 5 3 "`        | Mark & print 3. Look at neighbors (1, 6).                   |
| Recurse on neighbor 6                 | `dfs(1) -> dfs(3) -> dfs(6)` | `[T, T, T, T, T, T, F]` | `"1 2 4 5 3 6 "`      | Mark & print 6. Look at neighbors (3, 7).                   |
| Recurse on neighbor 7                 | `dfs(1) -> dfs(3) -> dfs(6) -> dfs(7)` | `[T, T, T, T, T, T, T]` | `"1 2 4 5 3 6 7 "`    | Mark & print 7. Look at neighbor (6).                       |
| 7's neighbor (6) is visited. **Return**. | `dfs(1) -> dfs(3) -> dfs(6)` | `[T, T, T, T, T, T, T]` | `"1 2 4 5 3 6 7 "`    | `dfs(7)` ends. Resume `dfs(6)`. No more neighbors.         |
| 6 has no more unvisited neighbors. **Return**. | `dfs(1) -> dfs(3)`         | `[T, T, T, T, T, T, T]` | `"1 2 4 5 3 6 7 "`    | `dfs(6)` ends. Resume `dfs(3)`. No more neighbors.         |
| 3 has no more unvisited neighbors. **Return**. | `dfs(1)`                   | `[T, T, T, T, T, T, T]` | `"1 2 4 5 3 6 7 "`    | `dfs(3)` ends. Resume `dfs(1)`. No more neighbors.         |
| **End** |                            | `[T, T, T, T, T, T, T]` | `"1 2 4 5 3 6 7 "`    | `dfs(1)` ends. Traversal complete.                       |

### Final Analysis

The final output is **`1 2 4 5 3 6 7`**.

Compare this to the BFS output (`1 2 3 4 5 6 7`). DFS dived all the way down the `1 -> 2` branch (`4`, `5`) before it ever considered the `1 -> 3` branch. This perfectly demonstrates its "depth-first" nature.

DFS is essential for tasks like:

  * Finding if a path exists between two nodes.
  * Detecting cycles in a graph.
  * Topological sorting (a key algorithm for scheduling tasks with dependencies).