# Rotting Oranges

---

## Question

**Rotting Oranges**

You are given an `m x n` grid where:

* `0` → empty cell
* `1` → fresh orange
* `2` → rotten orange

Each minute, any fresh orange that is **adjacent (up, down, left, right)** to a rotten orange becomes rotten.

Return the **minimum number of minutes** until no fresh orange remains. If it’s impossible, return `-1`.

**Example:**

* Input:

  ```
  grid = [[2,1,1],
          [1,1,0],
          [0,1,1]]
  ```

  Output: `4`

* Input:

  ```
  grid = [[0,2]]
  ```

  Output: `0` (no fresh oranges)

---

## Approach

1. Traverse the grid:

   * Push all initially rotten oranges into a **queue** (multi-source BFS).
   * Count the total fresh oranges.
2. If no fresh oranges → return 0.
3. Perform BFS level by level:

   * For each rotten orange in the queue, check its 4 neighbors.
   * If a neighbor is fresh → rot it, decrease fresh count, and push it into the queue.
   * After processing one level (one minute), increase `minutes`.
4. At the end:

   * If `freshOranges == 0` → return `minutes`.
   * Else → return `-1`.

---

## Pattern

**Queue Pattern – Multi-Source BFS**

* Hint: *"Whenever multiple sources spread something level by level in all directions, use a queue with BFS."*
* Why Queue?

  * Rotten oranges spread simultaneously (parallel effect).
  * BFS with a queue naturally processes elements **level by level (minute by minute)**.
  * Each level in BFS corresponds to 1 minute in this problem.

---

## Time & Space Complexity

* **Time Complexity:** `O(m * n)` (each cell visited at most once).
* **Space Complexity:** `O(m * n)` (queue may hold all cells in worst case).

---

## Dry Run

**Input:**

```
grid = [[2,1,1],
        [1,1,0],
        [0,1,1]]
```

**Step 1: Initialization**

* Rotten = `[(0,0)]`
* Fresh = `6`

**Step 2: BFS**

* Minute = 0 → Rotten = (0,0)

  * Neighbors: (0,1), (1,0) → both fresh → rot them → Fresh = 4
  * Queue = \[(0,1), (1,0)]
  * Rotten this round → Minute = 1

* Minute = 1 → Rotten = (0,1), (1,0)

  * Rot (0,2), (1,1) → Fresh = 2
  * Queue = \[(0,2), (1,1)]
  * Minute = 2

* Minute = 2 → Rotten = (0,2), (1,1)

  * Rot (2,1) → Fresh = 1
  * Queue = \[(2,1)]
  * Minute = 3

* Minute = 3 → Rotten = (2,1)

  * Rot (2,2) → Fresh = 0
  * Queue = \[(2,2)]
  * Minute = 4

**Step 3: Fresh = 0 → Return 4**

---

## Correct C++ Code

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int rows = grid.size();
        int cols = grid[0].size();
        
        queue<pair<int, int>> q;
        int freshOranges = 0;

        // Step 1: Find initially rotten oranges and count fresh ones
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j] == 2) {
                    q.push({i, j});
                } else if (grid[i][j] == 1) {
                    freshOranges++;
                }
            }
        }

        // No fresh oranges at start
        if (freshOranges == 0) return 0;

        int minutes = 0;
        vector<int> dir_row = {-1, 1, 0, 0};
        vector<int> dir_col = {0, 0, -1, 1};

        // Step 2: BFS
        while (!q.empty()) {
            int size = q.size();
            bool rottenThisMinute = false;

            for (int i = 0; i < size; i++) {
                int r = q.front().first;
                int c = q.front().second;
                q.pop();

                for (int j = 0; j < 4; j++) {
                    int nr = r + dir_row[j];
                    int nc = c + dir_col[j];

                    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc] == 1) {
                        grid[nr][nc] = 2;   // make rotten
                        q.push({nr, nc});
                        freshOranges--;
                        rottenThisMinute = true;
                    }
                }
            }

            if (rottenThisMinute) minutes++;
        }

        // Step 3: Check if all fresh are rotten
        return (freshOranges == 0) ? minutes : -1;
    }
};

int main() {
    Solution sol;
    vector<vector<int>> grid = {{2,1,1},{1,1,0},{0,1,1}};
    cout << sol.orangesRotting(grid) << endl; // Output: 4
    return 0;
}
```

---
