# 3. Graphs

## Basic Concepts

### What is a graph?
- A logical data structure that consists of a set of nodes (vertices) and a set of edges that relate the nodes to each other.
- A graph G is defined as following:
    - G(V,E)
        - V(G): a finite, non-empty set of vertices
        - E(G): a set of edges (pairs of vertices)

### What is undirected graph?
Each edge has an unordered pair of vertices.

### What is directed graph?
Each edge has an ordered pair of vertices.

### What is the difference between sparse graph and dense graph?
- **Dense Graph:** If all vertices or nodes in a graph are densely connected (i.e., a node connects with all neighbor nodes with all possible edges). Here possibly, total number of edges > total number of nodes.
- **Sparse Graph:** It's the opposite of a dense graph. Here we can observe that nodes or vertices are not fully connected to their neighboring nodes (i.e., they have unconnected/remaining edges). Here possibly, total number of edges <= total number of nodes.

![Screenshot 2023-10-07 at 1.05.47 AM.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/1b23daeb-cb49-4890-9c17-428323da13cb/dcff3d32-3385-4e46-b237-ed3a00420a98/Screenshot_2023-10-07_at_1.05.47_AM.png)

## Graph Properties

### What is connectivity of the graph?
An undirected/directed graph is connected if and only if every distinct pair of vertices are reachable from each other.

### What is connected graph?
For every pair of nodes u & v there is a path between u and v.

### What is strongly connected graph?
- A strongly connected graph is a directed graph in which there is a path from any node to any other node in the graph.
- For every pair of nodes (u, v), there exists a directed path from node u to node v and another directed path from node v to node u.

### What is Complete and incomplete graph?
- **Complete graph:** A graph in which each vertex is connected to every other vertex or a graph that has the maximum number of edges.
    - For undirected graph maximum number of edges: $n(n-1)/2$
    - For directed graph maximum number of edges: $n(n-1)$
    - Example:
        ![Complete Graph](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/75ff605a-e5d1-47f4-8c91-47488756072e/Untitled.png)

- **Incomplete graph:** A graph in which each vertex is not connected to every other vertex
    - Example:
        ![Incomplete Graph](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6a33081a-5bd0-46f1-b97f-7b2fd83b3681/Untitled.png)

### What is adjacent and incident?
- **Adjacent:** When two vertices are connected with an edge in an undirected graph or when an edge connects two vertices, the vertices are said to be adjacent to each other and the edge is incident on both vertices. This term is defined for the vertices.
- **Incident:** When two vertices are connected with an edge in a directed graph. For example: V1 and V2 and v2 is directed from v2 then V1 is adjacent from v2 but v2 is adjacent from v1. This term is defined for the edges.

### What is connected component?
If the graph has a component and it's connected, it's known as a connected component.

### What is self-loop?
A self-loop is an edge that connects a vertex to itself.

## Node Degrees

### What is degree?
- For undirected graph: Number of nodes which are connected to the vertices.
- For directed graph:
    - **In-degree:** The edges which are pointing towards the vertices.
    - **Out-degree:** The edges which are pointing outwards from the vertices.
    - Example:
        ![Degree Example](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/33d8abc9-19ec-468a-8b40-07c8bb816e4c/Untitled.png)
        
        | Node | In-degree | Out-degree |
        | ---- | --------- | ---------- |
        | A    | 1         | 2          |
        | B    | 1         | 1          |
        | C    | 1         | 2          |
        | D    | 2         | 0          |

### What is the formula for counting the edges with each degree node?
![Degree Formula](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f73ee0a0-fb29-4da3-92dd-e2cb0e2317ab/Untitled.png)

## Graph Structures

### What is subgraph?
A subgraph of G is a graph G' such that V(G') is a subset of V(G) and E(G') is a subset of E(G).

- Example:
    ![Subgraph Example](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/522082e4-33f2-40ae-9d36-0c5f2940e804/Untitled.png)

### What is Path?
- Path: A path is a sequence of consecutive pairs of vertices such that vi and vi+1 are adjacent.
- Example: From G to F in a dotted line is a path.
    ![Path Example](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0f1a3776-6566-4b66-b346-0104dd4fd5c4/Untitled.png)

### What is simple path?
A simple path does not contain any repeated vertices or edges or all nodes are distinct.

### What is cycle?
- A cycle path is where the first and last vertices are the same. A simple cycle is a cycle with no repeated vertices or edges (except the first and last vertices).
- A cycle is a path v1,v2,v3...vk such that:
    - First k-1 nodes are distinct.
    - v1=vk
- Example: C → B → A → D → C is a cycle
    ![Cycle Example](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/994741ed-8e62-4c31-b747-20ec2c37e6e7/Untitled.png)

### What is length of the path/distance between two nodes?
Number of edges between the initial and final vertices(Node).

### What is Reachability?
We say that v is reachable from u in graph G if and only if there is a path from u to v.

### How do we say that the graph is connected?
A graph is connected if there is a path from every vertex to every other vertex.

### What is Directed Acyclic Graph?
A directed graph with no cycles.

- Example:
    ![DAG Example](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6021fb1c-6ade-4e4c-8c23-d7473b5e8591/Untitled.png)

> 💡 Let G be an undirected graph on n nodes. Any two of the following statements implies the third.
> - G is connected.
> - G does not contain a cycle.
> - G has n−1 edges.

### What is spanning trees?
- Spanning tree is a subgraph and a single tree of the connected graph.
- The spanning tree must not have a cycle.
- Formula to find the spanning tree: $^EC(V-1) - Cycles$
- Book definition: A spanning tree of a connected graph is a subgraph that contains all of that graph's vertices and is a single tree. A spanning forest of a graph is the union of spanning trees of its connected components.
- Example:
    ![Spanning Tree Example](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/12c547d6-c118-49ee-8c98-dc18b07c5c3f/Untitled.png)

### What is minimum cost spanning tree?
The spanning tree which has the minimum sum of weighted edges.

### What is prim's algorithm for minimum cost spanning tree?
- In Prim's algorithm we select first the minimum edge of the graph and then we'll select the smallest edges from the ending nodes and we'll avoid the edge which will be forming the cycle.
- Example:
    ![Prim's Example 1](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/158b5cd6-5c17-4c90-82eb-551f17ecd8bf/methods-of-minimum-spanning-tree3.png)
    ![Prim's Example 2](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aae22479-eb5c-44d4-bf68-1865c62bae2e/methods-of-minimum-spanning-tree15.png)

### Write the algo for the prim's
- Algorithm:
    ```
    Initialize an empty MST (minimum spanning tree) and a set of visited vertices.
    Choose a starting vertex arbitrarily and mark it as visited.
    While there are unvisited vertices:
        a. Find the minimum-weight edge that connects a visited vertex to an unvisited vertex.
        b. Add this edge to the MST.
        c. Mark the newly visited vertex as visited.
    Return the MST.
    ```

### What is articulation point?
Connecting node such that after removal of that node, the graph breaks into multiple components.

- Example:
    ![Articulation Point Example](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e8eac4dc-737d-4aac-bae0-a8a731b6625c/Untitled.png)

## Applications and Representations

### What are the applications of Graphs?
The applications of graphs:

1. **Transportation networks:** The map of routes served by an airline carrier naturally forms a graph: the nodes are airports, and there is an edge from u to v if there is a nonstop flight that departs from u and arrives at v.
2. **Communication networks:** A collection of computers connected via a communication network can be naturally modeled as a graph in a few different ways.
3. **Information networks:** The World Wide Web can be naturally viewed as a directed graph, in which nodes correspond to Web pages and there is an edge from u to v if u has a hyperlink to v.
4. **Social networks:** Given any collection of people who interact (the employees of a company, the students in a high school, or the residents of a small town), we can define a network whose nodes are people, with an edge joining u and v if they are friends with one another.
5. **Dependency networks:** It is natural to define directed graphs that capture the interdependencies among a collection of objects.

### How do we represent Graph?
1. Adjacency matrix
2. Adjacency List
3. Adjacency Set

#### What is Adjacency matrix?
- Adjacency matrix is matrix of $V \times V$ dimension and if there is an edge between two vertices then it'll be represented by 1 and otherwise 0.
- Example:
    ![Adjacency Matrix Example 1](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/161dba4d-2556-46c3-9011-0d2603cf9f5d/Untitled.png)
    ![Adjacency Matrix Example 2](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6defa793-b972-4244-8d7a-17e9dc034424/Untitled.png)

- What is the space and time complexity?
    Space complexity and Time complexity: $O(V \times V)$

#### What is Adjacency List?
- It's an array of linked lists in which the size of an array is the number of vertices. And the entry in array[i] represents the linked list of the vertices adjacent to the ith vertex.

> 💡 Linked list is not the only representation to store the neighbors.

- Example:
    ![Adjacency List Example 1](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0c39306f-b44b-445e-bf91-fc1b08371189/Untitled.png)
    ![Adjacency List Example 2](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d4c0bdf0-e5f9-42f4-92e7-c495bb89d9f7/Untitled.png)

#### What is compact list/adjacent set?
In this representation, an array of size `V + 2E + 1` is used to store the graph. The first indices represent the vertices, and if there are `s` vertices, then at each index the indices are stored from where the number of edges are stored.

#### What is the difference between the Adjacency list and Adjacent matrix?

| Operation | Adjacency List | Adjacency Matrix |
|-----------|---------------|------------------|
| Space | O(2m+n) | O($N^2$) |
| Checking if (u,v) belongs to E | O(min(deg(u),deg(v)) | O(1) |
| List all edges | O(m+n) | O($N^2$) |
| Insert Edge | O(1) | O(1) |
| Delete Edge | O(deg(u)+deg(v)) | O(1) |

### How do we represent the directed graph?
Same as the undirected graph but with 1 when there is an outward edge.

### Compare the representation?
![Representation Comparison](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d3d14606-116e-4d6e-9d1a-b60a32501a7a/Untitled.png)

## Graph Traversal Algorithms

### What is Breadth First Search?
- Definition: *The **Breadth First Search (BFS)** algorithm is used to search a graph data structure for a node that meets a set of criteria. It starts at the root of the graph and visits all nodes at the current depth level before moving on to the nodes at the next depth level.*
- It's similar to Level order traversal in trees, but the difference is that trees are not cyclic but graphs are. So, to avoid processing the same node again and again we use two terms:
    - Visited
    - Not visited

- Algorithm and code:
    - Algorithm:
        ```
        Create a queue and mark all vertices as not visited.
        Enqueue the starting vertex and mark it as visited.
        Repeat the following steps until the queue is empty:
                a. Dequeue a vertex from the queue.
                b. Process the dequeued vertex (e.g., print it).
                c. Enqueue all adjacent vertices of the dequeued vertex that have not been visited and mark them as visited.
        If there are unvisited vertices, go to step 3. Otherwise, the BFS is complete.
        ```
    - Code:
        ```cpp
        void BFS(int node, vector<int>& arr[], int visited[]) {
                queue<int> q;
                visited[node] = true;
                q.push(node);
                while(!q.empty()) {
                        int frontNode = q.front();
                        q.pop();
                        for(auto i : arr[frontNode]) {
                                if(!visited[i]) {
                                        q.push(i);
                                        visited[i] = true;
                                }
                        }
                }
        }
        ```

- Working:
    - **Step 1:** Initially queue and visited arrays are empty.
        ![BFS Step 1](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8867c37d-fa0f-4286-9a2b-877513e19fcb/Untitled.png)
    
    - **Step 2:** Push node 0 into queue and mark it visited.
        ![BFS Step 2](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4b349bb7-9801-4dc4-b1e1-ffbb3a47bbf2/Untitled.png)
    
    - **Step 3:** Remove node 0 from the front of queue and visit the unvisited neighbors and push them into queue.
        ![BFS Step 3](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f3133c48-468c-44fd-886b-36761abc4984/Untitled.png)
    
    - **Step 4:** Remove node 1 from the front of queue and visit the unvisited neighbors and push them into queue.
        ![BFS Step 4](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1f3b4e0b-b36f-4621-bea5-fdd741dc5dd6/Untitled.png)
    
    - **Step 5:** Remove node 2 from the front of queue and visit the unvisited neighbors and push them into queue.
        ![BFS Step 5](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6c89740c-329d-424d-a631-25e2cdd3edc4/Untitled.png)
    
    - **Step 6:** Remove node 3 from the front of queue and visit the unvisited neighbors and push them into queue. As we can see that every neighbor of node 3 is visited, so move to the next node that is in the front of the queue.
        ![BFS Step 6](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e9a81c30-4214-4206-b35f-aac09386e5e9/Untitled.png)
    
    - **Step 7:** Remove node 4 from the front of queue and visit the unvisited neighbors and push them into queue. As we can see that every neighbor of node 4 is visited, so move to the next node that is in the front of the queue.
        ![BFS Step 7](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/24bf7f30-4575-4532-96a5-828f00158437/Untitled.png)

### Theorems Related to BFS
1. For each j ≥ 1, layer Lj produced by BFS consists of all nodes at distance exactly j from s. There is a path from s to t if and only if t appears in some layer.
2. Let T be a breadth-first search tree, let x and y be nodes in T belonging to layers Li and Lj respectively, and let (x, y) be an edge of G. Then i and j differ by at most 1.
3. The set R produced at the end of the algorithm is precisely the connected component of G containing s.
     
     Proof:
     We have already argued that for any node v ∈ R, there is a path from s to v.
     Now, consider a node w ̸∈ R, and suppose by way of contradiction, that there is an s-w path P in G. Since s ∈ R but w ̸∈ R, there must be a first node v on P that does not belong to R; and this node v is not equal to s. Thus there is a node u immediately preceding v on P, so (u, v) is an edge. Moreover, since v is the first node on P that does not belong to R, we must have u ∈ R. It follows that (u, v) is an edge where u ∈ R and v ̸∈ R; this contradicts the stopping rule for the algorithm.

### What is Breadth first search tree?
A tree that is generated while applying the BFS algorithm.

### Applications of BFS
1. Finding the shortest path
2. ⭐️: Counting all the connected components
3. To check if the graph is a Bipartite graph or not

### What is Depth-First Traversal?
- DFT uses the same principle as preorder traversal. It means visiting the node and exploring one of its adjacent nodes, then terminating the exploration of the parent node, then exploring the child node and repeating the same process until there are no adjacents left or there is a node that is unexplored.
- Example:
    ![DFT Example](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/962f111a-9afe-4202-b736-261663b32841/ezgif.com-gif-maker61.gif)

- Working:
    - **Step 1:** Initially stack and visited arrays are empty.
        ![DFS Step 1](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/25f3e877-1cf3-4fb4-9b12-e832316f3fc5/1.webp)
    
    - **Step 2:** Visit 0 and put its adjacent nodes which are not visited yet into the stack.
        ![DFS Step 2](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8f076560-72e3-4249-aa66-9dee86a711b8/2.webp)
    
    - **Step 3:** Now, Node 1 is at the top of the stack, so visit node 1 and pop it from the stack and put all of its adjacent nodes which are not visited in the stack.
        ![DFS Step 3](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1b1d579c-a856-41d7-a31d-6de134c53054/3.webp)
    
    - **Step 4:** Now, Node 2 is at the top of the stack, so visit node 2 and pop it from the stack and put all of its adjacent nodes which are not visited (i.e., 3, 4) in the stack.
        ![DFS Step 4](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1c3b43cb-ef37-4403-ad42-c364a1da97ed/4.webp)
    
    - **Step 5:** Now, Node 4 is at the top of the stack, so visit node 4 and pop it from the stack and put all of its adjacent nodes which are not visited in the stack.
        ![DFS Step 5](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a67b95e3-499f-4ed6-b60d-fc058f1e4796/5.webp)
    
    - **Step 6:** Now, Node 3 is at the top of the stack, so visit node 3 and pop it from the stack and put all of its adjacent nodes which are not visited in the stack.
        ![DFS Step 6](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1dc250d8-fbd6-4d57-8444-a1bfceda5456/DFS-(6)-copy.webp)

### Theorems based upon the DFS
1. For a given recursive call DFS(u), all nodes that are marked "Explored" between the invocation and end of this recursive call are descendants of u in T.
2. Let T be a depth-first search tree, let x and y be nodes in T, and let (x, y) be an edge of G that is not an edge of T. Then one of x or y is an ancestor of the other.
     - Proof:
         Suppose that (x,y) is an edge of G that is not an edge of T, and suppose without loss of generality that x is reached first by the DFS algorithm. When the edge (x, y) is examined during the execution of DFS(x), it is not added to T because y is marked "Explored." Since y was not marked "Explored" when DFS(x) was first invoked, it is a node that was discovered between the invocation and end of the recursive call DFS(x). It follows from (3.6) that y is a descendant of x.

### What is a back-edge?
It is an edge (u, v) such that v is an ancestor of node u but not part of the DFS Traversal of the tree.

### What is discovery time?
This is the moment when you first visit a node. It's like you're discovering it for the first time. You mark this time as you enter the node.

### What is finish time?
This is the time when you finish visiting a node and all its descendants (the nodes you can reach by following edges from the starting node). You mark this time when you leave the node.

### Why checking back-edge is important but not cross edge to form a cycle?
1. **Back-Edges:** These are edges that go backward in the DFS traversal, from a node to one of its ancestors in the DFS tree. When you encounter a back-edge, it means you've found a cycle in the graph because it creates a path that loops back to a node you've already visited in the current DFS branch. Detecting these back-edges is crucial for identifying and confirming the presence of cycles in a graph. This is important in many algorithms and applications, such as cycle detection and topological sorting.
2. **Cross Edges:** Cross-edges connect nodes that are neither ancestors nor descendants of each other in the DFS traversal. They link different branches of the DFS tree but do not form cycles. Cross edges are not used for cycle detection because they don't create loops that return to previously visited nodes. Instead, they provide information about the connectivity and structure of the graph but aren't directly related to detecting cycles.

> 💡 NO BACK EDGE IMPLIES NO CYCLE

## Advanced Graph Algorithms

### What is Topological order?
- Topological order is a linear ordering of the nodes in a Directed Acyclic Graph (DAG) where for every directed edge `(u, v)`, node `u` comes before node `v` in the ordering. In other words, it is an ordering of the nodes that respects the dependencies between them.
- Topological order is commonly used in algorithms and applications that require a sequence of steps or tasks to be performed in a specific order, where each step or task depends on the completion of certain other steps or tasks. It helps to ensure that there are no cyclic dependencies or circular dependencies in the order of execution.
- For example, in a project management context, topological order can be used to determine the order in which different tasks need to be executed based on their dependencies. It allows for efficient scheduling and planning of project activities.
- It's important to note that topological order only exists for Directed Acyclic Graphs (DAGs) and cannot be defined for graphs that contain cycles.

### What is Kahn's Algorithm?
Kahn's Algorithm is a popular algorithm used for topological sorting of directed acyclic graphs (DAGs). It was developed by Arthur B. Kahn in 1962.

The algorithm works by repeatedly selecting nodes with no incoming edges and adding them to the topological order. It starts by initializing a queue with nodes that have no incoming edges. Then, it iteratively removes a node from the queue, adds it to the topological order, and updates the incoming edges of its adjacent nodes. This process continues until all nodes have been processed or a cycle is detected.

Kahn's Algorithm is efficient and guarantees a valid topological ordering if the input graph is a DAG. It is commonly used in various applications, such as scheduling tasks, dependency resolution, and determining the order of compilation or execution in software engineering.

Here is the pseudocode for Kahn's Algorithm:

```
1. Initialize an empty list, topologicalOrder, to store the topological order.
2. Initialize a queue, q, and enqueue all nodes with no incoming edges.
3. While the queue is not empty:
         a. Dequeue a node, current, from the queue.
         b. Add current to the topological order list.
         c. For each adjacent node, neighbor, of current:
                    i. Remove the edge from current to neighbor.
                    ii. If neighbor has no other incoming edges, enqueue neighbor.
4. If the topological order list contains all nodes, return the topologicalOrder; otherwise, a cycle exists in the graph.
```

Kahn's Algorithm provides a reliable way to obtain a valid topological order for a DAG, ensuring that dependencies are respected and no cycles are present.

### What is Dijkstra algorithm?
Dijkstra's algorithm is a popular algorithm used to find the shortest path between nodes in a weighted graph. It uses a greedy approach to iteratively find the shortest path from a source node to all other nodes in the graph.

- Algorithm:
    1. Initialize the distance values from the source node to all other nodes as infinity, except for the source node itself, which is set to 0.
    2. Create an empty set of visited nodes.
    3. While there are unvisited nodes:
         - Select the unvisited node with the minimum distance value.
         - Mark the selected node as visited.
         - Update the distance values of its neighboring nodes by adding the weight of the current node.
    4. Repeat step 3 until all nodes have been visited.

- Dry Run Example:
    
    Let's consider the following weighted graph:
    
    ```
                         4
             (1)-------(3)
            / |       / |
        1/  |      /  |3
        /   |     /   |
    (0)   |   2/    |
        \\   |   /     |
        2\\  |  /4     |6
            \\ | /       |
             (2)-------(4)
                        5
    ```
    
    We want to find the shortest path from node 0 to all other nodes.
    
    - Step 1: Initialize the distance values.
        - Start node: 0 (distance = 0), all other nodes: infinity.
        - Distances: [0, inf, inf, inf, inf]
    - Step 2: Select the unvisited node with the minimum distance value.
        - Node 0 is selected.
    - Step 3: Update the distance values of its neighboring nodes.
        - Node 1: distance[1] = min(distance[1], distance[0] + weight(0, 1)) = min(inf, 0 + 1) = 1
        - Node 2: distance[2] = min(distance[2], distance[0] + weight(0, 2)) = min(inf, 0 + 2) = 2
    - Step 4: Mark node 0 as visited.
        - Visited nodes: [0]
    - Step 2: Select the unvisited node with the minimum distance value.
        - Node 1 is selected.
    - Step 3: Update the distance values of its neighboring nodes.
        - Node 3: distance[3] = min(distance[3], distance[1] + weight(1, 3)) = min(inf, 1 + 4) = 5
    - Step 4: Mark node 1 as visited.
        - Visited nodes: [0, 1]
    - Step 2: Select the unvisited node with the minimum distance value.
        - Node 2 is selected.
    - Step 3: Update the distance values of its neighboring nodes.
        - Node 4: distance[4] = min(distance[4], distance[2] + weight(2, 4)) = min(inf, 2 + 5) = 7
    - Step 4: Mark node 2 as visited.
        - Visited nodes: [0, 1, 2]
    - Step 2: Select the unvisited node with the minimum distance value.
        - Node 3 is selected.
    - Step 3: Update the distance values of its neighboring nodes.
        - Node 4: distance[4] = min(distance[4], distance[3] + weight(3, 4)) = min(7, 5 + 6) = 7
    - Step 4: Mark node 3 as visited.
        - Visited nodes: [0, 1, 2, 3]
    - Step 2: Select the unvisited node with the minimum distance value.
        - Node 4 is selected.
    - Step 3: Update the distance values of its neighboring nodes.
        - No unvisited neighbors.
    - Step 4: Mark node 4 as visited.
        - Visited nodes: [0, 1, 2, 3, 4]

### Bellman Ford algorithm
The Bellman-Ford algorithm is a popular algorithm used to find the shortest path between nodes in a weighted graph, even in the presence of negative edge weights. It is an improvement over Dijkstra's algorithm, which does not handle negative weights.

The algorithm works by iteratively relaxing the edges of the graph, reducing the distance estimates for each node until it reaches the optimal shortest paths.

Here is the basic idea of the Bellman-Ford algorithm:

1. Initialize the distance values from the source node to all other nodes as infinity, except for the source node itself, which is set to 0.
2. Repeat the following steps for a total of |V|-1 times, where |V| is the number of vertices:
     - For each edge (u, v) in the graph, update the distance estimate for v if the distance from the source node to u plus the weight of (u, v) is smaller than the current distance estimate for v.
3. After the |V|-1 iterations, check for any negative-weight cycles in the graph. If a shorter path is found, then there must be a negative-weight cycle.
4. If no negative-weight cycles are found, the algorithm terminates, and the final distance estimates represent the shortest path from the source node to all other nodes.

The Bellman-Ford algorithm has a time complexity of O(|V| * |E|), where |V| is the number of vertices and |E| is the number of edges in the graph. It is slower than Dijkstra's algorithm but is more versatile as it can handle graphs with negative edge weights.

### Floyd Warshall algorithm
The Floyd-Warshall algorithm is a popular algorithm used to find the shortest paths between all pairs of nodes in a weighted graph. It works for both directed and undirected graphs, with positive or negative edge weights (but no negative cycles).

Here is an overview of the Floyd-Warshall algorithm:

1. Initialize a distance matrix, `dist`, with the initial distances between each pair of nodes. If there is no edge between two nodes, the distance is set to infinity.
2. For each intermediate node, `k`, from 1 to the number of nodes:
     - For each pair of nodes, `i` and `j`, from 1 to the number of nodes:
         - If the distance from `i` to `j` through `k` is shorter than the current distance, update the distance.
3. The final `dist` matrix will contain the shortest distances between all pairs of nodes.

The Floyd-Warshall algorithm is based on dynamic programming principles and uses a matrix to store the distances. It iteratively considers all possible intermediate nodes and updates the distances accordingly, gradually building up the shortest paths.

The time complexity of the Floyd-Warshall algorithm is O(V^3), where V is the number of vertices in the graph. It is suitable for dense graphs or situations where the number of nodes is relatively small.

### Disjoint set union
> 🧩 **Disjoint set union**
> 
> The Disjoint Set Union (DSU) data structure, also known as the Union-Find data structure, is used to efficiently manage a collection of disjoint sets. It supports two main operations: union and find.
> 
> - **Union:** Combines two sets into a single set by merging their respective sets.
> - **Find:** Determines which set a particular element belongs to.
> 
> The DSU data structure is commonly used in various algorithms and applications, such as:
> 
> - Detecting connected components in a graph.
> - Checking if two elements belong to the same set.
> - Implementing Kruskal's algorithm for finding minimum spanning trees.
> - Solving dynamic connectivity problems.
> 
> The DSU data structure maintains a forest of rooted trees, where each tree represents a disjoint set. Each element in the set has a parent pointer that points to its parent in the tree. The root of each tree represents the representative of the set.
> 
> To perform a union operation, the trees representing the two sets are merged by making one tree the child of the other. This is usually done by linking the root of one tree to the root of the other tree.
> 
> The find operation is used to determine the representative of a set. It follows the parent pointers until it reaches the root of the tree.
> 
> The DSU data structure can be implemented using various techniques, such as rank-based union and path compression, to achieve efficient time complexity for both union and find operations.

### Strongly Connected Components - Kosaraju's Algorithm
Kosaraju's Algorithm is a graph algorithm used to find the strongly connected components (SCCs) in a directed graph. A strongly connected component is a subgraph in which there is a path between every pair of nodes.

Here is an overview of Kosaraju's Algorithm:

1. Perform a depth-first search (DFS) on the graph and keep track of the order in which nodes finish their DFS traversal (known as the "finishing times").
2. Transpose the graph by reversing the direction of all edges.
3. Perform a second DFS on the transposed graph, starting from the node with the highest finishing time from step 1. Each DFS traversal from this step will give us one strongly connected component.

Kosaraju's Algorithm is based on the fact that the transpose of a graph has the same SCCs as the original graph. By performing two DFS traversals, we can identify all the SCCs in the graph.

The time complexity of Kosaraju's Algorithm is O(V + E), where V is the number of vertices and E is the number of edges in the graph. It is an efficient algorithm for finding SCCs in large graphs.
