# Detect Cycle in an Undirected Graph using BFS

---

## Question

**Detect Cycle in an Undirected Graph using BFS**

You are given an undirected graph with `V` vertices and a list of edges. The task is to determine if the graph contains a cycle.

**Example:**

* Input: `V = 5, edges = [[0,1],[1,2],[2,3],[3,4]]`

* Output: `false` (No cycle)

* Input: `V = 4, edges = [[0,1],[1,2],[2,0],[2,3]]`

* Output: `true` (Cycle exists between `0-1-2-0`).

---

## Approach

1. Construct an adjacency list from the given edges.
2. Maintain a visited array to track visited nodes.
3. For every unvisited node, perform **BFS traversal**:

   * Use a queue of `{node, parent}` pairs.
   * For each neighbor:

     * If not visited → mark visited and push into queue.
     * If already visited and neighbor is not the parent → a cycle exists.
4. If BFS for any component finds a cycle → return `true`.
5. If no cycles in all components → return `false`.

---

## Pattern

**Queue Pattern – BFS Traversal for Cycle Detection**

* Hint: *"Whenever we want to explore nodes level by level and also need to track parent-child relations in an undirected graph, we use BFS with a queue."*
* Why Queue?

  * BFS ensures systematic exploration of all neighbors level by level.
  * The queue keeps track of nodes to explore, and the parent information helps in avoiding false cycle detection from immediate backtracking edges.
  * This pattern is common in graph problems where level order or shortest path is needed.

---

## Time & Space Complexity

* **Time Complexity:** `O(V + E)`

  * Each node and edge is processed once.
* **Space Complexity:** `O(V + E)`

  * Adjacency list stores edges, visited array uses `O(V)`, and BFS queue uses at most `O(V)`.

---

## Dry Run

**Input:**
`V = 4, edges = [[0,1],[1,2],[2,0],[2,3]]`

Adjacency List:

* 0 → \[1,2]
* 1 → \[0,2]
* 2 → \[1,0,3]
* 3 → \[2]

Steps:

* Start with node `0`. Mark visited. Queue = `{(0, -1)}`.
* Pop `(0,-1)`. Neighbors:

  * `1` not visited → push `(1,0)`.
  * `2` not visited → push `(2,0)`.
* Queue = `{(1,0), (2,0)}`.
* Pop `(1,0)`. Neighbors:

  * `0` is parent → ignore.
  * `2` is visited and not parent → cycle found.

Answer: `true`.

---

## Correct C++ Code

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

class Solution {
public:
    bool bfs(vector<vector<int>>& adj, int src_node, vector<bool>& visited) {
        queue<pair<int,int>> que; // {node, parent}
        visited[src_node] = true;
        que.push({src_node, -1});

        while (!que.empty()) {
            int curr_node = que.front().first;
            int curr_parent = que.front().second;
            que.pop();

            for (auto neighbor : adj[curr_node]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    que.push({neighbor, curr_node});
                }
                else if (neighbor != curr_parent) {
                    // Visited and not parent → cycle
                    return true;
                }
            }
        }
        return false;
    }

    bool isCycle(int V, vector<vector<int>>& edges) {
        vector<vector<int>> adj(V);

        // Build adjacency list
        for (auto& edge : edges) {
            int u = edge[0];
            int v = edge[1];
            adj[u].push_back(v);
            adj[v].push_back(u); // undirected graph
        }

        vector<bool> visited(V, false);

        // Check all components
        for (int i = 0; i < V; i++) {
            if (!visited[i]) {
                if (bfs(adj, i, visited)) {
                    return true;
                }
            }
        }
        return false;
    }
};

int main() {
    Solution sol;
    int V = 4;
    vector<vector<int>> edges1 = {{0,1},{1,2},{2,0},{2,3}};
    cout << sol.isCycle(V, edges1) << endl; // Output: 1 (true)

    vector<vector<int>> edges2 = {{0,1},{1,2},{2,3}};
    cout << sol.isCycle(4, edges2) << endl; // Output: 0 (false)
    return 0;
}
```

---
