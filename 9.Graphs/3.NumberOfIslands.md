# Number of Islands

---

## Question

**Number of Islands**

You are given an `m x n` 2D binary grid:

* `'1'` → represents land.
* `'0'` → represents water.

An island is formed by connecting **4-directionally adjacent** lands (`up, down, left, right`).

Return the **number of islands**.

**Example:**

```
grid = [
  ['1','1','0','0','0'],
  ['1','1','0','0','0'],
  ['0','0','1','0','0'],
  ['0','0','0','1','1']
]
```

Output: `3`

---

## Approach (BFS)

1. Keep a `visited` matrix initialized to false.
2. Traverse the entire grid.
3. If we encounter a cell that is land (`'1'`) and not visited:

   * Start BFS from this cell.
   * BFS will mark all land cells connected to this one as visited.
   * Increase island count.
4. BFS implementation:

   * Use a queue of `(row,col)`.
   * For each cell, explore its **4 neighbors** (up, down, left, right).
   * If neighbor is valid land and not visited → mark visited and push into queue.

---

## Pattern

**Graph Pattern – Connected Components in Grid using BFS**

* Hint: *"Whenever we need to count groups of connected elements in a grid using level-order traversal, BFS is a good fit."*
* Why BFS?

  * BFS ensures we visit all connected land cells starting from one source before moving on.
  * Prevents double counting of the same island.

---

## Time & Space Complexity

* **Time Complexity:** O(N \* M) → Each cell is visited at most once.
* **Space Complexity:** O(N \* M) → For `visited[][]` and BFS queue in the worst case (grid full of land).

---

## Dry Run

**Input:**

```
grid = [
  ['1','1','0'],
  ['0','1','0'],
  ['1','0','1']
]
```

Steps:

* Start (0,0) → new island → BFS covers (0,0),(0,1),(1,1).
* Next unvisited land: (2,0) → new island.
* Next unvisited land: (2,2) → new island.
  Answer = 3.

---

## Correct C++ Code

```cpp
#include <vector>
#include <queue>
using namespace std;

class Solution {
public:
    void BFS(int row, int col, const vector<vector<char>>& grid, 
             vector<vector<bool>>& visited, int startRow, int startCol) {
        
        queue<pair<int, int>> q;
        q.push({startRow, startCol});
        visited[startRow][startCol] = true;
    
        // Directions: Up, Down, Left, Right
        int dRow[] = {-1, 1, 0, 0};
        int dCol[] = {0, 0, -1, 1};
    
        while (!q.empty()) {
            int r = q.front().first;
            int c = q.front().second;
            q.pop();
    
            // Check 4 neighbors
            for (int i = 0; i < 4; i++) {
                int newRow = r + dRow[i];
                int newCol = c + dCol[i];
    
                if (newRow >= 0 && newRow < row && newCol >= 0 && newCol < col &&
                    grid[newRow][newCol] == '1' && !visited[newRow][newCol]) {
                    
                    visited[newRow][newCol] = true;
                    q.push({newRow, newCol});
                }
            }
        }
    }

    int numIslands(vector<vector<char>>& grid) {
        if (grid.empty() || grid[0].empty()) return 0;

        int row = grid.size();
        int col = grid[0].size();
        vector<vector<bool>> visited(row, vector<bool>(col, false));
        int ctr = 0;

        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (grid[i][j] == '1' && !visited[i][j]) {
                    ctr++;
                    BFS(row, col, grid, visited, i, j);
                }
            }
        }

        return ctr;
    }
};
```

---
