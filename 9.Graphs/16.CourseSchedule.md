
## **Problem Name:** Course Schedule

**Problem Link:** [LeetCode](https://leetcode.com/problems/course-schedule/)

### **1. Problem Understanding**

We are given:

  * An integer `numCourses` representing the total number of courses, labeled from `0` to `numCourses - 1`.
  * A list of `prerequisites`, where each `prerequisites[i] = [a, b]` means you must take course `b` before you can take course `a`.

**Task:**
Determine if it is possible to finish all courses. Return `true` if possible, `false` otherwise.

**Example:**

  * `numCourses = 2`, `prerequisites = [[1, 0]]` → `Output: true`
      * To take course 1, you must finish course 0. This is possible.
  * `numCourses = 2`, `prerequisites = [[1, 0], [0, 1]]` → `Output: false`
      * To take course 1, you need 0, but to take 0, you need 1. This is a circular dependency, so it's impossible.

-----

### **2. When to Think of Graphs & Topological Sort**

This is a classic graph problem. Here's how to spot it:

1.  **Entities and Relationships:** The problem involves distinct items (courses) and relationships between them (prerequisites). This structure naturally maps to a **graph**, where courses are **nodes (vertices)** and prerequisites are **directed edges**.
2.  **Order and Dependencies:** The core of the problem is about a valid ordering. When you need to find a linear ordering of tasks or items that have dependencies, you should immediately think of **Topological Sorting**.
3.  **Detecting Impossibility:** The question "Is it possible?" often translates to "Is there a contradiction in the dependencies?". In a directed graph, a contradiction is a **cycle**. A topological sort can only exist in a **Directed Acyclic Graph (DAG)**. Therefore, the problem is equivalent to detecting a cycle in a directed graph.

-----

### **3. Why Kahn's Algorithm (Topological Sort)**

To solve this, we need to check for cycles in the directed graph we've built. **Kahn's algorithm** is a standard and intuitive way to perform a topological sort, which simultaneously detects cycles.

  * **The Core Idea:** The algorithm simulates the process of taking courses. You can only start with courses that have **no prerequisites**. In graph terms, these are nodes with an **in-degree of 0**.
  * **How it Works:**
    1.  Start with all courses that have no prerequisites (in-degree 0).
    2.  "Take" one of these courses. This means you have now fulfilled a prerequisite for other courses.
    3.  Update the prerequisite count (in-degree) for the dependent courses.
    4.  If any of those courses now have no remaining prerequisites, they become available to be taken.
    5.  Repeat this until no more courses are available.
  * **Cycle Detection:** If, at the end, you were able to "take" all the courses, it means there were no circular dependencies (no cycles). If some courses are left over, they must be part of a cycle.

-----

### **4. Algorithm (Kahn's Algorithm)**

**Step-by-step:**

1.  **Build the Graph:**
      * Create an **adjacency list** to represent the graph, where `adj[i]` stores all courses that have `i` as a prerequisite.
      * Create an `in_degree` array to store the number of prerequisites for each course.
2.  **Populate Graph and In-Degrees:**
      * Iterate through the `prerequisites` list. For each pair `[a, b]`, it represents an edge `b -> a`.
      * Add `a` to `adj[b]`.
      * Increment `in_degree[a]`.
3.  **Initialize the Queue:**
      * Create a queue.
      * Iterate from `0` to `numCourses - 1`. If `in_degree[i]` is `0`, push course `i` into the queue.
4.  **Process Courses:**
      * Initialize a `count` of completed courses to `0`.
      * While the queue is not empty:
          * Dequeue a course `u`. This is a course we can "take".
          * Increment `count`.
          * For each neighbor `v` in `adj[u]`:
              * Decrement `in_degree[v]`.
              * If `in_degree[v]` becomes `0`, it means all its prerequisites are met, so enqueue `v`.
5.  **Final Check:**
      * After the loop finishes, if `count` is equal to `numCourses`, it means we processed every course. The graph is a DAG, and we can return `true`.
      * If `count < numCourses`, it means some courses were never processed because they were part of a cycle. Return `false`.

-----

### **5. Complexity Analysis**

Let **V** be the number of courses and **E** be the number of prerequisites.

  * **Time Complexity:** $O(V + E)$
      * Building the adjacency list and in-degree array takes $O(E)$ time.
      * Initializing the queue takes $O(V)$ time.
      * The main while loop processes each vertex and each edge exactly once. This takes $O(V + E)$.
  * **Space Complexity:** $O(V + E)$
      * The adjacency list requires $O(V + E)$ space.
      * The `in_degree` array requires $O(V)$ space.
      * The queue can hold up to $V$ vertices in the worst case, requiring $O(V)$ space.

-----

### **6. Code**

```cpp
class Solution {
public:
    // This function implements Kahn's Algorithm for topological sort
    bool isPossible(vector<vector<int>>& adj, int V) {
        vector<int> in_degree(V, 0);

        // Calculate in-degrees for all vertices
        for (int i = 0; i < V; i++) {
            for (int v : adj[i]) {
                in_degree[v]++;
            }
        }

        queue<int> que;
        // Add all nodes with 0 in-degree to the queue
        for (int i = 0; i < V; i++) {
            if (in_degree[i] == 0) {
                que.push(i);
            }
        }

        int processed_nodes = 0;

        // Process nodes from the queue
        while (!que.empty()) {
            int node = que.front();
            que.pop();
            processed_nodes++; // Increment counter for processed nodes

            // Process all neighbors of the current node
            for (int neighbor : adj[node]) {
                in_degree[neighbor]--; // Decrease in-degree of neighbor

                // If in-degree becomes 0, add it to the queue
                if (in_degree[neighbor] == 0) {
                    que.push(neighbor);
                }
            }
        }

        // If we processed all nodes, no cycle exists
        return processed_nodes == V;
    }

    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        vector<vector<int>> adj(numCourses);

        // Build adjacency list from prerequisites
        // Edge v -> u means v is a prerequisite for u
        for (const auto& p : prerequisites) {
            int u = p[0];
            int v = p[1];
            adj[v].push_back(u);
        }

        // Check if a valid topological sort is possible
        return isPossible(adj, numCourses);
    }
};
```

-----

### **7. Dry Run Example**

**Input:** `numCourses = 4`, `prerequisites = [[1,0], [2,0], [3,1], [3,2]]`

1.  **Graph & In-Degree:**

      * Edges: `0->1`, `0->2`, `1->3`, `2->3`
      * `adj` = `{0:[1,2], 1:[3], 2:[3], 3:[]}`
      * `in_degree` = `{0:0, 1:1, 2:1, 3:2}`

2.  **Initialize Queue:**

      * Only course `0` has an in-degree of 0.
      * `queue` = `[0]`
      * `processed_nodes` = `0`

3.  **Processing Loop:**

      * **Dequeue `0`:** `queue` = `[]`, `processed_nodes` = `1`.
          * Neighbors of `0` are `1` and `2`.
          * `in_degree[1]` becomes `0`. Enqueue `1`.
          * `in_degree[2]` becomes `0`. Enqueue `2`.
          * `queue` = `[1, 2]`
      * **Dequeue `1`:** `queue` = `[2]`, `processed_nodes` = `2`.
          * Neighbor of `1` is `3`.
          * `in_degree[3]` becomes `1`. (Not 0, so don't enqueue).
      * **Dequeue `2`:** `queue` = `[]`, `processed_nodes` = `3`.
          * Neighbor of `2` is `3`.
          * `in_degree[3]` becomes `0`. Enqueue `3`.
          * `queue` = `[3]`
      * **Dequeue `3`:** `queue` = `[]`, `processed_nodes` = `4`.
          * No neighbors.
      * Queue is now empty. Loop terminates.

4.  **Final Check:**

      * `processed_nodes` (4) == `numCourses` (4).
      * ✅ **Return `true`**.

-----

### **8. Key Takeaways**

1.  **Dependency -\> Graph:** Problems involving prerequisites, dependencies, or a required order of events are strong candidates for graph-based solutions.
2.  **"Possible to complete?" -\> "Is it a DAG?":** The core question of whether a set of dependent tasks can be completed is equivalent to checking if the corresponding directed graph is acyclic.
3.  **Kahn's Algorithm is Your Tool:** This algorithm is a go-to for both finding a topological sort and detecting cycles in a directed graph. Its logic of using in-degrees and a queue is efficient and mirrors how one would solve such a problem in real life.