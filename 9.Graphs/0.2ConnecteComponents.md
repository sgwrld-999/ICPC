# Connected Components in a Graph

Imagine a social network. You and your friends form a group, your friends' friends are also in that group, and so on. Anyone within this group is connected to everyone else through some chain of friendships. However, there might be another group of people in a different city that has no connection to your group at all.

That's the core idea! A connected component is a part of a graph where every node is reachable from every other node within that same part. Think of it as an "island" of nodes in your graph. üèùÔ∏è

In the image above, the graph has 3 connected components:

- Component 1: {0, 1, 2}
- Component 2: {3, 4, 5, 6}
- Component 3: {7}

A graph is considered **fully connected** if it has only one connected component.

## Finding the Number of Connected Components

So, how do we write a program to count these "islands"? The strategy is quite elegant and relies on a standard graph traversal algorithm like Depth First Search (DFS) or Breadth First Search (BFS).

Here's the game plan:

1. **Keep Track of Visitors**: Create a visited boolean array, `visited[i]`, which is initially false for all nodes i. This array will help us avoid recounting nodes or getting stuck in cycles.

2. **Iterate and Explore**: Loop through every single node in the graph, from 1 to N.

3. **Discover New Islands**: For each node i, check if it has been visited yet (`!visited[i]`).
    - If it hasn't been visited, it means we've just landed on a new, unexplored island (a new connected component).
    - So, we increment our component counter.
    - Then, we start a traversal (like DFS) from this node i. The DFS will explore every reachable part of this island, marking every node it finds as visited.

4. **Count is the Answer**: After the loop finishes, the component counter will hold the total number of connected components in the graph.

## C++ Implementation (using DFS)

This is a classic problem in competitive programming. Here's how you'd implement the logic using an adjacency list and DFS.

```cpp
#include <iostream>
#include <vector>

// Adjacency list to store the graph
std::vector<std::vector<int>> adj;
// Visited array to keep track of visited nodes
std::vector<bool> visited;

// The DFS function to explore a component
void dfs(int u) {
     // Mark the current node as visited
     visited[u] = true;

     // Explore all its neighbors
     for (int neighbor : adj[u]) {
          // If the neighbor hasn't been visited, recursively call dfs on it
          if (!visited[neighbor]) {
                dfs(neighbor);
          }
     }
}

int main() {
     int n, m; // n = nodes, m = edges
     std::cout << "Enter number of nodes and edges: ";
     std::cin >> n >> m;

     // Resize our data structures
     adj.resize(n + 1);
     visited.resize(n + 1, false);

     std::cout << "Enter " << m << " edges (u v):" << std::endl;
     for (int i = 0; i < m; ++i) {
          int u, v;
          std::cin >> u >> v;
          adj[u].push_back(v);
          adj[v].push_back(u); // Undirected graph
     }

     int component_count = 0;

     // Loop through all nodes to find unvisited ones
     for (int i = 1; i <= n; ++i) {
          if (!visited[i]) {
                // Found a start of a new component
                component_count++;
                // Explore this entire component
                dfs(i);
          }
     }

     std::cout << "Total number of connected components: " << component_count << std::endl;

     return 0;
}
```

## Why is this useful?

Understanding connected components is crucial for many problems, such as:

- **Network Connectivity**: Determining if a computer network is fully connected or partitioned into separate sub-networks.
- **Social Network Analysis**: Identifying separate communities or groups of friends.
- **Pathfinding**: If two nodes are in different components, you know immediately that no path exists between them, saving you from running a costly pathfinding algorithm.
