# Introduction to Trees 

## 1. BINARY TREE 
### What is a Tree?
- Its a non - linear data structure which follow hierarchical structure that is used to represent and organize data. It's a collection of nodes in which topmost node is called as ROOT node. And each node have a hierarchical relation between them.
- Bookish Definition(Recursive) : A tree is a finite set of one or more nodes such that :
    - There is special designated node called root.
    - The remaining nodes are partitioned into n >=0 disjoint set T1,. . . . ,Tn where each of these sets is a tree.
    - T1,. . . . ,Tn are called the subtrees of the root

### What are the terminology?
        
The terminology which is used is : 
        
1. Root : The top most node which don't have any parents.
2. Parent : Predecessor of a node
3. Child : Immediate successor of a node.
4. Sibling : A child of same parents
5. Edges : Connecting line of parent and child 
6. Leaf/External nodes/terminal node : A nodes which don't have any child.
7. Descendants :
8. Ancestors : Any node on the path of leaf node to root node.
9. Degree of nodes : Number of child which are connected to that node.
10. Forest : Collection of trees 
11. Height : The count of edge from along the longest path from root to bottom.
12. Internal node : Have at least one child.
13. Level : The count of edges along the path from root to leaf.
14. Example : 
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e9af4506-6042-4a3d-b974-5c6b818c24c1/Untitled.png)
            
### What is a node?
        
The item of information is called NODE
        
### What is a Binary Tree?
- A binary tree is a tree which can have at most 2 child.
- Bookish definition: It's a finite set of nodes that is either empty or consist of a root and two disjoint binary tree called left subtree and Right subtree.

### What is a left or right skew tree?
- Left skew tree : A tree which have only left child.
- Right skew tree : A tree which have only right child.

### How many maximum nodes are at a height of the binary tree?
        
`2^h`
        
### What is the maximum no. of trees in a binary tree(labelled and unlabelled)? Given n nodes are in the tree.
1. Unlabeled: $2n!/ (n+1)! n!$
2. Labeled: $2n!/ (n+1)!$

### What is the maximum and minimum height of a binary tree? Given n nodes are in the tree.
- Min: $(log2(n +1))-1$ [logn-1 mei 1 aur hata do]
- Max: n - 1

### What is the maximum and minimum no. of nodes required to construct a binary tree? Given h is the height of the binary tree.
- Min: h + 1
- Max: 2^(h+1) - 1

### What is the relation between the leaf nodes and deg-2 nodes?
- No = N2 + 1

### What is a strict/proper/Full binary tree?
- A binary tree which have either 0 or 2 child not 1.
- Bookish definition: A Binary Tree with n nodes and k is computer if its nodes corresponds to the nodes numbered from 1 to n in the full binary tree of height h.
- Example:
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f5fcfd06-377b-428c-8e66-077283df6707/Untitled.png)
            
### What is a complete binary tree?
- All levels completely filled with nodes except the last level and in the last level, all the nodes are as left side as possible.
- Example:
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9c147c8a-0207-459b-ad4f-564571b40994/Untitled.png)
            
### What is a Perfect binary tree?
- Binary Tree in which all internal nodes have 2 children and all the leaf nodes are at the same depth or same level.
- Example:
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/463b736a-fd8f-49c6-94e9-6e84d5c69c5d/Untitled.png)
            
### What is the maximum and minimum height of a Strict binary tree? Given n nodes are in the tree.
- Max: $n - 1$
- Min: $(log2(n +1))-1$

### What is the maximum and minimum no. of nodes required to construct a Strict binary tree? Given h is the height of the binary tree.
- Min: 2h +1
- Max: 2^(h+1) - 1

### What is the relation b/w leaf/External nodes and Non-leaf/internal?
        
leaf = Non-leaf + 1
        
### What is an N-ary Tree? In the N-ary tree "N" stands for? Also if height h is given find max and min nodes. Also, if n nodes are given then find the max and min height of the tree.
        
In the N-ary tree max degree of a node can have is M. 
        
- Height:
    - Max: $n - 1 / m$
    - min: (LogN(n(N-1)))-1
- Nodes:
    - Max: $Nh + 1$
    - min: N^( h + 1 ) - 1 / N - 1

### How do we represent a Binary tree? Also, write the C code for it.
        
We represent binary tree the Linked list and array also.
        
- Code:
    
    ```c
    typedef struct BTN
    {
        struct BTN *lc ;
        int data ;
        struct BTN *rc ;
    }tree;
    
    tree *newNode(int data){
        tree *newNode = (tree *)malloc(sizeof(tree));
        newNode -> data = data ;
        newNode ->lc = NULL ;
        newNode ->rc = NULL ;
        return newNode ;
    }
    
    tree *insertLeft(tree *root , int value){
        root -> lc = newNode(value);
        return root -> lc ;
    }
    
    tree *insertright(tree *root , int data){
        root -> rc = newNode(data);
        return root -> rc ;
    }
    ```
            
### How do we traverse the elements in the array?
1. If the index is starting from zero then: 
   - To excess the root node: $[i / 2]$
   - To excess the right child node: $[ 2 * i + 2 ]$
   - To excess the left child: $2 * i + 1$
2. If the index is starting from one:
   - To excess the root node: $[i / 2]$
   - To excess the right child node: $[ 2 * i + 1 ]$
   - To excess the left child: $2 * i$

### What is the difference between Full and Complete Binary tree?
        
| S. No. | **Complete Binary Tree** | **Full Binary Tree** |
| --- | --- | --- |
| 1. | In a complete binary tree, a node in the last level can have only one child. | In a full binary tree, a node cannot have just one child. |
| 2. | In a complete binary tree, the node should be filled from the left to right. | There is no order of filling nodes in a full binary tree. |
| 3. | Complete binary trees are mainly used in heap-based data structures. | Full binary tree has no application as such but is also called a proper binary tree. |
| 4. | A complete binary tree is also called almost complete binary tree. | A full binary tree also called proper binary tree or 2-tree. |
| 5. | A complete binary tree must have the entire leaves node in the exact same depth. | In full binary tree leaf level not necessarily have to be in the same depth. |

### What is Tree Traversal? In how many ways can we do the tree traversal and explain each traversal.
- Traversing each node data.
- There are 3 types of traversing each node:
    1. In order: L D R 
       - Code:
           ```c
           void Inorder(tree *root){
               if(root != NULL){
                   Inorder(root -> lc) ;
                   printf("%d"  , root -> data) ;
                   Inorder(root->rc) ;
               }
               return;
           }
           ```
    2. Post order: L R D
       - Code:
           ```c
           void postorder(tree *root){
               if(root != NULL){
                   postorder(root -> lc) ;
                   postorder(root->rc) ;
                   printf("%d"  , root -> data) ; 
               }
               return;
           }
           ```
    3. Pre order: D L R 
       - Code:
           ```c
           void preorder(tree *root){
               if(root != NULL){
                   printf("%d"  , root -> data) ;
                   preorder(root -> lc) ;
                   preorder(root->rc);
               }
               return;
           }
           ```
                    
### How we can calculate the height and Number of Nodes?
1. We can calculate the height by using the idea of post order traversal.
   - Code:
       ```c
       int Height(tree* root) {
           if (root == NULL) {
               return 0;
           } else {
               int leftHeight = Height(root->leftChild) ;
               int rightHeight = Height(root->rightChild);
               return (leftHeight > rightHeight ? leftHeight : rightHeight) + 1;
           }
       }
       ```
            
2. Number of nodes:
   - Code:
       ```c
       int countNumberOfNodes(tree *root){
           int x , y ;
           if(root != NULL){
               x = countNumberOfNodes(root -> leftChild) ;
               y = countNumberOfNodes(root->rightChild) ;
               return x + y + 1 ;
           }
           return 0;
       }
       ```
                
### Which traversal is mainly used?
        
Post order Traversal


## 2. Binary Search Tree
### What is a binary Search Tree?
        
**Binary Search Tree** is a node-based binary tree data structure which has the following properties:
        
- The left subtree of a node contains only nodes with keys lesser than the node's key.
- The right subtree of a node contains only nodes with keys greater than the node's key.
- The left and right subtree each must also be a binary search tree.

### What are the properties of BST?
- No duplicates
- In order gives sorted order

### What is the time complexity of the BST?
        
Time complexity of BST depends upon height of the BST:
        
$logn ≤ h ≤ n$
        
$O(n) ≤ Time complexity ≤ O(logn)$
        
### Write code for creating the BST
- Code:
    ```c
    typedef struct tree tree;
    struct tree 
    {
        tree *lc ;
        int data ;
        tree *rc ;
    };
    
    tree *createNode(int data){
        tree *root = (tree *)malloc(sizeof(tree));
        root -> data = data ;
        root -> lc = n;
        root -> rc = n;
    
        return root  ;
    }
    
    tree *createBST(tree *root , int data){
        if (root == n)
        {
            return createNode(data);
        }
        else if (data < root -> data)
        {
            root-> lc = createBST(root -> lc , data);
        }
        else if(data > root -> data){
            root -> rc = createBST(root -> rc , data);
        }
        
        return root;
    }
    
    tree *searchBST(tree *root , int data){
        if (root ->data == data)
        {
            return root ;
        }
        else if (data < root -> data)
        {
            return searchBST(root -> lc , data);
        }
        else if(data > root -> data){
            return searchBST(root -> rc , data);
        }
    
        return n ;
    }
    ```
            
### What is the logic behind the searching, and insertion in the BST?
- We compare the given key to the root data
    - if the root data ≥ key the pointer will be shifted right
    - if the root data ≤ key the pointer will be shifted left
- For inserting the process will be run till the leaf nodes.

### What is the time complexity of the creating the BST tree?
        
TC: O($n * logn$)

## 3. AVL Trees
### What are AVL trees?
- `BST which are self - height balanced` or the difference between left height sub-tree and right subtree is at most 1 are called AVL trees.

### What is balancing factor?
- Height = $|heightOfLEftSubtree - heightOfRighttSubtree|$
- Count the edges not the nodes.

### What are the types of Rotation? And also show them how they work.
        
There 2 ways in which we can do rotation:
        
- Single Rotation: Only one rotation is done:
    1. RR: The tree is unbalanced from right side. So, we've to perform rotation on the left side.
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7254f6fd-247f-472d-bc88-4cebf1c12aaa/Untitled.png)
                
    2. LL: The tree is unbalanced from left side. So, we've to perform rotation on the right side.
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/078992b4-674a-4a70-b41e-4210a0f2bc64/Untitled.png)
                
- Double Rotation:
    - LR: 2 rotation is done:
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/401e991a-8dac-4a6f-9c8a-bd42a3f62678/Untitled.png)
                
    - RL:
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1e39482e-c8d0-4539-8a8e-54fe6fef70a5/Untitled.png)
                
### In how many nodes rotation can be done?
        
Only on 3 nodes.
        
### What are the maximum and minimum nodes of AVL tree given that height h?
- Minimum: N(h-1) + N(h-2) + 1
    - height v/s Node
    
    | Height(h) | Node(n) |
    | --- | --- |
    | 1 | 1 |
    | 2 | 2 |
    | 3 | 4 |
    | 4 | 7 |
    | 5 | 12 |
    | 6 | 20 |
    | 7 | 23 |
- Maximum: $Logn$

## 4. Binary Heap
### What is Binary Heap?
        
Heap is a special tree data structure in which tree is complete Binary tree is called Binary heap.
        
### What is Binary Max heap?
- Heap in which the root node have greater value than that of their descendants child nodes.
- Ex:-
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6af11132-e150-46a0-9904-051c3094fdf4/Untitled.png)
            
### What is Binary Min Heap?
- Heap in which the root node have smaller value than that of their descendants child nodes.
- Ex:
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e5e4ecdc-9785-4c2f-af00-5f7fc9c2286c/Untitled.png)
            
### How the insertion in Heap occur?
- The insertion of heap occur in a such a manner that it'll retain the property that is it'll be a complete binary tree.
- Left to Right.
- If it's a Max Heap then the comparison of the root node and child node is node. If the child node is holding the value greater than that of parent node it'll be swapped. Till it'll reach it correct position. Same for min heap.

### Write the code for insertion in heap.
        
```c
void insertionHeap(int *array , int n ){
    int i = n - 1 , temp = array[n-1];
    while (i > 0 && array[i % 2 == 0 ? (i/2) -1 : i / 2])
    {
        array[i] = array[i % 2 == 0 ? (i / 2) - 1 : i / 2 ] ;
        i = i % 2 == 0 ? (i/2) -1 : i / 2
    }
    array[i] = temp ;
}
```
        
### How to we create a Heap?
        
We create by making the complete binary tree and using the property of the Max and Min heap.
        
### Write the code for creation of heap?
- Array:
    
    ```c
    void insertionHeap(int *array , int n ){
        int i = n - 1 , temp = array[n-1];
        while (i > 0 && array[i % 2 == 0 ? (i/2) -1 : i / 2])
        {
            array[i] = array[i % 2 == 0 ? (i / 2) - 1 : i / 2 ] ;
            i = i % 2 == 0 ? (i/2) -1 : i / 2 ;
        }
        array[i] = temp ;
    }
    
    void createHeap(int *array , int size){
        for (int i = 0; i < size ; i++)
        {
            insertHeap(array , size);
        }
    }
    ```
            
### What is heapify?
- Heapify is the process of rearrangement of the elements of binary tree so it'll restore the property of the of heap.
- It starts from the last parent node iteratively shifts towards other nodes. RIGHT TO LEFT
- In heapify the element of the root node is compared to its children if the children node contains the value greater than the value of root element it'll swap and it'll done till the property of the heap is stored.

### Write the code for the heapify