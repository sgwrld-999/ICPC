
## Question

**Immediate Smaller Element**

Given an array `arr[]` of size `n`, replace every element with the nearest smaller element on its right. If no such element exists, replace it with `-1`.

**Example:**

* Input: `arr = [4, 2, 1, 5, 3]`
* Output: `arr = [2, 1, -1, 3, -1]`

Explanation:

* For `4`, nearest smaller on right is `2`.
* For `2`, nearest smaller on right is `1`.
* For `1`, no smaller on right → `-1`.
* For `5`, nearest smaller on right is `3`.
* For `3`, no smaller → `-1`.

---

## Approach

1. Traverse the array **from right to left**.
2. Maintain a **stack** to keep potential candidates for the "next smaller element".
3. For each element `arr[i]`:

   * Pop from the stack until we find a smaller element than `arr[i]`.
   * If stack becomes empty → no smaller → `-1`.
   * Else → the top of the stack is the next smaller.
   * Push the current element into stack.
4. Store answers in a result array and finally replace `arr`.

---

## Pattern

**Stack Pattern – Nearest Smaller Element**

* Hint: *"Whenever we want to find the nearest smaller/greater element (left or right), we use a stack to keep track of candidates."*
* Why Stack?

  * The stack efficiently maintains a list of "useful elements" (monotonic property).
  * While processing each element, the stack keeps the **latest elements on the right** in sorted order, so we can find the nearest smaller in `O(1)` after popping useless elements.
  * This avoids nested loops and brings solution from `O(n²)` → `O(n)`.

---

## Time & Space Complexity

* **Time Complexity:** `O(n)` (each element is pushed and popped at most once).
* **Space Complexity:** `O(n)` (stack + output array).

---

## Dry Run

**Input:** `arr = [4, 2, 1, 5, 3]`

Start from right →

* i = 4 → arr\[4] = 3

  * Stack empty → result\[4] = -1
  * Push(3) → Stack = \[3]

* i = 3 → arr\[3] = 5

  * Top(3) < 5 → result\[3] = 3
  * Push(5) → Stack = \[3, 5]

* i = 2 → arr\[2] = 1

  * Top(5) >= 1 → pop(5)
  * Top(3) >= 1 → pop(3)
  * Stack empty → result\[2] = -1
  * Push(1) → Stack = \[1]

* i = 1 → arr\[1] = 2

  * Top(1) < 2 → result\[1] = 1
  * Push(2) → Stack = \[1, 2]

* i = 0 → arr\[0] = 4

  * Top(2) < 4 → result\[0] = 2
  * Push(4) → Stack = \[1, 2, 4]

Final result: `[2, 1, -1, 3, -1]`

---

## Correct C++ Code

```cpp
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

class Solution {
public:
    void immediateSmaller(vector<int>& arr) {
        int n = arr.size();
        vector<int> result(n, -1);  // initialize with -1
        stack<int> st;

        // Traverse from right to left
        for (int i = n - 1; i >= 0; i--) {
            // Pop elements >= current
            while (!st.empty() && st.top() >= arr[i]) {
                st.pop();
            }

            // If stack not empty → top is next smaller
            if (!st.empty()) {
                result[i] = st.top();
            }

            // Push current element
            st.push(arr[i]);
        }

        // Replace arr with result
        arr = result;
    }
};

int main() {
    Solution sol;
    vector<int> arr = {4, 2, 1, 5, 3};
    sol.immediateSmaller(arr);

    for (int x : arr) cout << x << " ";
    // Output: 2 1 -1 3 -1
    return 0;
}
```

---
