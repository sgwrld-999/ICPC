## Question

**Previous Smaller Element (SmallestonLeft)**

Given an array `arr[]` of size `n`, for every element `arr[i]`, find the nearest smaller element on its **left** side. If no such element exists, return `-1`.

**Example:**

* Input: `arr = [1, 6, 4, 10, 2, 5]`
* Output: `[-1, 1, 1, 4, 1, 2]`

Explanation:

* For `1` → no element on left → `-1`.
* For `6` → nearest smaller on left is `1`.
* For `4` → nearest smaller on left is `1`.
* For `10` → nearest smaller on left is `4`.
* For `2` → nearest smaller on left is `1`.
* For `5` → nearest smaller on left is `2`.

---

## Approach

1. Traverse array from **left to right**.
2. Maintain a stack that stores useful elements in **monotonic increasing order**.
3. For each `arr[i]`:

   * Pop elements from stack until a smaller element is found or stack becomes empty.
   * If stack empty → no smaller on left → `-1`.
   * Else → top of stack is the nearest smaller.
   * Push `arr[i]` into stack for future elements.
4. Store results in output array.

---

## Pattern

**Stack Pattern – Nearest Smaller to Left (NSL)**

* Hint: *"Whenever we want the nearest smaller/greater element in one direction, we use a monotonic stack to store candidates."*
* Why stack?

  * The stack helps to quickly discard elements that cannot be answers.
  * For each element, the **last useful smaller element on the left** will always be at the top of the stack.
  * Ensures each element is pushed and popped at most once → efficient `O(n)`.

---

## Time & Space Complexity

* **Time Complexity:** `O(n)` (each element pushed/popped at most once).
* **Space Complexity:** `O(n)` (stack + output array).

---

## Dry Run

**Input:** `arr = [1, 6, 4, 10, 2, 5]`

* i=0 → arr\[0]=1
  stack empty → result\[0]=-1 → push(1) → st=\[1]

* i=1 → arr\[1]=6
  top(1)<6 → result\[1]=1 → push(6) → st=\[1,6]

* i=2 → arr\[2]=4
  top(6)>=4 → pop(6) → top(1)<4 → result\[2]=1 → push(4) → st=\[1,4]

* i=3 → arr\[3]=10
  top(4)<10 → result\[3]=4 → push(10) → st=\[1,4,10]

* i=4 → arr\[4]=2
  top(10)>=2 → pop(10)
  top(4)>=2 → pop(4)
  top(1)<2 → result\[4]=1 → push(2) → st=\[1,2]

* i=5 → arr\[5]=5
  top(2)<5 → result\[5]=2 → push(5) → st=\[1,2,5]

Final result: `[-1, 1, 1, 4, 1, 2]`

---

## Correct C++ Code

```cpp
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

class Solution {
public:
    vector<int> Smallestonleft(int arr[], int n) {
        vector<int> pse(n);
        stack<int> st;

        for (int i = 0; i < n; i++) {
            // Pop until we find a smaller element
            while (!st.empty() && st.top() >= arr[i]) {
                st.pop();
            }

            // If stack empty → no smaller element on left
            if (st.empty())
                pse[i] = -1;
            else
                pse[i] = st.top();

            // Push current element into stack
            st.push(arr[i]);
        }

        return pse;
    }
};

int main() {
    Solution sol;
    int arr[] = {1, 6, 4, 10, 2, 5};
    int n = sizeof(arr) / sizeof(arr[0]);

    vector<int> result = sol.Smallestonleft(arr, n);

    for (int x : result) cout << x << " ";
    // Output: -1 1 1 4 1 2
    return 0;
}
```

---

