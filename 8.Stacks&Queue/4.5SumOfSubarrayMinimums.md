# Problem: Sum of Subarray Minimums

### Question

Given an array of integers, return the sum of the minimum element of every subarray. Since the answer may be very large, return it modulo 1e9+7.

---

### Approach

1. **Observation**:
   Each element in the array can be the **minimum** of multiple subarrays.
   Instead of generating all subarrays, calculate the **contribution** of each element directly.

2. **Contribution Logic**:

   * For each element `arr[i]`, find:

     * `PSE[i]` → index of **previous smaller or equal element** on the left.
     * `NSE[i]` → index of **next smaller element** on the right.
   * Then:

     * `leftCount = i - PSE[i]` → number of choices for left boundary.
     * `rightCount = NSE[i] - i` → number of choices for right boundary.
   * Total subarrays where `arr[i]` is minimum = `leftCount * rightCount`.
   * Contribution of `arr[i]` = `arr[i] * leftCount * rightCount`.

3. **Use Monotonic Stack**:

   * To compute `PSE` and `NSE` efficiently in **O(n)**.
   * Maintain **increasing stack** to find nearest smaller elements.

---

### Pattern

**Stack Pattern Hint:**
Whenever we need to find **previous/next smaller (or greater) elements** efficiently for each index, we use a **monotonic stack**.

* Here, stack ensures that we know the nearest smaller boundary for each element.
* This avoids brute-force scanning left/right for every index.

---

### Time Complexity & Space Complexity

* **Time Complexity**: `O(n)`

  * Each element is pushed and popped at most once from the stack.
* **Space Complexity**: `O(n)`

  * For storing `PSE`, `NSE`, and stack.

---

### Dry Run

**Example:** `arr = [3, 1, 2, 4]`

1. Compute `PSE`:

   * For 3 → no smaller left → `-1`
   * For 1 → no smaller left → `-1`
   * For 2 → smaller left = 1 → `1`
   * For 4 → smaller left = 2 → `2`
     ⇒ `PSE = [-1, -1, 1, 2]`

2. Compute `NSE`:

   * For 4 → no smaller right → `4`
   * For 2 → next smaller is 4 → `3`
   * For 1 → next smaller is none → `4`
   * For 3 → next smaller is 1 → `1`
     ⇒ `NSE = [1, 4, 3, 4]`

3. Contribution of each:

   * `arr[0] = 3`, leftCount = `0 - (-1) = 1`, rightCount = `1 - 0 = 1` → contribution = `3*1*1 = 3`
   * `arr[1] = 1`, leftCount = `1 - (-1) = 2`, rightCount = `4 - 1 = 3` → contribution = `1*2*3 = 6`
   * `arr[2] = 2`, leftCount = `2 - 1 = 1`, rightCount = `3 - 2 = 1` → contribution = `2*1*1 = 2`
   * `arr[3] = 4`, leftCount = `3 - 2 = 1`, rightCount = `4 - 3 = 1` → contribution = `4*1*1 = 4`
   * Total = `3 + 6 + 2 + 4 = 15`

Answer = `15`.

---

### Code (C++)

```cpp
#define ll long long
class Solution {
public:
    // Find Next Smaller Element (NSE) index for each element
    vector<int> findNSE(vector<int>& nums, int n) {
        vector<int> nse(n);
        stack<int> st;
        for(int i = n - 1; i >= 0; i--) {
            while(!st.empty() && nums[st.top()] >= nums[i]) {
                st.pop();
            }
            if(st.empty()) nse[i] = n;     // no smaller to right
            else nse[i] = st.top();
            st.push(i);
        }
        return nse;
    }

    // Find Previous Smaller Element (PSE) index for each element
    vector<int> findPSE(vector<int>& nums, int n) {
        vector<int> pse(n);
        stack<int> st;
        for(int i = 0; i < n; i++) {
            while(!st.empty() && nums[st.top()] > nums[i]) {
                st.pop();
            }
            if(st.empty()) pse[i] = -1;    // no smaller to left
            else pse[i] = st.top();
            st.push(i);
        }
        return pse;
    }

    int sumSubarrayMins(vector<int>& arr) {
        int n = arr.size();
        vector<int> pse = findPSE(arr, n);
        vector<int> nse = findNSE(arr, n);

        const int MOD = 1e9 + 7;
        long long total = 0;

        for(int i = 0; i < n; i++) {
            long long leftCount = i - pse[i];   
            long long rightCount = nse[i] - i;  

            long long contribution = (arr[i] * leftCount % MOD * rightCount % MOD) % MOD;
            total = (total + contribution) % MOD;
        }

        return (int) total;
    }
};
```

---