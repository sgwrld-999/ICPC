# Intuition

The task is to design a stack that, along with the normal operations (`push`, `pop`, `top`), can also return the **minimum element** in constant time.
Normally, finding the minimum requires scanning the stack, which is $O(n)$. To optimize, we store **extra information** (the current minimum so far) along with each pushed element.

---

# Approach

* Use a stack of **pairs**: `{value, minSoFar}`.

* Why pair?

  > Whenever a problem requires us to **track both the current value and an additional property of the data structure at the same time**, a pair (or tuple) is a natural choice.

* **Push**:

  * If the stack is empty → push `{val, val}`.
  * Otherwise → compare `val` with `customSt.top().second` (previous min), and push `{val, newMin}`.

* **Pop**: simply remove the top element.

* **Top**: return `customSt.top().first`.

* **GetMin**: return `customSt.top().second`.

This ensures every operation is $O(1)$.

---

# Pattern

The pattern here is **“augmented stack”**:

* We don’t just store the value, but also an **extra property** (in this case, minimum so far).
* This technique can be generalized:

  * **MinStack / MaxStack** → store value + min/max so far
  * **Frequency stack** → store value + frequency
  * **Monotonic stack** → store value + next greater/smaller info

At any time, if we need to **carry an extra property along with the main element**, we augment the data with a pair (or more if needed).

---

# Complexity

* Time complexity:

  * `push`, `pop`, `top`, `getMin` → $O(1)$

* Space complexity:

  * Each element stores 2 integers instead of 1 → $O(n)$

---

### 
Example

```cpp
MinStack st;
st.push(5);
st.push(3);
st.push(7);
st.push(2);
st.pop();
```

---

### Dry Run Table

| Operation | Stack Content (`{value, minSoFar}`) | Top() | GetMin() |
| --------- | ----------------------------------- | ----- | -------- |
| push(5)   | `{5, 5}`                            | 5     | 5        |
| push(3)   | `{5, 5}, {3, 3}`                    | 3     | 3        |
| push(7)   | `{5, 5}, {3, 3}, {7, 3}`            | 7     | 3        |
| push(2)   | `{5, 5}, {3, 3}, {7, 3}, {2, 2}`    | 2     | 2        |
| pop()     | `{5, 5}, {3, 3}, {7, 3}`            | 7     | 3        |

---

### Explanation of each step

* **push(5)** → stack empty, so push `{5, 5}` (value = 5, minSoFar = 5).
* **push(3)** → min(3, 5) = 3, so push `{3, 3}`.
* **push(7)** → min(7, 3) = 3, so push `{7, 3}`.
* **push(2)** → min(2, 3) = 2, so push `{2, 2}`.
* **pop()** → remove `{2, 2}`, now min reverts back to 3.

---

# Code

```cpp []
class MinStack {
private:
    stack<pair<int,int>> customSt;  // {value, minSoFar}

public:
    MinStack() {}

    void push(int val) {
        if(customSt.empty()){
            customSt.push({val, val});
        }
        else{
            int currMin = min(val, customSt.top().second);
            customSt.push({val, currMin});
        }
    }
    
    void pop() {
        customSt.pop();
    }
    
    int top() {
        return customSt.top().first;
    }
    
    int getMin() {
        return customSt.top().second;
    }
};
```

---

# 1. **Array Implementation**

We’ll maintain two parallel arrays:

* `values[]` → actual stack values
* `mins[]` → minimum so far at that index

```cpp
#include <iostream>
#include <climits>
using namespace std;

class MinStackArray {
private:
    int values[1000];   // stack values
    int mins[1000];     // min so far
    int topIndex;

public:
    MinStackArray() {
        topIndex = -1;
    }

    void push(int val) {
        if(topIndex == 999) {
            cout << "Stack overflow\n";
            return;
        }
        topIndex++;
        values[topIndex] = val;

        if(topIndex == 0) 
            mins[topIndex] = val;
        else 
            mins[topIndex] = min(val, mins[topIndex - 1]);
    }

    void pop() {
        if(topIndex == -1) {
            cout << "Stack underflow\n";
            return;
        }
        topIndex--;
    }

    int top() {
        if(topIndex == -1) {
            cout << "Stack empty\n";
            return INT_MIN;
        }
        return values[topIndex];
    }

    int getMin() {
        if(topIndex == -1) {
            cout << "Stack empty\n";
            return INT_MIN;
        }
        return mins[topIndex];
    }
};
```

---

# 2. **Linked List Implementation**

Each node stores:

* `value`
* `minSoFar`
* `next` pointer

```cpp
#include <iostream>
#include <climits>
using namespace std;

class MinStackLinkedList {
private:
    struct Node {
        int value;
        int minSoFar;
        Node* next;
        Node(int v, int m, Node* nxt) : value(v), minSoFar(m), next(nxt) {}
    };
    Node* head;

public:
    MinStackLinkedList() {
        head = nullptr;
    }

    void push(int val) {
        if(head == nullptr) {
            head = new Node(val, val, nullptr);
        } else {
            int currMin = min(val, head->minSoFar);
            head = new Node(val, currMin, head);
        }
    }

    void pop() {
        if(head == nullptr) {
            cout << "Stack underflow\n";
            return;
        }
        Node* temp = head;
        head = head->next;
        delete temp;
    }

    int top() {
        if(head == nullptr) {
            cout << "Stack empty\n";
            return INT_MIN;
        }
        return head->value;
    }

    int getMin() {
        if(head == nullptr) {
            cout << "Stack empty\n";
            return INT_MIN;
        }
        return head->minSoFar;
    }
};
```


