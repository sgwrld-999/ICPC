## Question

**Valid Parentheses Problem**
Given a string `s` consisting of characters `'(', ')', '{', '}', '[' and ']'`, determine if the input string is valid.

A string is valid if:

1. Open brackets are closed by the same type of brackets.
2. Open brackets are closed in the correct order.
3. Every closing bracket has a corresponding opening bracket.

**Example:**

* Input: `"()[]{}"` → Output: `true`
* Input: `"(]"` → Output: `false`
* Input: `"([{}])"` → Output: `true`

---

## Approach

1. Traverse each character in the string.
2. If it's an opening bracket → push onto stack.
3. If it's a closing bracket →

   * If the stack is empty → invalid.
   * If the top of the stack does not match the correct opening → invalid.
   * Otherwise, pop the stack.
4. After traversal, if the stack is empty → valid, else invalid.

---

## Pattern

**Stack Pattern – Balanced Parentheses**

* Hint: *"Whenever we want the last input to be accessed first (i.e., keep track of most recent opening bracket), we use a stack data structure."*
* Explanation:

  * Stack helps match the **latest unmatched opening bracket** with the current closing bracket.
  * This is a **last-in-first-out requirement**, perfectly modeled by a stack.
  * If at the end the stack is empty → all brackets are matched.

---

## Time & Space Complexity

* **Time Complexity:** `O(n)` (we scan the string once, each element pushed/popped at most once).
* **Space Complexity:** `O(n)` (in worst case, all opening brackets pushed to stack).

---

## Dry Run

**Input:** `s = "([{}])"`

* Step 1: `(` → opening → push → stack: `(`
* Step 2: `[` → opening → push → stack: `(`, `[`
* Step 3: `{` → opening → push → stack: `(`, `[`, `{`
* Step 4: `}` → closing → matches `{` → pop → stack: `(`, `[`
* Step 5: `]` → closing → matches `[` → pop → stack: `(`
* Step 6: `)` → closing → matches `(` → pop → stack: empty

Stack empty → **Valid**.

---

## Corrected C++ Code (with Edge Cases)

```cpp
#include <iostream>
#include <stack>
#include <string>
using namespace std;

class Solution {
public:
    bool isValid(string s) {
        stack<char> st;

        for (char it : s) {
            // Push opening brackets
            if (it == '(' || it == '{' || it == '[') {
                st.push(it);
            }
            else {
                // If closing bracket but stack is empty
                if (st.empty()) return false;

                // Match top of stack with closing
                if ((st.top() == '(' && it == ')') ||
                    (st.top() == '{' && it == '}') ||
                    (st.top() == '[' && it == ']')) {
                    st.pop();
                }
                else {
                    // Mismatched bracket
                    return false;
                }
            }
        }

        // At the end, stack should be empty
        return st.empty();
    }
};

int main() {
    Solution sol;
    cout << sol.isValid("()[]{}") << endl;   // Output: 1 (true)
    cout << sol.isValid("(]") << endl;       // Output: 0 (false)
    cout << sol.isValid("([{}])") << endl;   // Output: 1 (true)
    cout << sol.isValid("(((") << endl;      // Output: 0 (false)
    return 0;
}
```

