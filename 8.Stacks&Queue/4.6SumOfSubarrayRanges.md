## Question

Given an integer array `nums`, the **range** of a subarray is the difference between the maximum and minimum elements in it.
Return the **sum of all subarray ranges** in `nums`.

**Example**:
Input: `nums = [1,2,3]`
Output: `4`
Explanation:

* Subarrays: \[1], \[2], \[3], \[1,2], \[2,3], \[1,2,3]
* Ranges = 0 + 0 + 0 + (2-1) + (3-2) + (3-1) = 4

---

## Approach

1. A brute force way is to generate all subarrays and compute max - min → O(n³) or O(n²). Too slow.
2. Optimized way:

   * Think in terms of **contribution** of each element.
   * Each element `arr[i]` contributes to subarrays where it is either the **minimum** or the **maximum**.
   * Use **monotonic stacks** to find:

     * **PSE (Previous Smaller Element)** and **NSE (Next Smaller Element)** → counts subarrays where `arr[i]` is the minimum.
     * **PGE (Previous Greater Element)** and **NGE (Next Greater Element)** → counts subarrays where `arr[i]` is the maximum.
   * Multiply by left span and right span to calculate contribution.
3. Final answer = `sum(contribution as max) - sum(contribution as min)`.

---

## Pattern

**Special Pattern:**

* *Whenever we want to know how far an element can extend in subarrays while remaining the minimum or maximum, we use monotonic stacks.*
* The stack ensures we quickly find the **nearest smaller/greater elements on both sides**.
* The contribution method avoids redundant recalculation for each subarray.

---

## Time & Space Complexity

* **Time Complexity**: O(n)

  * Each element is pushed and popped at most once in the stacks.
* **Space Complexity**: O(n)

  * Extra space for PSE, NSE, PGE, NGE arrays + stacks.

---

## Dry Run

Input: `nums = [1, 2, 3]`

* For **min contribution**:

  * `1`: PSE = -1, NSE = n=3 → left=1-(-1)=1, right=3-0=3 → contributes 1*1*3=3
  * `2`: PSE=0, NSE=3 → left=1, right=1 → contributes 2*1*1=2
  * `3`: PSE=1, NSE=3 → left=1, right=1 → contributes 3*1*1=3
  * Total Min Contribution = 8

* For **max contribution**:

  * `1`: PGE=-1, NGE=1 → left=1, right=1 → contributes 1*1*1=1
  * `2`: PGE=0, NGE=2 → left=1, right=1 → contributes 2*1*1=2
  * `3`: PGE=1, NGE=n=3 → left=1, right=1 → contributes 3*1*1=3
  * Total Max Contribution = 6

* Final Answer = 6 - 8 = -2 (wait, check carefully).

Correction:
Actually, need to recompute carefully:

For Max:

* `1`: left=1-(-1)=1, right=1-0=1 → 1*1*1=1
* `2`: left=2-(-1)=2, right=2-1=1 → 2*2*1=4
* `3`: left=3-(-1)=3, right=3-2=1 → 3*3*1=9
  Total Max=14

For Min:

* `1`: left=0-(-1)=1, right=3-0=3 → 1*1*3=3
* `2`: left=1-0=1, right=3-1=2 → 2*1*2=4
* `3`: left=2-1=1, right=3-2=1 → 3*1*1=3
  Total Min=10

Final = 14 - 10 = 4 ✅

---

## Code

```cpp
#define ll long long
class Solution {
public:
    // Next Greater Element (NGE)
    vector<int> findNGE(vector<int>& nums, int n) {
        vector<int> nge(n);
        stack<int> st;
        for (int i = n - 1; i >= 0; i--) {
            while (!st.empty() && nums[st.top()] <= nums[i]) st.pop();
            nge[i] = st.empty() ? n : st.top();
            st.push(i);
        }
        return nge;
    }

    // Previous Greater Element (PGE)
    vector<int> findPGE(vector<int>& nums, int n) {
        vector<int> pge(n);
        stack<int> st;
        for (int i = 0; i < n; i++) {
            while (!st.empty() && nums[st.top()] < nums[i]) st.pop();
            pge[i] = st.empty() ? -1 : st.top();
            st.push(i);
        }
        return pge;
    }

    // Next Smaller Element (NSE)
    vector<int> findNSE(vector<int>& nums, int n) {
        vector<int> nse(n);
        stack<int> st;
        for (int i = n - 1; i >= 0; i--) {
            while (!st.empty() && nums[st.top()] >= nums[i]) st.pop();
            nse[i] = st.empty() ? n : st.top();
            st.push(i);
        }
        return nse;
    }

    // Previous Smaller Element (PSE)
    vector<int> findPSE(vector<int>& nums, int n) {
        vector<int> pse(n);
        stack<int> st;
        for (int i = 0; i < n; i++) {
            while (!st.empty() && nums[st.top()] > nums[i]) st.pop();
            pse[i] = st.empty() ? -1 : st.top();
            st.push(i);
        }
        return pse;
    }

    long long subarrayMins(vector<int>& arr) {
        int n = arr.size();
        vector<int> pse = findPSE(arr, n);
        vector<int> nse = findNSE(arr, n);

        ll total = 0;
        for (int i = 0; i < n; i++) {
            ll left = i - pse[i];
            ll right = nse[i] - i;
            total += 1LL * arr[i] * left * right;
        }
        return total;
    }

    long long subarrayMaxs(vector<int>& arr) {
        int n = arr.size();
        vector<int> pge = findPGE(arr, n);
        vector<int> nge = findNGE(arr, n);

        ll total = 0;
        for (int i = 0; i < n; i++) {
            ll left = i - pge[i];
            ll right = nge[i] - i;
            total += 1LL * arr[i] * left * right;
        }
        return total;
    }

    long long subArrayRanges(vector<int>& nums) {
        return subarrayMaxs(nums) - subarrayMins(nums);
    }
};
```

---

