# Intuition

We need to find the **next greater element** (NGE) for every element of `nums1`, based on its position in `nums2`.
Brute force would scan right for every element → $O(n^2)$. Too slow.

Instead, we use a **monotonic decreasing stack**:

* Traverse `nums2` from right to left.
* Maintain a stack of “candidates for next greater.”
* Pop elements that are smaller or equal (they can’t be next greater).
* The top of the stack is the NGE.

---

# Approach

1. **Precompute NGE for nums2** using a stack.
2. Store each element of `nums2` → `NGE` mapping in a hashmap.
3. For each element in `nums1`, look up its NGE in the map.

---

# Dry Run

Example:

```cpp
nums1 = [4,1,2]  
nums2 = [1,3,4,2]
```

| Step | i | nums2\[i] | Stack Content | NGE\[i] | Action                            |
| ---- | - | --------- | ------------- | ------- | --------------------------------- |
| init |   |           | empty         |         | Start from right                  |
| 1    | 3 | 2         | empty         | -1      | Stack empty → push 2              |
| 2    | 2 | 4         | {2}           | -1      | Pop 2 (<=4), stack empty → push 4 |
| 3    | 1 | 3         | {4}           | 4       | Top = 4 (>3), push 3              |
| 4    | 0 | 1         | {4,3}         | 3       | Top = 3 (>1), push 1              |

So `NGE for nums2 = [-1, 4, -1, -1]`.

Mapping:

* `1 → 3`
* `3 → 4`
* `4 → -1`
* `2 → -1`

Now for `nums1`:

* 4 → -1
* 1 → 3
* 2 → -1

Final answer = `[-1, 3, -1]`.

---

# Pattern

This is the **Monotonic Stack pattern**:

* Used when we want **next greater/smaller element** in an array.
* General rule:

  * Traverse from right → maintain a **decreasing stack** for next greater.
  * Traverse from right → maintain an **increasing stack** for next smaller.
* This avoids re-scanning → reduces $O(n^2)$ to $O(n)$.

---

# Complexity

* Time complexity: $O(n + m)$

  * $O(n)$ to compute NGEs for `nums2`
  * $O(m)$ to answer queries for `nums1`
* Space complexity: $O(n)$ for stack + hashmap

---

# Code

```cpp []
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Step 1: Precompute next greater element for nums2
    vector<int> monotonicSt(vector<int>& nums2) {
        int n = nums2.size();
        stack<int> st;
        vector<int> nge(n);

        for(int i = n - 1; i >= 0; i--) {
            // Pop all smaller or equal elements
            while(!st.empty() && st.top() <= nums2[i]) {
                st.pop();
            }

            // If stack is empty, no greater element
            if(st.empty()) nge[i] = -1;
            else nge[i] = st.top();

            // Push current element
            st.push(nums2[i]);
        }
        return nge;
    }

    // Step 2: Answer queries for nums1 based on nums2 results
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        vector<int> nge = monotonicSt(nums2);
        unordered_map<int,int> mp;

        // Map each number in nums2 to its next greater
        for(int i = 0; i < nums2.size(); i++) {
            mp[nums2[i]] = nge[i];
        }

        // Build result for nums1 using the map
        vector<int> result;
        for(int num : nums1) {
            result.push_back(mp[num]);
        }
        return result;
    }
};
```

---

