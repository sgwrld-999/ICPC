# ðŸ“˜ Stack and Queue â€“ Theory + Implementation + Problem Patterns

---

## ðŸ”¹ **Stack**

### 1. What is Stack?

* A **linear data structure** that follows **LIFO (Last In First Out)** order.
* Example: A stack of plates â€“ the last plate placed is the first one removed.

---

### 2. Principle of Stack

* **LIFO principle**: Last element inserted is the first to be removed.

---

### 3. Basic Functionalities of Stack

* **push(x)** â†’ insert an element at the top.
* **pop()** â†’ remove the top element.
* **peek()/top()** â†’ see the top element without removing it.
* **isEmpty()** â†’ check if stack is empty.
* **isFull()** (in array-based implementation).

---

### 4. Implementation of Stack

#### (a) **Using Array**

**Pseudocode:**

```
Initialize stack[SIZE], top = -1

function push(x):
    if top == SIZE-1:
        print "Overflow"
    else:
        top = top + 1
        stack[top] = x

function pop():
    if top == -1:
        print "Underflow"
    else:
        top = top - 1

function peek():
    if top == -1:
        print "Empty stack"
    else:
        return stack[top]
```

**C++ Code:**

```cpp
#include <iostream>
using namespace std;

#define SIZE 100

class Stack {
    int arr[SIZE];
    int top;

public:
    Stack() { top = -1; }

    void push(int x) {
        if (top == SIZE - 1) {
            cout << "Stack Overflow\n";
            return;
        }
        arr[++top] = x;
    }

    void pop() {
        if (top == -1) {
            cout << "Stack Underflow\n";
            return;
        }
        top--;
    }

    int peek() {
        if (top == -1) {
            cout << "Stack is Empty\n";
            return -1;
        }
        return arr[top];
    }

    bool isEmpty() { return top == -1; }
};
```

---

#### (b) **Using Linked List**

**Pseudocode:**

```
struct Node {
    data, next
}

top = NULL

function push(x):
    create newNode
    newNode.data = x
    newNode.next = top
    top = newNode

function pop():
    if top == NULL:
        print "Underflow"
    else:
        temp = top
        top = top.next
        delete temp
```

**C++ Code:**

```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

class Stack {
    Node* top;
public:
    Stack() { top = NULL; }

    void push(int x) {
        Node* temp = new Node();
        temp->data = x;
        temp->next = top;
        top = temp;
    }

    void pop() {
        if (top == NULL) {
            cout << "Stack Underflow\n";
            return;
        }
        Node* temp = top;
        top = top->next;
        delete temp;
    }

    int peek() {
        if (top == NULL) {
            cout << "Stack is Empty\n";
            return -1;
        }
        return top->data;
    }

    bool isEmpty() { return top == NULL; }
};
```

---

## ðŸ”¹ **Queue**

### 1. What is Queue?

* A **linear data structure** that follows **FIFO (First In First Out)** order.
* Example: People standing in a line â€“ first person in line is served first.

---

### 2. Principle of Queue

* **FIFO principle**: First element inserted is the first one removed.

---

### 3. Basic Functionalities of Queue

* **enqueue(x)** â†’ insert an element at the rear.
* **dequeue()** â†’ remove an element from the front.
* **front()** â†’ access the first element.
* **rear()** â†’ access the last element.
* **isEmpty()** â†’ check if queue is empty.
* **isFull()** (for array-based).

---

### 4. Implementation of Queue

#### (a) **Using Array (Simple Queue)**

**Pseudocode:**

```
Initialize queue[SIZE], front = -1, rear = -1

function enqueue(x):
    if rear == SIZE-1:
        print "Overflow"
    else:
        if front == -1: front = 0
        rear = rear + 1
        queue[rear] = x

function dequeue():
    if front == -1 or front > rear:
        print "Underflow"
    else:
        front = front + 1
```

**C++ Code:**

```cpp
#include <iostream>
using namespace std;

#define SIZE 100

class Queue {
    int arr[SIZE];
    int front, rear;

public:
    Queue() { front = -1; rear = -1; }

    void enqueue(int x) {
        if (rear == SIZE - 1) {
            cout << "Queue Overflow\n";
            return;
        }
        if (front == -1) front = 0;
        arr[++rear] = x;
    }

    void dequeue() {
        if (front == -1 || front > rear) {
            cout << "Queue Underflow\n";
            return;
        }
        front++;
    }

    int getFront() {
        if (front == -1 || front > rear) {
            cout << "Queue Empty\n";
            return -1;
        }
        return arr[front];
    }
};
```

---

#### (b) **Using Linked List**

**Pseudocode:**

```
struct Node { data, next }

front = NULL, rear = NULL

function enqueue(x):
    newNode = create node
    newNode.data = x
    newNode.next = NULL
    if rear == NULL:
        front = rear = newNode
    else:
        rear.next = newNode
        rear = newNode

function dequeue():
    if front == NULL:
        print "Underflow"
    else:
        temp = front
        front = front.next
        if front == NULL:
            rear = NULL
        delete temp
```

**C++ Code:**

```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

class Queue {
    Node* front;
    Node* rear;
public:
    Queue() { front = rear = NULL; }

    void enqueue(int x) {
        Node* temp = new Node();
        temp->data = x;
        temp->next = NULL;
        if (rear == NULL) {
            front = rear = temp;
            return;
        }
        rear->next = temp;
        rear = temp;
    }

    void dequeue() {
        if (front == NULL) {
            cout << "Queue Underflow\n";
            return;
        }
        Node* temp = front;
        front = front->next;
        if (front == NULL) rear = NULL;
        delete temp;
    }

    int getFront() {
        if (front == NULL) {
            cout << "Queue Empty\n";
            return -1;
        }
        return front->data;
    }
};
```

---

## ðŸ”¹ **Question Patterns with Stacks and Queues**

### ðŸ“Œ **Stack-based Questions**

1. **Balanced Parentheses / Valid Brackets**
   Example: `"({[]})"` âœ…
2. **Next Greater Element**
3. **Stock Span Problem**
4. **Largest Rectangle in Histogram**
5. **Evaluate Postfix/Prefix Expressions**
6. **Infix to Postfix Conversion**
7. **Min Stack (O(1) min retrieval)**
8. **Celebrity Problem** (Matrix based, stack optimization).

---

### ðŸ“Œ **Queue-based Questions**

1. **Implement Stack using Queue**
2. **Implement Queue using Stack**
3. **Circular Queue Implementation**
4. **LRU Cache** (Queue + HashMap).
5. **Sliding Window Maximum (Monotonic Queue)**
6. **Rotten Oranges Problem (BFS with Queue)**
7. **Level Order Traversal of Tree (BFS)**
8. **First Non-Repeating Character in a Stream**

---

### ðŸ“Œ **Competitive Programming Patterns**

* **Monotonic Stack/Queue problems** â†’ Sliding window, histogram, next greater.
* **Two-stack tricks** â†’ Implement queue with two stacks.
* **Deque problems** â†’ Max/Min in sliding window.
* **Multi-source BFS using Queue** â†’ Shortest path in grids, rotten oranges.
* **Greedy + Stack** â†’ Removing k digits, canonical sequence problems.

---
