# Asteroid Collision (Stack)

### Problem Statement

We are given an array of integers `asteroids`:

* **Positive value** → asteroid moving right
* **Negative value** → asteroid moving left

Collision rules:

* If two asteroids meet:

  * The **smaller one explodes**.
  * If both have equal size → both explode.
* Asteroids moving in the same direction never collide.
* Return the state of asteroids after all collisions.

---

### Intuition

* Use a **stack** to simulate asteroid movement.
* Push **right-moving** asteroids directly.
* For a **left-moving** asteroid, check top of stack for possible collision (only if top is right-moving).
* Handle cases: destroyed, survives, or both destroyed.

---

### Approach

1. Initialize an empty stack.
2. Traverse each asteroid:

   * If `> 0` → push onto stack.
   * If `< 0` → handle collisions:

     * While top of stack is **smaller right-moving asteroid**, pop it.
     * If top of stack is equal (same size), pop both.
     * If stack is empty or top is negative, push current asteroid (it survives).
3. Convert stack into result vector (reverse order).

---

### Dry Run Example

Input: `asteroids = [5, 10, -5]`

* Start with empty stack.
* `5` → push → `[5]`
* `10` → push → `[5, 10]`
* `-5` comes:

  * Compare with top `10`: since `10 > 5`, `-5` destroyed.
* Final stack = `[5, 10]`

Output = `[5, 10]` ✅

---

### Complexity

* **Time:** O(n) → Each asteroid pushed/popped at most once.
* **Space:** O(n) → Stack stores surviving asteroids.

---

### Code

```cpp
class Solution {
public:
    vector<int> asteroidCollision(vector<int>& asteroids) {
        stack<int> st;

        for (int i = 0; i < asteroids.size(); i++) {
            // If asteroid is moving right
            if (asteroids[i] > 0) {
                st.push(asteroids[i]);
            } else {
                // Handle collisions
                while (!st.empty() && st.top() > 0 && st.top() < abs(asteroids[i])) {
                    st.pop(); // smaller right-moving asteroid destroyed
                }

                if (!st.empty() && st.top() == abs(asteroids[i])) {
                    st.pop(); // both destroyed
                }
                else if (st.empty() || st.top() < 0) {
                    st.push(asteroids[i]); // left-moving asteroid survives
                }
            }
        }

        // Convert stack -> vector (in correct order)
        vector<int> result(st.size());
        for (int i = st.size() - 1; i >= 0; i--) {
            result[i] = st.top();
            st.pop();
        }
        return result;
    }
};
```
---