# Intuition

We need to find the next greater element (NGE) for each element in a **circular array**.

* If we reach the end of the array, we wrap around and keep checking.
* Brute force would be $O(n^2)$ because for each element we might scan almost the entire array again.

A smarter way:

* Think of the array as **duplicated twice** (`2n` length).
* Traverse from right to left, using a **monotonic decreasing stack**.
* Use modulo `i % n` to map indices back into the original array.

---

# Approach

1. Double the traversal length (`2 * n`) to simulate the circular behavior.
2. Traverse from right to left (`i = 2n → 0`).

   * While stack top is ≤ current element, pop it.
   * If stack is non-empty, its top is the NGE.
3. Only assign answers for the first `n` elements (ignore the duplicated half).
4. Return the result array.

---

# Dry Run

Example:

```cpp
nums = [1, 2, 1]
n = 3, N = 6
```

| Step | i | nums\[i % n] | Stack (top→bottom) | nge\[i % n] | Action                         |
| ---- | - | ------------ | ------------------ | ----------- | ------------------------------ |
| 6    | - | -            | empty              | -           | start                          |
| 5    | 2 | 1            | empty              | -           | push 1                         |
| 4    | 1 | 2            | {1}                | -           | pop 1, push 2                  |
| 3    | 0 | 1            | {2}                | 2           | push 1                         |
| 2    | 2 | 1            | {1,2}              | 2           | push 1                         |
| 1    | 1 | 2            | {2,1,2}            | -1          | pop 1, pop 2, stack empty → -1 |
| 0    | 0 | 1            | {1}                | 2           | push 1                         |

Final result:
`[2, -1, 2]`

---

# Pattern

This problem is a **variation of Monotonic Stack** with a circular twist:

* Normally, NGE is solved with one traversal.
* For circular arrays, we **extend traversal to 2n**.
* Modulo indexing (`i % n`) brings us back to simulate wrapping around.

General rule:

* Use **monotonic decreasing stack** for Next Greater.
* Use **2n traversal with modulo** for circular arrays.

---

# Complexity

* Time complexity: $O(2n) = O(n)$

  * Each element is pushed/popped at most once.
* Space complexity: $O(n)$ for the stack + result.

---

# Code

```cpp []
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        stack<int> st;
        int n = nums.size();
        int N = 2 * n;
        vector<int> nge(n);

        for(int i = N - 1; i >= 0; i--) {
            int curr = nums[i % n];

            while(!st.empty() && st.top() <= curr) {
                st.pop();
            }

            if(i < n) {
                nge[i] = st.empty() ? -1 : st.top();
            }

            st.push(curr);
        }
        return nge;
    }
};
```

---

