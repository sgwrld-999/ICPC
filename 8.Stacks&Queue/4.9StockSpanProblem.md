# Stack Problem Notes

---

## Question

**Stock Span Problem**

Given an array `arr[]` of size `n` where `arr[i]` represents the price of a stock on day `i`, calculate the **stock span** for each day.

The **stock span** of a day is defined as the maximum number of consecutive days (including the current day) just before that day, for which the stock price is less than or equal to its price on the current day.

**Example:**

* Input: `arr = [100, 80, 60, 70, 60, 75, 85]`
* Output: `[1, 1, 1, 2, 1, 4, 6]`

Explanation:

* Day 0 (100): span=1 (itself).
* Day 1 (80): span=1.
* Day 2 (60): span=1.
* Day 3 (70): last greater is day 1 (80), span=3−1=2.
* Day 4 (60): span=1.
* Day 5 (75): last greater is day 1 (80), span=5−1=4.
* Day 6 (85): last greater is −1, span=6−(−1)=6.

---

## Approach

1. Traverse the array from left to right.
2. Maintain a **stack of indices** where prices are stored in **monotonic decreasing order**.
3. For each day `i`:

   * Pop elements from stack while price at stack top ≤ current price.
   * If stack empty → no previous greater → set `pse[i] = -1`.
   * Else → top of stack is index of previous greater → set `pse[i] = st.top()`.
   * Push current index into stack.
4. Span = `i - pse[i]`.

---

## Pattern

**Stack Pattern – Previous Greater Element (PGE)**

* Hint: *"Whenever we want to find how far back a greater element exists on the left, we use a stack."*
* Why stack?

  * The stock span depends on **nearest greater to left**.
  * Using a monotonic decreasing stack of indices, we can efficiently jump over irrelevant days.
  * This avoids O(n²) brute force and makes it O(n).

---

## Time & Space Complexity

* **Time Complexity:** O(n) (each index pushed/popped at most once).
* **Space Complexity:** O(n) (stack + result array).

---

## Dry Run

**Input:** `arr = [100, 80, 60, 70, 60, 75, 85]`

* i=0 (100): stack empty → pse\[0]=-1, span=0−(−1)=1 → push(0) → st=\[0]
* i=1 (80): top(100)>80 → pse\[1]=0, span=1−0=1 → push(1) → st=\[0,1]
* i=2 (60): top(80)>60 → pse\[2]=1, span=1 → push(2) → st=\[0,1,2]
* i=3 (70): pop(2) since 60≤70 → top=1, arr\[1]=80>70 → pse\[3]=1 → span=3−1=2 → push(3)
* i=4 (60): top(70)>60 → pse\[4]=3 → span=4−3=1 → push(4)
* i=5 (75): pop(4:60), pop(3:70) → top=1 (80>75) → pse\[5]=1 → span=5−1=4 → push(5)
* i=6 (85): pop(5:75), pop(1:80), pop(0:100) → stack empty → pse\[6]=-1 → span=6−(−1)=7 → push(6)

Final Spans: `[1, 1, 1, 2, 1, 4, 6]`

---

## Correct C++ Code

```cpp
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

class Solution {
public:
    vector<int> calculateSpan(vector<int>& arr) {
        int n = arr.size();
        vector<int> span(n);  // result array
        stack<int> st;        // stores indices of days

        for (int i = 0; i < n; i++) {
            // Pop while current price >= price at stack top
            while (!st.empty() && arr[i] >= arr[st.top()]) {
                st.pop();
            }

            // If stack empty → no previous greater element
            if (st.empty()) {
                span[i] = i - (-1);  // i+1
            } else {
                span[i] = i - st.top();
            }

            // Push current index
            st.push(i);
        }

        return span;
    }
};

int main() {
    Solution sol;
    vector<int> arr = {100, 80, 60, 70, 60, 75, 85};
    vector<int> ans = sol.calculateSpan(arr);

    for (int x : ans) cout << x << " ";
    // Output: 1 1 1 2 1 4 6
    return 0;
}
```

---
