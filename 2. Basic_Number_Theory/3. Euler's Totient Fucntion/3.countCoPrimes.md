## **Topic:** Counting Co-Prime Pairs 

---

### **1. Problem Restatement**
Problem link: https://www.geeksforgeeks.org/problems/count-the-coprimes/1

We need to count unordered pairs `(i, j)` where:

* $0 \le i < j < n$
* `gcd(arr[i], arr[j]) = 1`

---

### **2. Naive Approach (Brute Force)**

* Loop over **all pairs** `(i, j)` → $O(n^2)$ pairs.
* For each pair, compute `gcd` → $O(\log \text{max}(a,b))$ per pair.
* **Time complexity:** $O(n^2 \log M)$
* **Fails** for $n = 10^4$ (≈ 50 million gcd checks).

---

### **3. Key Observation**

Instead of directly checking gcd for every pair:

* Count **how many pairs have gcd = 1** without iterating pairs.
* If we could find the number of pairs having **gcd = exactly g** for all `g`,
  then the answer for `g = 1` is what we want.

---

### **4. Plan (Number Theory + Inclusion–Exclusion)**

#### Step A — Precompute Frequencies

* Count how many times each number appears → `freq[x]`.

#### Step B — Count Multiples

* For each `i`, count how many array numbers are divisible by `i`.
  Store in `multiples[i]`.

#### Step C — Count Pairs for Each GCD

* Let `dp[i]` = number of pairs with gcd **exactly** `i`.
* Formula:

  $$
  \text{dp[i]} = \binom{\text{multiples[i]}}{2} - \sum_{k = 2i, 3i, ...} \text{dp[k]}
  $$
* This uses **Inclusion–Exclusion**: subtract pairs already counted with gcd as a multiple of `i`.

#### Step D — Answer

* The result = `dp[1]`.

---

### **5. Why It Works**

* Every pair has **exactly one gcd**.
* Counting from largest to smallest divisor avoids double counting.
* Subtracting `dp[multiple]` removes pairs that belong to larger gcd values.

---

### **6. Dry Run Example**

**arr = \[4, 8, 3, 9]**

**Step A — freq:**
freq\[3] = 1, freq\[4] = 1, freq\[8] = 1, freq\[9] = 1.

**Step B — multiples:**

* multiples\[1] = 4 (all numbers)
* multiples\[2] = 2 (4, 8)
* multiples\[3] = 2 (3, 9)
* multiples\[4] = 1 (4)
* multiples\[8] = 1 (8)
* multiples\[9] = 1 (9)

**Step C — dp from largest to smallest:**

* dp\[9] = C(1, 2) = 0
* dp\[8] = C(1, 2) = 0
* dp\[4] = C(1, 2) = 0
* dp\[3] = C(2, 2) = 1, subtract dp\[6], dp\[9] → stays 1
* dp\[2] = C(2, 2) = 1, subtract dp\[4], dp\[6], dp\[8] → stays 1
* dp\[1] = C(4, 2) = 6, subtract dp\[2] (1), dp\[3] (1), dp\[4] (0), dp\[5] (0), dp\[6] (0), dp\[7] (0), dp\[8] (0), dp\[9] (0)
  → dp\[1] = 6 - 1 - 1 = **4**

**Answer:** 4 pairs.

---

### **7. Complexity**

* Multiples counting: $O(M \log M)$
* Inclusion–Exclusion: $O(M \log M)$
* $M = \max(arr)$ ≤ $10^4$
  → Runs easily in time.

---

### **8. Code**

```cpp
class Solution {
public:
    int cntCoprime(vector<int>& arr) {
        int M = *max_element(arr.begin(), arr.end());

        // Step A: frequency array
        vector<int> freq(M + 1, 0);
        for (int x : arr) freq[x]++;

        // Step B: count multiples
        vector<int> multiples(M + 1, 0);
        for (int i = 1; i <= M; ++i) {
            for (int j = i; j <= M; j += i) {
                multiples[i] += freq[j];
            }
        }

        // Step C: dp for exact gcd
        vector<long long> dp(M + 1, 0);
        for (int i = M; i >= 1; --i) {
            long long c = multiples[i];
            dp[i] = c * (c - 1) / 2; // total pairs divisible by i
            for (int k = 2 * i; k <= M; k += i) {
                dp[i] -= dp[k];
            }
        }

        // Step D: answer is gcd = 1
        return (int)dp[1];
    }
};
```

---
