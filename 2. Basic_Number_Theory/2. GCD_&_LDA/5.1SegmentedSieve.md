# Intuition

We want to find all prime numbers in a given range **\[L, R]**.
If `R` is very large, directly using a normal sieve up to `R` will consume too much memory and time.

The **segmented sieve** technique allows us to:

* First find all primes up to **√R** using a simple sieve (base primes).
* Then mark multiples of these base primes **only in the range \[L, R]**.

This works because any composite number in the range must have at least one prime factor ≤ √R.
By storing only the range \[L, R], we save memory.

---

# Thought Process

* **Why √R?**
  Any composite number `x` in \[L, R] will have a smallest prime factor `p ≤ √x ≤ √R`.
  So, we only need to sieve up to √R to get all the "base primes".

* **Why segmented?**
  Direct sieve from 2 to R wastes memory for values < L if L is large (e.g., 10^9).
  Instead, we only keep an array of size (R - L + 1).

* **How to map numbers to the small array?**
  If our range is \[L, R], number `j` maps to index `j - L`.
  Example: L = 110, marking 119 → index = 119 - 110 = 9.

* **Special cases:**
  If `L < 2`, we set `L = 2` because 0 and 1 are not primes.

---

# Approach

1. **Generate base primes up to √R** using a normal sieve:

   * Start marking from `p*p` for each prime `p`.
   * Only go up to `√R` because larger factors aren't needed.

2. **Create a boolean array for \[L, R]**:

   * Initially mark all numbers as prime.

3. **Mark non-primes in \[L, R]**:

   * For each base prime `p`, find the first multiple in \[L, R]:

     * `start = max(p*p, ceil(L/p) * p)`
   * Mark all multiples of `p` in this range as non-prime.

4. **Collect results**:

   * Numbers that remain marked as prime in \[L, R] are the final primes.

---

# Complexity

* **Time complexity:**

  * Sieve up to √R: $O(\sqrt{R} \log \log \sqrt{R})$
  * Marking multiples in \[L, R]: $O((R - L + 1) \log \log \sqrt{R})$
* **Space complexity:**

  * $O(\sqrt{R})$ for base primes.
  * $O(R - L + 1)$ for range marking.

---

# Dry Run

Example: L = 10, R = 30

1. **Generate base primes up to √30 ≈ 5:**
   → \[2, 3, 5]

2. **Initialize array for \[10, 30]:**
   Size = 21 → all marked as prime initially.

3. **Mark multiples:**

   * p = 2: start = max(4, ceil(10/2)\*2 = 10)
     Mark 10, 12, 14, ..., 30 as non-prime.
   * p = 3: start = max(9, ceil(10/3)\*3 = 12)
     Mark 12, 15, 18, ..., 30 as non-prime.
   * p = 5: start = max(25, ceil(10/5)\*5 = 10)
     Mark 10, 15, 20, 25, 30 as non-prime.

4. **Remaining primes in \[10, 30]:**
   \[11, 13, 17, 19, 23, 29]

---

# Code

cpp \[]

```cpp
#include <bits/stdc++.h>
using namespace std;
/*
 * Problem Understanding:
 * ----------------------
 * We need to find all prime numbers within a given range [L, R].
 * For large R, directly using the normal Sieve of Eratosthenes up to R is memory-inefficient.
 * Instead, we use the Segmented Sieve technique to handle large ranges efficiently.
 *
 * Mathematical Insight:
 * ---------------------
 * - Any composite number in the range [L, R] must have a prime factor ≤ √R.
 * - First, generate all base primes up to √R using a normal sieve.
 * - Then, use these base primes to mark multiples as non-prime within [L, R].
 * - This way, we only store a boolean array of size (R - L + 1) instead of R.
 * - To map a number `num` in [L, R] to this array, we use index = num - L.
 *
 * Algorithm:
 * ----------
 * 1. Generate all prime numbers up to √R using the simple sieve.
 * 2. Create a boolean array `isPrime` of size (R - L + 1), initialized as true.
 * 3. For each base prime p:
 *      - Find the first multiple of p in [L, R]:
 *          start = max(p*p, ceil(L/p) * p)
 *      - Mark all multiples of p in this range as non-prime in `isPrime`.
 * 4. The remaining true entries in `isPrime` correspond to primes in [L, R].
 * 5. Return these primes as a vector.
 *
 * Time Complexity:
 * ----------------
 * - Generating base primes up to √R: O(√R log log √R)
 * - Marking in [L, R]: O((R - L + 1) log log √R)
 *
 * Space Complexity:
 * -----------------
 * - O(√R) for base primes
 * - O(R - L + 1) for the segmented boolean array
 */

class Solution {
public:
    // Simple sieve to generate base primes up to √R
    vector<int> simpleSieve(int limit) {
        vector<bool> isPrime(limit + 1, true);
        isPrime[0] = isPrime[1] = false;

        for (int p = 2; p * p <= limit; p++) {
            if (isPrime[p]) {
                for (int j = p * p; j <= limit; j += p) {
                    isPrime[j] = false;
                }
            }
        }

        vector<int> primes;
        for (int i = 2; i <= limit; i++) {
            if (isPrime[i]) primes.push_back(i);
        }
        return primes;
    }

    // Segmented sieve for range [L, R]
    vector<int> segmentedSieve(int L, int R) {
        if (L < 2) L = 2;

        int limit = sqrt(R);
        vector<int> basePrimes = simpleSieve(limit);

        vector<bool> isPrime(R - L + 1, true);

        for (int p : basePrimes) {
            int start = max(p * p, (L + p - 1) / p * p);
            for (int j = start; j <= R; j += p) {
                isPrime[j - L] = false;
            }
        }

        vector<int> primesInRange;
        for (int i = 0; i < isPrime.size(); i++) {
            if (isPrime[i]) primesInRange.push_back(L + i);
        }
        return primesInRange;
    }
};
```

---

