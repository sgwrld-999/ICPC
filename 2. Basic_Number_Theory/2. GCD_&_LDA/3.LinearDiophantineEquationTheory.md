Alright, let’s make you rock-solid on **Linear Diophantine Equations (LDE)** — both theory and competitive programming applications.

---

## 1️⃣ Concept Breakdown (Mathematical Foundations)

**Definition:**
A **Linear Diophantine Equation** in two variables is:

$$
a x + b y = c
$$

where:

* $a, b, c$ are integers
* We seek **integer** solutions $x, y$

---

**Key Solvability Condition:**

* The equation has integer solutions **iff**

  $$
  \gcd(a, b) \mid c
  $$

  (The gcd of $a$ and $b$ divides $c$)

---

**Extended Euclidean Algorithm (EEA) role:**
EEA finds integers $x_0, y_0$ such that:

$$
a x_0 + b y_0 = \gcd(a, b)
$$

If $d = \gcd(a, b)$, then:

$$
x = x_0 \cdot \frac{c}{d}, \quad y = y_0 \cdot \frac{c}{d}
$$

is **one** particular solution.

---

**General Solution:**
If $(x_0, y_0)$ is one solution, then:

$$
x = x_0 + \frac{b}{d} \cdot t, \quad y = y_0 - \frac{a}{d} \cdot t
$$

where $t$ is any integer (parameterizing all solutions).

---

### Quick Example:

Solve:

$$
15x + 21y = 6
$$

1. $d = \gcd(15, 21) = 3$ ✅ divides 6 → solutions exist.
2. EEA: $15( -1 ) + 21( 1 ) = 6$ after scaling.
3. One solution: $x_0 = -2, y_0 = 2$
4. General:

   $$
   x = -2 + 7t,\quad y = 2 - 5t
   $$

---

## 2️⃣ Applied CP / DSA Examples

**Example 1 – Find any integer solution**

```cpp
#include <bits/stdc++.h>
using namespace std;

long long extended_gcd(long long a, long long b, long long &x, long long &y) {
    if (b == 0) {
        x = 1; y = 0;
        return a;
    }
    long long x1, y1;
    long long g = extended_gcd(b, a % b, x1, y1);
    x = y1;
    y = x1 - (a / b) * y1;
    return g;
}

bool solve_LDE(long long a, long long b, long long c, long long &x, long long &y) {
    long long g = extended_gcd(a, b, x, y);
    if (c % g != 0) return false; // no solution
    x *= c / g;
    y *= c / g;
    return true;
}

int main() {
    long long a = 15, b = 21, c = 6, x, y;
    if (solve_LDE(a, b, c, x, y))
        cout << "One solution: " << x << " " << y << "\n";
    else
        cout << "No integer solution\n";
}
```

---

**Example 2 – Find non-negative solutions**
Often in CP, you need $x \geq 0, y \geq 0$.
From the general form:

$$
x = x_0 + \frac{b}{d} t
$$

$$
y = y_0 - \frac{a}{d} t
$$

You can **bound** $t$ to ensure $x, y$ are both ≥ 0.

---

**Example 3 – Coin Problem / Frobenius Problem**

* Can you make sum $c$ using coins $a, b$?
* This is exactly $a x + b y = c$ with $x, y \geq 0$.
* If gcd condition fails → impossible.

---

## 3️⃣ Pattern Recognition for CP

* **Pattern 1:**
  If problem asks for *integer solutions*, check `gcd(a, b) | c` first.
* **Pattern 2:**
  If asking for *count of solutions in a range*,
  → Find **general solution** → Bound parameter $t$.
* **Pattern 3:**
  In modular inverse problems $a x \equiv 1 \ (\text{mod } m)$
  → Special case of LDE: $a x + m y = 1$
* **Pattern 4:**
  "Minimum positive solution" → Adjust $t$ until smallest $x > 0$ or $y > 0$.
* **Pattern 5:**
  Optimization in CP → Precompute gcd, use EEA only once per query.

---

I can follow this up by making you a **"contest quick-reference sheet"** for LDE with ready-to-use formulas, gcd checks, and bounds for $t$ so you can solve problems in under 60 seconds in contests.

Do you want me to prepare that quick-reference sheet now?
