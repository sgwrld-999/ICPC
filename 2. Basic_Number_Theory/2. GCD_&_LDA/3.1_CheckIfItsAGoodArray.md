## Check if the array is good
Problem link: https://leetcode.com/problems/check-if-it-is-a-good-array/description
```cpp
class Solution {
public:
    /**
     * Problem Understanding:
     * ----------------------
     * A "good array" is one where you can select some elements (subset) such that
     * their linear combination equals 1. 
     * 
     * Mathematical Insight:
     * ---------------------
     * From the Linear Diophantine Equation:
     *   ax + by = c  has integer solutions if and only if gcd(a, b) divides c.
     * For this problem, c = 1. So gcd(a, b) must be 1 for some subset of elements.
     * 
     * Key Optimization:
     * -----------------
     * Instead of checking all subsets, we can note:
     *   gcd(a1, a2, a3, ..., an) = 1  ⟹  There exists a subset whose gcd is 1.
     * Thus, the problem reduces to computing the GCD of the entire array.
     * 
     * Algorithm:
     * ----------
     * 1. Initialize `currentGCD` with the first element.
     * 2. Iterate through the array, updating `currentGCD = gcd(currentGCD, nums[i])`.
     * 3. If at any point `currentGCD == 1`, return true (early exit).
     * 4. After the loop, return `currentGCD == 1`.
     * 
     * Time Complexity:
     * ----------------
     * O(n * log(maxElement)) — gcd computation is logarithmic.
     * Space Complexity: O(1) — constant extra space.
     */
    bool isGoodArray(vector<int>& nums) {
        int currentGCD = nums[0];
        for (int i = 1; i < nums.size(); ++i) {
            currentGCD = gcd(currentGCD, nums[i]);
            if (currentGCD == 1) return true; // Early exit
        }
        return currentGCD == 1;
    }
};
```

---

## **Thought Process (as if in interview)**

> **Step 1 — Restate the problem:** We need to check if some subset of the array can be linearly combined (with integer coefficients) to produce `1`.
>
> **Step 2 — Connect to known theory:** This is exactly the integer solution condition of the Linear Diophantine Equation. For `c = 1`, the GCD of the subset must be `1`.
>
> **Step 3 — Optimization observation:** Instead of checking all subsets, if the GCD of the *entire array* is `1`, then the answer is `true`. Otherwise, it’s `false`.
>
> **Step 4 — Implementation plan:** Iterate once over the array, compute running GCD, exit early if it becomes `1`.
>
> **Step 5 — Complexity check:** Time is `O(n log(max(nums)))`, space is `O(1)`.
>
> **Step 6 — Edge cases:** Single element array (`[1]` → true, `[2]` → false), negative numbers (GCD is always positive).

---

### **Polished Interview Transcript Style Explanation**

**Interviewer:** Can you explain your thought process for this problem?

**You:**
Sure. The problem is essentially asking if there’s a subset of the given array whose linear combination equals `1`.

From **number theory**, I know that this is directly related to the **Linear Diophantine Equation**:

* The equation `a₁x₁ + a₂x₂ + ... + aₙxₙ = c` has integer solutions if and only if `gcd(a₁, a₂, ..., aₙ)` divides `c`.
* In our case, `c = 1`, so the condition becomes:

  ```
  gcd(a₁, a₂, ..., aₙ) == 1
  ```
* If that’s true, then 1 can be expressed as a linear combination of the array elements, meaning it’s a “good array.”

Instead of checking all subsets (which would be exponential), I can just compute the **GCD of the entire array**.

* I’ll initialize `currentGCD` with the first element.
* Iterate through the rest, updating `currentGCD = gcd(currentGCD, nums[i])`.
* If at any point `currentGCD` becomes `1`, I can return `true` early.
* Otherwise, at the end, I return whether `currentGCD` equals `1`.

**Complexity Analysis:**

* GCD computation is `O(log(maxElement))`, so overall complexity is `O(n log(maxElement))`.
* Space complexity is `O(1)`.

**Edge Cases:**

* `[1]` should return `true` since GCD is already 1.
* An array like `[2, 4, 6]` will return `false` since GCD stays above 1.
* Negative numbers don’t matter — GCD is always positive.

---

This style keeps the explanation tight, shows you know the math, **and** makes you sound like you’re solving it systematically rather than exploring aimlessly.

---


