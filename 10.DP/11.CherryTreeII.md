## \#\# Problem Name: Cherry Pickup II

**Problem Link:** [LeetCode](https://leetcode.com/problems/cherry-pickup-ii/)

-----

## \#\# Problem Understanding

You're given an `m x n` grid representing a field of cherries. You have two robots.

  * Robot 1 starts at the top-left corner `(0, 0)`.
  * Robot 2 starts at the top-right corner `(0, n-1)`.

**The Rules:**

  * **Movement:** Both robots must move **downwards** to the next row in every step. From a cell `(row, col)`, a robot can move to `(row + 1, col - 1)`, `(row + 1, col)`, or `(row + 1, col + 1)`.
  * **Cherries:** When a robot passes through a cell, it picks up all the cherries.
  * **Shared Cells:** If both robots land on the same cell, the cherries are only counted **once**.

**Task:**
Find the **maximum** total number of cherries the two robots can collect when they both reach the last row.

-----

## \#\# When to Think of Dynamic Programming

This problem is a clear signal for a more advanced DP approach:

1.  **Optimization on a Grid:** The goal is to find the **maximum** collection on a grid, a classic DP setup.
2.  **Simultaneous Movement:** You need to track the state of two different entities (robots) at the same time. This immediately suggests that your DP state will need to capture the positions of both.
3.  **Fixed Progression:** The robots move down one row at a time. This fixed, step-by-step progression is perfect for DP, as the state for `row` depends only on the state for `row + 1`.

-----

## \#\# The Recurrence Relation (The "Why")

Since both robots are always on the same row, the state of our problem can be defined by three variables: the current `row`, the column of the first robot `col1`, and the column of the second robot `col2`.

Let's define our function `f(row, col1, col2)` as the maximum cherries we can collect from the current `row` down to the very last row.

To calculate `f(row, col1, col2)`, we need to:

1.  Calculate the cherries collected at the current positions: `grid[row][col1] + grid[row][col2]` (or just `grid[row][col1]` if `col1 == col2`).
2.  Explore all possible next moves. Robot 1 has 3 choices, and Robot 2 has 3 choices, giving us `3 x 3 = 9` total combined moves to the next row.
3.  Find the `max` result from the recursive calls for these 9 future states: `max(f(row + 1, next_col1, next_col2))`.

The recurrence is:
`f(row, col1, col2) = current_cherries + max(f(row + 1, ...))`

The **base case** is when the robots reach the last row. At that point, they just collect the cherries and the process ends.

-----

## \#\# Code for All Methods

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
private:
    // Check if both robot positions are inside the grid
    bool isInBounds(int colCount, int col1, int col2) {
        return (col1 >= 0 && col2 >= 0 && col1 < colCount && col2 < colCount);
    }

    // --------------------  Recursive Approach --------------------
    int collectCherriesRecursively(int rowCount, int colCount,
                                   int row, int col1, int col2,
                                   vector<vector<int>>& grid) {
        // Out of bounds check
        if (!isInBounds(colCount, col1, col2)) return -1e8;

        // Collect cherries at the current positions
        int cherries = (col1 == col2) ? grid[row][col1]
                                      : grid[row][col1] + grid[row][col2];

        // Base case: last row
        if (row == rowCount - 1)
            return cherries;

        // Explore all 9 possible combinations of moves for the next row
        int maxFuture = -1e8;
        for (int move1 = -1; move1 <= 1; move1++) {
            for (int move2 = -1; move2 <= 1; move2++) {
                int nextVal = collectCherriesRecursively(rowCount, colCount,
                                                         row + 1, col1 + move1, col2 + move2, grid);
                maxFuture = max(maxFuture, nextVal);
            }
        }

        return cherries + maxFuture;
    }

    // --------------------  Memoization (Top-Down DP) --------------------
    int collectCherriesMemo(int rowCount, int colCount,
                            int row, int col1, int col2,
                            vector<vector<int>>& grid,
                            vector<vector<vector<int>>>& dp) {
        if (!isInBounds(colCount, col1, col2)) return -1e8;

        // Base case: last row
        if (row == rowCount - 1)
            return (col1 == col2) ? grid[row][col1]
                                  : grid[row][col1] + grid[row][col2];

        // If this state is already computed, return the result
        if (dp[row][col1][col2] != -1) return dp[row][col1][col2];

        int cherries = (col1 == col2) ? grid[row][col1]
                                      : grid[row][col1] + grid[row][col2];

        int maxFuture = -1e8;
        for (int move1 = -1; move1 <= 1; move1++) {
            for (int move2 = -1; move2 <= 1; move2++) {
                int nextVal = collectCherriesMemo(rowCount, colCount,
                                                  row + 1, col1 + move1, col2 + move2,
                                                  grid, dp);
                maxFuture = max(maxFuture, nextVal);
            }
        }
        
        // Store and return the result for the current state
        return dp[row][col1][col2] = cherries + maxFuture;
    }

    // --------------------  Tabulation (Bottom-Up DP) --------------------
    int collectCherriesTabulation(vector<vector<int>>& grid) {
        int rowCount = grid.size();
        int colCount = grid[0].size();

        vector<vector<vector<int>>> dp(rowCount,
            vector<vector<int>>(colCount, vector<int>(colCount, 0)));

        // Base case: fill the dp table for the last row
        for (int col1 = 0; col1 < colCount; col1++) {
            for (int col2 = 0; col2 < colCount; col2++) {
                dp[rowCount - 1][col1][col2] =
                    (col1 == col2) ? grid[rowCount - 1][col1]
                                   : grid[rowCount - 1][col1] + grid[rowCount - 1][col2];
            }
        }

        // Iterate from the second-to-last row up to the first
        for (int row = rowCount - 2; row >= 0; row--) {
            for (int col1 = 0; col1 < colCount; col1++) {
                for (int col2 = 0; col2 < colCount; col2++) {
                    // Find the max cherries from the next row
                    int maxFuture = -1e8;
                    for (int move1 = -1; move1 <= 1; move1++) {
                        for (int move2 = -1; move2 <= 1; move2++) {
                            int nextCol1 = col1 + move1;
                            int nextCol2 = col2 + move2;

                            if (isInBounds(colCount, nextCol1, nextCol2)) {
                                maxFuture = max(maxFuture, dp[row + 1][nextCol1][nextCol2]);
                            }
                        }
                    }

                    int cherries = (col1 == col2) ? grid[row][col1]
                                                  : grid[row][col1] + grid[row][col2];
                    dp[row][col1][col2] = cherries + maxFuture;
                }
            }
        }

        // The final answer is the result for the starting positions
        return dp[0][0][colCount - 1];
    }
public:
    int cherryPickup(vector<vector<int>>& grid) {
        return collectCherriesTabulation(grid);
    }
};
```

-----

## \#\# Complexity Analysis

Let `R` be the number of rows and `C` be the number of columns.

  * **Memoization Approach:**

      * **Time Complexity:** $O(R \times C \times C)$
          * We have `R * C * C` possible states `(row, col1, col2)`. Each state's calculation involves a constant number of operations (a loop of 9).
      * **Space Complexity:** $O(R \times C \times C)$ for the 3D `dp` table.

  * **Tabulation Approach:**

      * **Time Complexity:** $O(R \times C \times C)$. The nested loops iterate through all possible states.
      * **Space Complexity:** $O(R \times C \times C)$. This can be optimized to $O(C \times C)$ because to calculate the values for the current row, we only need the values from the row below it.

-----

## \#\# Key Takeaways

1.  **3D DP for Two Entities:** This problem is the quintessential example of using a 3D DP state to track two entities moving in sync (in this case, on the same row). The state `dp[row][col1][col2]` is the most natural way to model this.
2.  **Bottom-Up is Systematic:** The tabulation approach is very methodical. You establish the known base case (the last row) and then systematically build your solution backward to the starting state.
3.  **Explore All Transitions:** The core of the recurrence is to consider every possible combination of moves from one state to the next. Here, it was `3 x 3 = 9` possible transitions between rows.