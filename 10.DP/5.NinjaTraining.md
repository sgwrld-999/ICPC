Of course! This is an excellent problem to demonstrate the core principles of Dynamic Programming and the transition from recursion to more optimized solutions.

---

## **Problem Name:** Ninja's Training

### **1. Problem Understanding**

A ninja has a training schedule for **n** days. Each day, they can perform one of three activities. Each activity on a given day yields a specific number of merit points.

**The Constraint:** The ninja cannot perform the same activity on two consecutive days.

**Task:**
Find the **maximum** total merit points the ninja can earn over the `n` days.

**Example:**
`points = {{10, 40, 70}, {20, 50, 80}, {30, 60, 90}}`
The ninja can earn a maximum of `210` points (Day 0: Activity 2 (70), Day 1: Activity 1 (50), Day 2: Activity 2 (90)).

---

### **2. When to Think of Dynamic Programming**

This problem fits the DP pattern perfectly:

1.  **Optimization Problem:** The goal is to find the **maximum** total points.
2.  **Sequential Decisions:** On each day, the ninja must make a choice (which activity to do), and this choice directly impacts the available options for the next day.
3.  **Optimal Substructure:** The maximum points achievable up to `day i` can be calculated if we know the maximum points achievable up to `day i-1` for each possible activity.

---

### **3. The Recurrence Relation (The "Why")**

The core of the problem is deciding what to do on a given day. The state we need to track is the current `day` and the `last_activity` that was performed.

Let `f(day, last_activity)` be the maximum points the ninja can collect from the start up to the current `day`, given that `last_activity` was performed on the day *before*.

To compute `f(day, last_activity)`, we iterate through all possible activities for the current `day` (`current_activity` = 0, 1, or 2).

* If `current_activity` is **not** the same as `last_activity`, it's a valid choice.
* The points for this choice would be: `points[day][current_activity] + f(day - 1, current_activity)`.
* We take the **maximum** over all valid choices for `current_activity`.

This logic forms the basis for our recursive solution.

---

### **4. Three Approaches: From Recursion to Tabulation**

The provided code showcases the complete journey of solving a DP problem.

### **Approach 1: Simple Recursion**

This is a direct translation of the recurrence relation. It's easy to write but highly inefficient.

* **Time Complexity:** $O(3^n)$. For each day, we explore up to 3 branches, leading to an exponential number of calls.
* **Space Complexity:** $O(n)$ for the recursion call stack.

### **Approach 2: Memoization (Top-Down DP)**

This is the optimized recursive approach. We store the results of subproblems in a `dp` table (`memoization` in the code) so we never have to solve the same state `(day, last_activity)` more than once.

* **Time Complexity:** $O(n \times 4)$. We solve each state `dp[day][last_activity]` only once. There are `n` days and 4 possible "last activities" (0, 1, 2, and an initial state 3).
* **Space Complexity:** $O(n \times 4)$ for the DP table + $O(n)$ for the recursion stack.

### **Approach 3: Tabulation (Bottom-Up DP)**

This approach builds the solution from the ground up, starting from day 0, and iteratively fills a `dp` table. It completely avoids recursion. A clear way to structure the table is: `dp[i][j]` = maximum points achievable up to day `i`, ending with activity `j`.

**Algorithm:**
1.  Create a `dp` table of size `n x 3`.
2.  **Base Case (Day 0):** Initialize the first day's points directly: `dp[0][j] = points[0][j]`.
3.  **Iteration:** For each `day` from 1 to `n-1`:
    * For each `activity` `j` (0, 1, 2) on the current `day`:
        * Find the maximum points from the *previous day* on a *different* activity.
        * `dp[day][j] = points[day][j] + max(dp[day-1][other_activities])`.
4.  **Final Answer:** The result is the maximum value in the last row of the `dp` table: `max(dp[n-1][0], dp[n-1][1], dp[n-1][2])`.

* **Time Complexity:** $O(n \times 3)$. We iterate through each day and each activity once.
* **Space Complexity:** $O(n \times 3)$ for the DP table. (This can be further optimized to $O(1)$ since we only ever need the results from the previous day).

---

### **5. Dry Run Example (Tabulation)**

**Input:** `points = {{10, 40, 70}, {20, 50, 80}, {30, 60, 90}}`

**DP Table (`dp[day][activity]`):**

1.  **Day 0 (Base Case):**
    * `dp[0] = [10, 40, 70]`

2.  **Day 1:**
    * `dp[1][0]` (Activity 0): `points[1][0] + max(dp[0][1], dp[0][2])` = `20 + max(40, 70)` = `90`
    * `dp[1][1]` (Activity 1): `points[1][1] + max(dp[0][0], dp[0][2])` = `50 + max(10, 70)` = `120`
    * `dp[1][2]` (Activity 2): `points[1][2] + max(dp[0][0], dp[0][1])` = `80 + max(10, 40)` = `120`
    * `dp[1] = [90, 120, 120]`

3.  **Day 2:**
    * `dp[2][0]` (Activity 0): `points[2][0] + max(dp[1][1], dp[1][2])` = `30 + max(120, 120)` = `150`
    * `dp[2][1]` (Activity 1): `points[2][1] + max(dp[1][0], dp[1][2])` = `60 + max(90, 120)` = `180`
    * `dp[2][2]` (Activity 2): `points[2][2] + max(dp[1][0], dp[1][1])` = `90 + max(90, 120)` = `210`
    * `dp[2] = [150, 180, 210]`

4.  **Final Result:** `max(150, 180, 210)` = `210`.

âœ… **Final Answer: 210**

---

### **6. Code**
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Recursive approach
    int findingMaximumPoints(int day, int lastActivity, vector<vector<int>>& pointsTable) {
        if (day == 0) {
            int maxValue = 0;
            for (int activity = 0; activity < 3; activity++) {
                if (activity != lastActivity)
                    maxValue = max(maxValue, pointsTable[0][activity]);
            }
            return maxValue;
        }

        int maxValue = 0;
        for (int activity = 0; activity < 3; activity++) {
            if (activity != lastActivity) {
                int chosenActivity = pointsTable[day][activity] +
                                     findingMaximumPoints(day - 1, activity, pointsTable);
                maxValue = max(maxValue, chosenActivity);
            }
        }
        return maxValue;
    }

    // Memoization approach
    int findingMaximumPointsUsingMemoization(int day, int lastActivity,
                                             vector<vector<int>>& pointsTable,
                                             vector<vector<int>>& memoization) {
        if (memoization[day][lastActivity] != -1)
            return memoization[day][lastActivity];

        if (day == 0) {
            int maxValue = 0;
            for (int activity = 0; activity < 3; activity++) {
                if (activity != lastActivity)
                    maxValue = max(maxValue, pointsTable[0][activity]);
            }
            return memoization[day][lastActivity] = maxValue;
        }

        int maxValue = 0;
        for (int activity = 0; activity < 3; activity++) {
            if (activity != lastActivity) {
                int chosenActivity = pointsTable[day][activity] +
                                     findingMaximumPointsUsingMemoization(day - 1, activity, pointsTable, memoization);
                maxValue = max(maxValue, chosenActivity);
            }
        }
        return memoization[day][lastActivity] = maxValue;
    }

    // Tabulation approach
    int findingMaximumPointsUsingTabulation(int days, vector<vector<int>>& pointsTable) {
        vector<vector<int>> tabulationTable(days, vector<int>(4, 0));

        // Base case initialization (day 0)
        tabulationTable[0][0] = max(pointsTable[0][1], pointsTable[0][2]);
        tabulationTable[0][1] = max(pointsTable[0][0], pointsTable[0][2]);
        tabulationTable[0][2] = max(pointsTable[0][0], pointsTable[0][1]);
        tabulationTable[0][3] = max(pointsTable[0][0], max(pointsTable[0][1], pointsTable[0][2]));

        // Fill DP table iteratively
        for (int day = 1; day < days; day++) {
            for (int last = 0; last < 4; last++) {
                tabulationTable[day][last] = 0;

                for (int task = 0; task < 3; task++) {
                    if (task != last) {
                        int activity = pointsTable[day][task] + tabulationTable[day - 1][task];
                        tabulationTable[day][last] = max(tabulationTable[day][last], activity);
                    }
                }
            }
        }

        return tabulationTable[days - 1][3];
    }
};

int main() {
    Solution obj;
    vector<vector<int>> pointsTable = {
        {10, 40, 70},
        {20, 50, 80},
        {30, 60, 90}
    };

    int n = pointsTable.size();

    cout << "Using Recursion Only: "
         << obj.findingMaximumPoints(n - 1, 3, pointsTable) << endl;

    vector<vector<int>> memoization(n, vector<int>(4, -1));
    cout << "Using Memoization: "
         << obj.findingMaximumPointsUsingMemoization(n - 1, 3, pointsTable, memoization) << endl;

    cout << "Using Tabulation: "
         << obj.findingMaximumPointsUsingTabulation(n, pointsTable) << endl;

    return 0;
}
```
The provided code correctly implements all three approaches. The `main` function demonstrates how to call each one to get the same, correct result.

### **7. Key Takeaways**

1.  **State Definition is Crucial:** Defining the DP state correctly (e.g., what information do I need from the past to solve the present?) is the most important step. Here, it was the `day` and the `last_activity`.
2.  **Path to Optimization:** This problem is a textbook example of how a simple recursive idea can be optimized. Memoization plugs the efficiency hole in recursion, and tabulation provides an iterative, often more efficient, alternative.
3.  **Space Optimization:** For problems where the current state only depends on the immediately preceding state (like this one), the space complexity can often be reduced from $O(n)$ to $O(1)$ by just keeping track of the previous row's results instead of the entire table.