## **Problem Name:** Triangle

**Problem Link:** [LeetCode](https://leetcode.com/problems/triangle/)

### **1. Problem Understanding**

You are given a triangle, represented as a 2D vector, where `triangle[i][j]` is the number at row `i` and column `j`. You start at the very top of the triangle, `(0, 0)`.

**The Rules:**

  * From any cell `(row, col)`, you can move to one of two cells in the next row:
      * `(row + 1, col)` (directly below)
      * `(row + 1, col + 1)` (diagonally below)
  * A "path" is a sequence of such moves from the top to the bottom row.

**Task:**
Find the **minimum path sum** from the top to the bottom of the triangle.

-----

### **2. When to Think of Dynamic Programming**

This problem has all the classic hallmarks of a DP problem:

1.  **Optimization Problem:** You need to find the **minimum** path sum.
2.  **Grid-like Structure:** Although it's a triangle, it's a 2D structure where you make sequential decisions to move from one level to the next.
3.  **Optimal Substructure:** The minimum path sum *starting from* any cell `(row, col)` is simply the value of that cell plus the minimum of the path sums starting from its two children in the row below. This means the overall optimal path is built from optimal sub-paths.

-----

### **3. The Recurrence Relation (The "Why")**

The most intuitive way to think about this problem is from a given cell looking down. Let's define `f(row, col)` as the minimum path sum starting from cell `(row, col)` all the way to the bottom.

To calculate `f(row, col)`, we must:

1.  Take the value of the current cell, `triangle[row][col]`.
2.  Choose the cheaper of the two possible next steps: the path starting from `f(row + 1, col)` or the path starting from `f(row + 1, col + 1)`.

This gives us the recurrence relation:
`f(row, col) = triangle[row][col] + min( f(row + 1, col), f(row + 1, col + 1) )`

The base case is any cell in the last row, where the minimum path sum is just the value of the cell itself.

-----

### **4. Three Approaches: Recursion, Memoization, and Tabulation**

The provided code clearly shows the progression from a slow to a fast solution.

#### **Approach 1: Simple Recursion**

This is a straightforward implementation of the recurrence relation, starting from the top `(0, 0)`. It's easy to understand but very inefficient due to re-calculating paths for the same cells over and over.

  * **Time Complexity:** Exponential, $O(2^N)$, where N is the total number of cells.
  * **Space Complexity:** $O(H)$, where H is the height of the triangle, for the recursion stack.

#### **Approach 2: Memoization (Top-Down DP)**

We optimize the recursion by adding a `dp` table. `dp[row][col]` stores the minimum path sum starting from `(row, col)`. Before making recursive calls, we check if the answer is already in our table.

  * **Time Complexity:** $O(N)$, where N is the total number of cells (approx. `rows*rows/2`). We compute the value for each cell only once.
  * **Space Complexity:** $O(N)$ for the `dp` table + $O(H)$ for the recursion stack.

#### **Approach 3: Tabulation (Bottom-Up DP)**

This is a very clean and efficient iterative approach that works backward from the goal. We know the minimum path sums for the last row (it's just their own values). We can use this information to calculate the minimum path sums for the row above it, and so on, until we reach the top.

  * **Time Complexity:** $O(N)$.
  * **Space Complexity:** $O(N)$. This can be optimized to $O(H)$ (space for one row) because to calculate the values for `row i`, we only need the values from `row i+1`.

-----

### **5. Code**

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // -------------------- RECURSIVE APPROACH --------------------
    int findMinPathRecursive(int row, int col, vector<vector<int>>& triangle) {
        // Base case: If we are at the last row, the path sum is just the cell's value.
        if (row == triangle.size() - 1)
            return triangle[row][col];

        // Move to the cell directly below
        int down = triangle[row][col] + findMinPathRecursive(row + 1, col, triangle);
        // Move to the cell diagonally below
        int diagonal = triangle[row][col] + findMinPathRecursive(row + 1, col + 1, triangle);

        // Return the minimum of the two possible paths
        return min(down, diagonal);
    }

    // -------------------- MEMOIZATION APPROACH --------------------
    int findMinPathMemoized(int row, int col, vector<vector<int>>& triangle, vector<vector<int>>& dp) {
        if (row == triangle.size() - 1)
            return triangle[row][col];

        // If we've already computed the min path from this cell, return it.
        if (dp[row][col] != -1) return dp[row][col];

        int down = triangle[row][col] + findMinPathMemoized(row + 1, col, triangle, dp);
        int diagonal = triangle[row][col] + findMinPathMemoized(row + 1, col + 1, triangle, dp);
        
        // Store the result before returning.
        return dp[row][col] = min(down, diagonal);
    }

    // -------------------- TABULATION APPROACH --------------------
    int findMinPathTabulated(vector<vector<int>>& triangle) {
        int n = triangle.size();
        vector<vector<int>> dp(n, vector<int>(n, 0));

        // Base case: Initialize the last row of dp with the last row of the triangle.
        for (int j = 0; j < n; j++)
            dp[n - 1][j] = triangle[n - 1][j];

        // Fill the dp table from the second-to-last row up to the first row.
        for (int i = n - 2; i >= 0; i--) {
            for (int j = 0; j <= i; j++) {
                // Cost from moving straight down
                int down = triangle[i][j] + dp[i + 1][j];
                // Cost from moving diagonally down
                int diagonal = triangle[i][j] + dp[i + 1][j + 1];
                dp[i][j] = min(down, diagonal);
            }
        }
        
        // The answer is the minimum path sum starting from the top cell (0, 0).
        return dp[0][0];
    }
};
```

-----

### **6. Dry Run Example (Tabulation)**

**Input:** `triangle = {{2}, {3, 4}, {6, 5, 7}, {4, 1, 8, 3}}`

**DP Table (`dp[i][j]`):**

1.  **Base Case (Row 3):** We initialize the last row of our `dp` table.

      * `dp[3] = [4, 1, 8, 3]`

2.  **Compute Row 2 (working upwards):**

      * `dp[2][0] = tri[2][0] + min(dp[3][0], dp[3][1]) = 6 + min(4, 1) = 7`
      * `dp[2][1] = tri[2][1] + min(dp[3][1], dp[3][2]) = 5 + min(1, 8) = 6`
      * `dp[2][2] = tri[2][2] + min(dp[3][2], dp[3][3]) = 7 + min(8, 3) = 10`
      * `dp`'s last two rows: `[..., [7, 6, 10], [4, 1, 8, 3]]`

3.  **Compute Row 1:**

      * `dp[1][0] = tri[1][0] + min(dp[2][0], dp[2][1]) = 3 + min(7, 6) = 9`
      * `dp[1][1] = tri[1][1] + min(dp[2][1], dp[2][2]) = 4 + min(6, 10) = 10`

4.  **Compute Row 0:**

      * `dp[0][0] = tri[0][0] + min(dp[1][0], dp[1][1]) = 2 + min(9, 10) = 11`

**Final Answer:** `dp[0][0]` = **11**.

-----

### **7. Key Takeaways**

1.  **Bottom-Up Can Be More Intuitive:** For problems where the base cases are at the "end" (like the last row of the triangle), a bottom-up tabulation approach often leads to cleaner and more understandable code than a top-down recursive one.
2.  **State Representation:** The state `dp[row][col]` cleanly represents the minimum path sum *starting from that cell*. Defining the state is the most critical part of solving any DP problem.
3.  **Space Optimization:** This problem is a prime example for space optimization. Since you only need the next row `i+1` to compute the current row `i`, you can reduce the space complexity from $O(N^2)$ to $O(N)$ by using just a single 1D array to store the "next row's" results.