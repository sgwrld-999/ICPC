## **Problem Name:** Minimum Path Sum

**Problem Link:** [LeetCode](https://leetcode.com/problems/minimum-path-sum/)

### **1. Problem Understanding**

You're given an `m x n` grid filled with non-negative numbers. You need to find a path from the top-left corner `(0, 0)` to the bottom-right corner `(m-1, n-1)`.

**The Rules:**

  * You can only move either **down** or **right** at any point in time.
  * The "cost" of a path is the sum of all numbers along that path.

**Task:**
Find the path with the **minimum** possible cost.

-----

### **2. When to Think of Dynamic Programming**

This problem is a classic application of Dynamic Programming:

1.  **Grid Traversal:** The problem is set on a grid, a common DP environment.
2.  **Optimization Problem:** The core task is to find the **minimum** cost, a clear signal for an optimization DP approach.
3.  **Optimal Substructure:** The minimum cost path to any cell `(i, j)` must pass through one of its optimal predecessors. In other words, the globally optimal path is composed of locally optimal sub-paths.
4.  **Overlapping Subproblems:** Just like in "Unique Paths," a naive recursive approach would repeatedly calculate the minimum path sum to the same cells.

-----

### **3. The Recurrence Relation (The "Why")**

This problem is very similar to "Unique Paths," but instead of counting the number of paths, we are minimizing their sum.

To reach any cell `(i, j)` with the minimum possible cost, you must have arrived from the cell that offered the cheaper path: either the cell above `(i-1, j)` or the cell to the left `(i, j-1)`.

The minimum cost to reach `(i, j)` is therefore the cost of the cell `(i, j)` itself, plus the minimum of the costs to reach its two predecessors.

`min_cost(i, j) = cost(i, j) + min( min_cost(i-1, j), min_cost(i, j-1) )`

This recurrence is the heart of the DP solution.

-----

### **4. Three Approaches: The DP Journey**

Your code perfectly demonstrates the standard ways to tackle this.

#### **Approach 1: Simple Recursion**

This approach directly implements the recurrence relation. It's a natural starting point but is too slow for larger grids due to massive redundant calculations.

  * **Time Complexity:** Exponential, $O(2^{m+n})$
  * **Space Complexity:** $O(m+n)$ for the recursion stack.

#### **Approach 2: Memoization (Top-Down DP)**

This is the optimized recursive solution. By using a `dp` table to store the minimum cost for each cell once it's computed, we avoid re-doing work.

  * **Time Complexity:** $O(m \times n)$. Each cell's minimum path sum is calculated exactly once.
  * **Space Complexity:** $O(m \times n)$ for the `dp` table + $O(m+n)$ for the recursion stack.

#### **Approach 3: Tabulation (Bottom-Up DP)**

This iterative approach is often preferred as it eliminates recursion. We build a `dp` table where `dp[i][j]` stores the minimum cost to reach cell `(i, j)`.

  * **Time Complexity:** $O(m \times n)$.
  * **Space Complexity:** $O(m \times n)$. This can be optimized to $O(n)$ by realizing that to compute the current row, you only need the data from the previous row.

-----

### **5. Dry Run Example (Tabulation)**

**Input:** `costGrid = {{1, 3, 1}, {1, 5, 1}, {4, 2, 1}}`

**DP Table (`dp[i][j]` will store the min cost to reach that cell):**

1.  **Base Case:** `dp[0][0] = costGrid[0][0] = 1`.

2.  **Fill First Row (can only come from the left):**

      * `dp[0][1] = costGrid[0][1] + dp[0][0] = 3 + 1 = 4`
      * `dp[0][2] = costGrid[0][2] + dp[0][1] = 1 + 4 = 5`

3.  **Fill First Column (can only come from above):**

      * `dp[1][0] = costGrid[1][0] + dp[0][0] = 1 + 1 = 2`
      * `dp[2][0] = costGrid[2][0] + dp[1][0] = 4 + 2 = 6`

4.  **Fill the Rest of the Grid:**

      * `dp[1][1] = costGrid[1][1] + min(dp[0][1], dp[1][0]) = 5 + min(4, 2) = 7`
      * `dp[1][2] = costGrid[1][2] + min(dp[0][2], dp[1][1]) = 1 + min(5, 7) = 6`
      * `dp[2][1] = costGrid[2][1] + min(dp[1][1], dp[2][0]) = 2 + min(7, 6) = 8`
      * `dp[2][2] = costGrid[2][2] + min(dp[1][2], dp[2][1]) = 1 + min(6, 8) = 7`

5.  **Final DP Table:**

    ```
    [[1, 4, 5],
     [2, 7, 6],
     [6, 8, 7]]
    ```

 **Final Answer:** The value at `dp[2][2]` is **7**.

-----

### **6. Code**
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // -------------------- RECURSIVE APPROACH --------------------
    int findMinPathRecursive(int row, int col, vector<vector<int>>& costGrid) {
        if (row == 0 && col == 0) return costGrid[0][0];
        if (row < 0 || col < 0) return 1e7;  // represents an invalid path

        int costFromTop = costGrid[row][col] + findMinPathRecursive(row - 1, col, costGrid);
        int costFromLeft = costGrid[row][col] + findMinPathRecursive(row, col - 1, costGrid);

        return min(costFromTop, costFromLeft);
    }

    // -------------------- MEMOIZATION APPROACH --------------------
    int findMinPathMemoized(int row, int col, vector<vector<int>>& costGrid, vector<vector<int>>& dp) {
        if (row == 0 && col == 0) return costGrid[0][0];
        if (row < 0 || col < 0) return 1e7;

        if (dp[row][col] != -1) return dp[row][col];

        int costFromTop = costGrid[row][col] + findMinPathMemoized(row - 1, col, costGrid, dp);
        int costFromLeft = costGrid[row][col] + findMinPathMemoized(row, col - 1, costGrid, dp);

        return dp[row][col] = min(costFromTop, costFromLeft);
    }

    // -------------------- TABULATION APPROACH --------------------
    int findMinPathTabulated(vector<vector<int>>& costGrid) {
        int totalRows = costGrid.size();
        int totalCols = costGrid[0].size();

        vector<vector<int>> dp(totalRows, vector<int>(totalCols, 0));

        dp[0][0] = costGrid[0][0];

        // Fill first column
        for (int row = 1; row < totalRows; row++)
            dp[row][0] = dp[row - 1][0] + costGrid[row][0];

        // Fill first row
        for (int col = 1; col < totalCols; col++)
            dp[0][col] = dp[0][col - 1] + costGrid[0][col];

        // Fill remaining cells
        for (int row = 1; row < totalRows; row++) {
            for (int col = 1; col < totalCols; col++) {
                int minPrevCost = min(dp[row - 1][col], dp[row][col - 1]);
                dp[row][col] = costGrid[row][col] + minPrevCost;
            }
        }

        return dp[totalRows - 1][totalCols - 1];
    }

    // -------------------- DRIVER FUNCTION --------------------
    int getMinimumPathSum(vector<vector<int>>& costGrid) {
        int totalRows = costGrid.size();
        int totalCols = costGrid[0].size();

        // // Option 1: Pure Recursion
        // return findMinPathRecursive(totalRows - 1, totalCols - 1, costGrid);

        // // Option 2: Memoization
        // vector<vector<int>> dp(totalRows, vector<int>(totalCols, -1));
        // return findMinPathMemoized(totalRows - 1, totalCols - 1, costGrid, dp);

        // Option 3: Tabulation
        return findMinPathTabulated(costGrid);
    }
};

int main() {
    Solution solver;

    vector<vector<int>> costGrid = {
        {1, 3, 1},
        {1, 5, 1},
        {4, 2, 1}
    };

    cout << "Using Recursion: "
         << solver.findMinPathRecursive(costGrid.size() - 1, costGrid[0].size() - 1, costGrid)
         << endl;

    vector<vector<int>> dp(costGrid.size(), vector<int>(costGrid[0].size(), -1));
    cout << "Using Memoization: "
         << solver.findMinPathMemoized(costGrid.size() - 1, costGrid[0].size() - 1, costGrid, dp)
         << endl;

    cout << "Using Tabulation: "
         << solver.findMinPathTabulated(costGrid)
         << endl;

    return 0;
}

```
-----
### **7. Key Takeaways**

1.  **From Counting to Optimization:** This problem shows a simple but important shift from the "Unique Paths" problem. Instead of adding the results from predecessors (`+`), we find the best one (`min()`) and add the current cell's value.
2.  **The Grid DP Template:** The pattern of initializing `dp[0][0]`, filling the first row/column, and then iterating through the rest of the grid is a powerful and reusable template for many grid-based DP problems.
3.  **Thinking About State:** The state `dp[i][j]` cleanly represents the "minimum cost to reach cell (i, j)." Defining this state clearly is the most crucial step in solving the problem.