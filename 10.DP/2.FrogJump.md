# Frog Jump

---

## Question

**Frog Jump (LeetCode 403)**

A frog is crossing a river. The river is divided into `n` stones at certain positions given by an array `stones[]`, where `stones[i]` is the position of the i-th stone. The frog starts on the first stone (`stones[0] = 0`).

The frog can make jumps of size **k - 1, k, or k + 1** where `k` is the last jump length. The first jump must be 1 unit.

Return **true** if the frog can reach the last stone, else false.

**Example 1:**

* Input: `stones = [0,1,3,5,6,8,12,17]`
* Output: `true`
* Explanation: The frog can jump 1 → 2 → 2 → 3 → 4 units to reach 17.

**Example 2:**

* Input: `stones = [0,1,2,3,4,8,9,11]`
* Output: `false`
* Explanation: Frog cannot jump to the last stone.

---

## Approach

1. Use recursion with memoization (`dp`).
2. State: `dp[idx][lastJump]` → whether frog can reach the last stone starting from index `idx` with previous jump length `lastJump`.
3. Base case: if `idx == n - 1` → reached last stone → return true.
4. Transition:

   * From `stones[idx]`, try jumping to all possible next stones.
   * Compute `gap = stones[next] - stones[idx]`.
   * Valid moves if `gap == lastJump - 1 || gap == lastJump || gap == lastJump + 1`.
   * If any recursive call returns true → mark dp[idx][lastJump] = true.
   * If `gap > lastJump + 1`, break since stones are sorted.
5. Memoize results to avoid recomputation.
6. Start recursion from stone `1` with jump size `1`.

---

## Pattern

**DP on States with Recursion (Top-Down + Memoization)**

* Hint: "Whenever a problem has a **state defined by position + last decision/action** (like index + last jump), use **DP with multiple dimensions**."
* Why?

  * At each stone, the decision depends not just on the index but also on the **previous jump size**.
  * This naturally forms a **2D DP** → one dimension for stone index, one for last jump size.
* This is a **State + Transition Pattern** common in problems like frog jump, stone game, or knapsack-like variations.

---

## Time and Space Complexity

* **Time Complexity:** `O(n^2)` worst case (for each stone, we might check all possible jumps).
* **Space Complexity:** `O(n^2)` for the dp table + recursion stack.

---

## Dry Run

**Input:** `stones = [0,1,3,5,6,8,12,17]`

* Start: idx = 1, lastJump = 1 (from 0 to 1).
* At idx = 1 (stone = 1):

  * Try gap = 2 (stone 3) → valid (lastJump+1).
* At idx = 2 (stone = 3, lastJump = 2):

  * gap = 2 (stone 5) → valid.
* At idx = 3 (stone = 5, lastJump = 2):

  * gap = 1 (stone 6) → valid.
* At idx = 4 (stone = 6, lastJump = 1):

  * gap = 2 (stone 8) → valid.
* At idx = 5 (stone = 8, lastJump = 2):

  * gap = 4 (stone 12) → valid.
* At idx = 6 (stone = 12, lastJump = 4):

  * gap = 5 (stone 17) → valid.
* Reached last stone → return true.

---

## Correct C++ Code

```cpp
#include <iostream>
#include <vector>
using namespace std;

class Solution {
private:
    bool canCrossRiver(vector<int>& stones, int n, int idx, int lastJump, vector<vector<int>>& dp) {
        // Base case: reached last stone
        if (idx == n - 1) return true;

        // Already computed
        if (dp[idx][lastJump] != -1) return dp[idx][lastJump];

        // Try all possible next stones
        for (int next = idx + 1; next < n; next++) {
            int gap = stones[next] - stones[idx];

            // Frog can jump lastJump-1, lastJump, or lastJump+1
            if (gap == lastJump - 1 || gap == lastJump || gap == lastJump + 1) {
                if (canCrossRiver(stones, n, next, gap, dp)) {
                    return dp[idx][lastJump] = true;
                }
            }

            // Stones are sorted: if gap too large, no further checking needed
            if (gap > lastJump + 1) break;
        }

        return dp[idx][lastJump] = false;
    }

public:
    bool canCross(vector<int>& stones) {
        int n = stones.size();

        // Early check: if the first jump is not 1, frog cannot move
        if (stones[1] != 1) return false;

        // dp[idx][lastJump]: -1 = uncomputed, 0 = false, 1 = true
        vector<vector<int>> dp(n, vector<int>(n + 1, -1));

        return canCrossRiver(stones, n, 1, 1, dp);
    }
};

int main() {
    Solution sol;
    vector<int> stones1 = {0,1,3,5,6,8,12,17};
    vector<int> stones2 = {0,1,2,3,4,8,9,11};

    cout << sol.canCross(stones1) << endl; // Output: 1 (true)
    cout << sol.canCross(stones2) << endl; // Output: 0 (false)

    return 0;
}
```

---
