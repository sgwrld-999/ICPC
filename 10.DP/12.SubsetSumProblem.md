## \#\# Problem Name: Subset Sum Problem

**Problem Links:**

  * [GeeksforGeeks](https://www.geeksforgeeks.org/problems/subset-sum-problem-1611555638/1)
  * [LeetCode (related)](https://leetcode.com/problems/partition-equal-subset-sum/)

-----

## \#\# Problem Understanding

You're given an array of non-negative integers and a target `sum`.

**Task:**
Determine if there exists a **subset** of the given array whose elements sum up to the target `sum`. You can return `true` or `false`.

**Example:**

  * `arr = [2, 3, 7, 8, 10]`, `sum = 11`
  * **Output:** `true` (The subset `{3, 8}` sums to 11).

-----

## \#\# When to Think of Dynamic Programming

This problem is a classic candidate for DP, especially for the "pick/not pick" pattern.

1.  **Decision at Every Step:** For each element in the array, you have to make a choice: do you **include** it in your subset or **exclude** it?
2.  **Feasibility Problem:** The question asks "is it possible?" to form the sum, not "what is the subset?" or "what is the minimum/maximum?".
3.  **Optimal Substructure:** The possibility of forming a `target` sum using the first `i` elements depends on whether you could form the required sum using the first `i-1` elements.
4.  **Overlapping Subproblems:** A plain recursive solution would re-calculate the same subproblems (e.g., "can we make a sum of 5 using the first 3 elements?") multiple times. DP avoids this.

-----

## \#\# The Recurrence Relation (The "Why")

The core idea for this and many related problems is the **"pick vs. not pick"** choice for each element.

Let `f(idx, target)` be a function that returns `true` if we can make the `target` sum using elements from the array up to index `idx`.

For any element `arr[idx]`, we have two choices:

1.  **Don't Pick `arr[idx]`:** We ignore the current element and try to make the same `target` using the remaining elements up to `idx-1`. This is `f(idx-1, target)`.
2.  **Pick `arr[idx]`:** We include the current element in our subset. Now, we need to make a new, smaller `target - arr[idx]` using the remaining elements up to `idx-1`. This is `f(idx-1, target - arr[idx])`. This choice is only possible if `target >= arr[idx]`.

Since we can succeed if *either* choice works, we combine them with an **OR** operation.

`f(idx, target) = f(idx-1, target) || f(idx-1, target - arr[idx])`

-----

## \#\# Code for All Methods

Here are the three standard DP approaches to solve this problem.

### \#\#\# 1. Simple Recursion

This is the direct, unoptimized implementation of our recurrence relation.

  * **Time Complexity:** $O(2^N)$ - Exponential, as it explores every possible subset.
  * **Space Complexity:** $O(N)$ for the recursion call stack.

<!-- end list -->

```cpp
bool recursion(int idx, int target, vector<int>& arr) {
    // Base Case 1: Target achieved
    if (target == 0) return true;
    // Base Case 2: No elements left to check
    if (idx == 0) return (arr[0] == target);
    
    // Choice 1: Don't pick the current element
    bool notTake = recursion(idx - 1, target, arr);
    
    // Choice 2: Pick the current element (if possible)
    bool take = false;
    if (target >= arr[idx]) {
        take = recursion(idx - 1, target - arr[idx], arr);
    }
    
    return (take || notTake);
}
```

### \#\#\# 2. Memoization (Top-Down DP)

We optimize the recursion by storing the results of subproblems in a 2D `dp` table to avoid re-computation.

  * **Time Complexity:** $O(N \times \text{sum})$. Each state `(idx, target)` is computed only once.
  * **Space Complexity:** $O(N \times \text{sum})$ for the DP table + $O(N)$ for the recursion stack.

<!-- end list -->

```cpp
bool recursionMemo(int idx, int target, vector<int>& arr, vector<vector<int>>& dp) {
    if (target == 0) return true;
    if (idx == 0) return (arr[0] == target);
    
    // If this subproblem has been solved, return the result
    if (dp[idx][target] != -1) return dp[idx][target];
    
    bool notTake = recursionMemo(idx - 1, target, arr, dp);
    bool take = false;
    if (target >= arr[idx]) {
        take = recursionMemo(idx - 1, target - arr[idx], arr, dp);
    }
    
    // Store the result before returning
    return dp[idx][target] = (take | notTake);
}
```

### \#\#\# 3. Tabulation (Bottom-Up DP)

We build the solution iteratively, filling a `dp` table from the smallest subproblems up to the final answer. `dp[i][t]` means "is it possible to make sum `t` using elements up to index `i`?".

  * **Time Complexity:** $O(N \times \text{sum})$.
  * **Space Complexity:** $O(N \times \text{sum})$. (Can be optimized to $O(\text{sum})$).

<!-- end list -->

```cpp
bool tabulation(vector<int>& arr, int sum) {
    int n = arr.size();
    vector<vector<bool>> dp(n, vector<bool>(sum + 1, false));

    // Base Case 1: A sum of 0 is always possible with an empty subset.
    for (int i = 0; i < n; i++) {
        dp[i][0] = true;
    }

    // Base Case 2: With only the first element, we can only make a sum equal to its value.
    if (arr[0] <= sum) {
        dp[0][arr[0]] = true;
    }

    // Fill the DP table
    for (int i = 1; i < n; i++) {
        for (int target = 1; target <= sum; target++) {
            // notTake: can we make the target without the current element?
            bool notTake = dp[i - 1][target];
            // take: can we make the target by including the current element?
            bool take = false;
            if (target >= arr[i]) {
                take = dp[i - 1][target - arr[i]];
            }
            dp[i][target] = take || notTake;
        }
    }
    
    return dp[n - 1][sum];
}
```

-----

## \#\# Dry Run Example (Tabulation)

**Input:** `arr = {3, 2, 7}`, `sum = 9`

**DP Table (`dp[i][target]`):** `3 x 10` table, `T=true`, `F=false`

| idx\\target | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| :--- | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| **0 (use 3)** | T | F | F | T | F | F | F | F | F | F |
| **1 (use 2)** | T | F | T | T | F | T | F | F | F | F |
| **2 (use 7)** | T | F | T | T | F | T | F | T | F | T |

1.  **Row 0 (using `{3}`):** We can make sum `0` (empty set) and sum `3`.
2.  **Row 1 (using `{3, 2}`):**
      * `dp[1][2]` = `dp[0][2]` (notTake=F) `||` `dp[0][2-2]` (take=T) -\> `T`
      * `dp[1][5]` = `dp[0][5]` (notTake=F) `||` `dp[0][5-2]` (take=T) -\> `T`
3.  **Row 2 (using `{3, 2, 7}`):**
      * `dp[2][7]` = `dp[1][7]` (F) `||` `dp[1][7-7]` (T) -\> `T`
      * `dp[2][9]` = `dp[1][9]` (F) `||` `dp[1][9-7]` (T) -\> `T`

 **Final Answer:** `dp[2][9]` is **true**.

-----

## \#\# Connection to "Partition Equal Subset Sum"

This problem is a direct application of the Subset Sum problem.

**Problem:** Can an array be partitioned into two subsets with an equal sum?

**Logic:**

1.  Calculate the `totalSum` of the array.
2.  If `totalSum` is **odd**, it's impossible to partition it into two equal halves. Return `false`.
3.  If `totalSum` is **even**, the goal is to find two subsets that each sum to `target = totalSum / 2`.
4.  You only need to find **one** subset that sums to `target`. If you find one, the remaining elements are guaranteed to form the other subset.
5.  The problem reduces to: `isSubsetSum(arr, totalSum / 2)`.

-----

## \#\# Key Takeaways

1.  **"Pick/Not Pick" is Fundamental:** This decision-making pattern is the cornerstone of many DP problems involving subsets, subsequences, and the knapsack problem.
2.  **DP State:** The state `dp[index][target]` is a powerful way to represent subproblems. It asks, "Can we achieve this `target` using elements up to this `index`?"
3.  **Building Block:** This problem is a foundational DP concept. Mastering it makes it easier to solve more complex variations.