Of course. This is a foundational problem for understanding Dynamic Programming on grids. Here are the detailed notes.

---

## **Problem Name:** Unique Paths with Obstacles

### **1. Problem Understanding**

We are given an `m x n` grid. Some cells in the grid are marked as open paths, while others are marked as obstacles. We start at the top-left corner `(0, 0)` and want to reach the bottom-right corner `(m-1, n-1)`.

**The Rules:**
* You can only move **right** or **down** at any point.
* You cannot move through a cell that is an obstacle.

**Task:**
Find the total number of **unique paths** from the start to the finish.

**Example:**

In a 3x3 grid with one obstacle in the middle, there are 2 unique paths from the top-left to the bottom-right.

---

### **2. When to Think of Dynamic Programming**

Grid traversal problems are prime candidates for DP. Hereâ€™s why this problem fits:

1.  **Grid Problem:** The problem is explicitly set on a 2D grid, a very common setting for DP.
2.  **Counting Problem:** The question asks for the "number of unique paths," which is a counting task well-suited for DP.
3.  **Optimal Substructure:** The number of ways to reach a cell `(i, j)` is directly dependent on the number of ways to reach the cells from which we can enter it (`(i-1, j)` and `(i, j-1)`).
4.  **Overlapping Subproblems:** In a simple recursive approach, the number of paths to a single cell would be recalculated many times as it contributes to the paths of multiple future cells.

---

### **3. The Recurrence Relation (The "Why")**

To find the number of ways to get to any cell `(i, j)`, we can think about the final move that brought us there. Since we can only move **down** or **right**, we must have arrived from:
* The cell directly above, `(i-1, j)`.
* The cell directly to the left, `(i, j-1)`.

Therefore, the total number of unique paths to cell `(i, j)` is the sum of the paths to these two cells.

`paths(i, j) = paths(i-1, j) + paths(i, j-1)`

We also have to handle the obstacles. If the cell `(i, j)` itself is an obstacle, then it's impossible to reach it, so:

`If grid[i][j] is an obstacle, then paths(i, j) = 0.`

---

### **4. Three Approaches: Recursion, Memoization, and Tabulation**

The provided code demonstrates the standard progression for solving DP problems.

### **Approach 1: Simple Recursion**

This approach directly implements the recurrence relation. The code cleverly works backward from the destination, which is mathematically equivalent to working forward. It's intuitive but very slow due to re-computing the same subproblems.

* **Time Complexity:** $O(2^{m+n})$ - Exponential. In the worst case, every path is explored.
* **Space Complexity:** $O(m+n)$ for the recursion call stack depth.

### **Approach 2: Memoization (Top-Down DP)**

This is the optimized recursive solution. We use a `dp` table to store the number of paths for each cell `(i, j)` once it's calculated. If we need that value again, we just look it up instead of making new recursive calls.

* **Time Complexity:** $O(m \times n)$ - Linear in the size of the grid. Each cell's value is computed only once.
* **Space Complexity:** $O(m \times n)$ for the `dp` table + $O(m+n)$ for the recursion stack.

### **Approach 3: Tabulation (Bottom-Up DP)**

This iterative approach builds the solution from the start `(0, 0)` to the finish. It's often the most efficient method as it eliminates recursion overhead.

**Algorithm:**
1.  Create a `dp` table of size `m x n`, where `dp[i][j]` will store the number of unique paths to reach cell `(i, j)`.
2.  Initialize `dp[0][0] = 1` (if it's not an obstacle). There is one way to be at the starting cell.
3.  Iterate through the grid from top to bottom, left to right.
4.  For each cell `(i, j)`:
    * If `grid[i][j]` is an obstacle, set `dp[i][j] = 0`.
    * Otherwise, calculate `dp[i][j] = dp[i-1][j] + dp[i][j-1]`. (Handle boundary conditions for the first row and column, where paths can only come from one direction).
5.  The final answer is the value in the bottom-right cell, `dp[m-1][n-1]`.

* **Time Complexity:** $O(m \times n)$. We visit each cell of the grid once.
* **Space Complexity:** $O(m \times n)$. (This can be optimized to $O(n)$ because to compute the current row, you only need the values from the previous row).

---

### **5. Dry Run Example (Tabulation)**

**Input:** `grid = {{1, 1, 1}, {1, 0, 1}, {1, 1, 1}}`

**DP Table (`dp[i][j]`):**

1.  **Initialize:** 3x3 grid of 0s. Set `dp[0][0] = 1`.

2.  **Fill Row 0:**
    * `dp[0][1] = dp[0][0] = 1`
    * `dp[0][2] = dp[0][1] = 1`
    * **DP Table:** `[[1, 1, 1], [0, 0, 0], [0, 0, 0]]`

3.  **Fill Row 1:**
    * `dp[1][0] = dp[0][0] = 1`
    * `dp[1][1] = 0` (Obstacle)
    * `dp[1][2] = dp[0][2] + dp[1][1] = 1 + 0 = 1`
    * **DP Table:** `[[1, 1, 1], [1, 0, 1], [0, 0, 0]]`

4.  **Fill Row 2:**
    * `dp[2][0] = dp[1][0] = 1`
    * `dp[2][1] = dp[1][1] + dp[2][0] = 0 + 1 = 1`
    * `dp[2][2] = dp[1][2] + dp[2][1] = 1 + 1 = 2`
    * **DP Table:** `[[1, 1, 1], [1, 0, 1], [1, 1, 2]]`

5.  **Final Answer:** The value at `dp[2][2]` is **2**.

---

### **6. Code Implementation (Tabulation)**
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Recursive approach
    int uniquePathsRecursive(int row, int col, vector<vector<int>>& grid) {
        // Base cases
        if (row == 0 && col == 0) return 1;               // reached starting cell
        if (row < 0 || col < 0) return 0;                 // out of bounds
        if (grid[row][col] == 0) return 0;                // blocked cell (0 means obstacle)

        // Move up and left
        int upWard = uniquePathsRecursive(row - 1, col, grid);
        int leftWard = uniquePathsRecursive(row, col - 1, grid);

        return upWard + leftWard;
    }

    // Memoization approach
    int uniquePathsMemoization(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& dp) {
        if (row == 0 && col == 0) return 1;
        if (row < 0 || col < 0) return 0;
        if (grid[row][col] == 0) return 0;

        if (dp[row][col] != -1) return dp[row][col];

        int upWard = uniquePathsMemoization(row - 1, col, grid, dp);
        int leftWard = uniquePathsMemoization(row, col - 1, grid, dp);

        return dp[row][col] = upWard + leftWard;
    }

    // Tabulation approach
    int uniquePathsTabulation(int rows, int cols, vector<vector<int>>& grid) {
        vector<vector<int>> dp(rows, vector<int>(cols, 0));

        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < cols; col++) {
                if (grid[row][col] == 0) {
                    dp[row][col] = 0; // obstacle
                    continue;
                }

                if (row == 0 && col == 0) {
                    dp[row][col] = 1;
                } else {
                    int upWard = (row > 0) ? dp[row - 1][col] : 0;
                    int leftWard = (col > 0) ? dp[row][col - 1] : 0;
                    dp[row][col] = upWard + leftWard;
                }
            }
        }

        return dp[rows - 1][cols - 1];
    }
};

int main() {
    Solution obj;

    // 1 means path cell, 0 means obstacle
    vector<vector<int>> grid = {
        {1, 1, 1},
        {1, 0, 1},
        {1, 1, 1}
    };

    int rows = grid.size();
    int cols = grid[0].size();

    cout << "Using Recursion Only: "
         << obj.uniquePathsRecursive(rows - 1, cols - 1, grid) << endl;

    vector<vector<int>> dp(rows, vector<int>(cols, -1));
    cout << "Using Memoization: "
         << obj.uniquePathsMemoization(rows - 1, cols - 1, grid, dp) << endl;

    cout << "Using Tabulation: "
         << obj.uniquePathsTabulation(rows, cols, grid) << endl;

    return 0;
}
    << obj.findingMaximumPointsUsingMemoization(n - 1, 3, pointsTable, memoization) << endl;

    cout << "Using Tabulation: "
         << obj.findingMaximumPointsUsingTabulation(n, pointsTable) << endl;

    return 0;
}
```

---
### **7. Key Takeaways**

1.  **Grid DP Pattern:** The `dp[i][j] = dp[i-1][j] + dp[i][j-1]` transition is a fundamental pattern for grid traversal problems.
2.  **Handling Constraints:** Adding constraints like obstacles is often a simple matter of adding a condition (`if (obstacle) dp[i][j] = 0`) to the standard DP logic.
3.  **Equivalence of Approaches:** Notice how thinking forward (down/right moves in tabulation) and thinking backward (up/left moves in recursion) lead to the same recurrence relation and the same correct answer.