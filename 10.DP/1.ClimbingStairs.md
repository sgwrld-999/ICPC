## **Problem Name:** Climbing Stairs

**Problem Link:** [LeetCode](https://leetcode.com/problems/climbing-stairs/)

### **1. Problem Understanding**

We are given a staircase with **n** steps. Our goal is to reach the top. With each move, we can choose to climb either **1 step** or **2 steps**.

**Task:**
Calculate the total number of **distinct ways** we can climb to the top of the staircase.

**Example:**

  * `n = 2` → `Output: 2`
      * Ways: `1 step + 1 step` OR `2 steps`
  * `n = 3` → `Output: 3`
      * Ways: `1+1+1`, `1+2`, `2+1`

-----

### **2. When to Think of Dynamic Programming**

This problem is a perfect candidate for DP. Here's why:

1.  **Counting Problem:** The question asks for the "number of ways," which is a very common pattern in DP problems.
2.  **Optimal Substructure:** The total number of ways to climb `n` stairs is built upon the solutions for smaller numbers of stairs. The solution for `n` depends directly on the solutions for `n-1` and `n-2`.
3.  **Overlapping Subproblems:** If you draw the recursion tree for `climbStairs(5)`, you'll see that `climbStairs(3)` is calculated twice, `climbStairs(2)` is calculated three times, and so on. A naive recursive solution would be very slow because it re-computes the same values over and over. DP eliminates this redundant work.

-----

### **3. The Recurrence Relation (The "Why")**

Let's think about how we can arrive at the very last step, step `n`. There are only two possibilities for our final move:

  * We took a **single step** from step `n-1`.
  * We took a **double step** from step `n-2`.

There are no other ways to land exactly on step `n`. Therefore, the total number of ways to reach step `n` is the sum of the ways to reach step `n-1` and the ways to reach step `n-2`.

This gives us the famous **Fibonacci sequence** recurrence relation:
`ways(n) = ways(n-1) + ways(n-2)`

-----

### **4. Algorithm (Top-Down with Memoization)**

The provided code uses a top-down recursive approach with memoization.

**Step-by-step:**

1.  **Define a Recursive Function:** Create a helper function, `solve(n, dp)`, that will compute the number of ways to climb `n` stairs.
2.  **Base Cases:** Identify the simplest cases that can be solved directly.
      * If `n = 1`, there is only `1` way (a single 1-step move). Return `1`.
      * If `n = 2`, there are `2` ways (`1+1` or `2`). Return `2`.
3.  **Memoization Check:** Before any computation, check if the solution for `n` has already been calculated and stored in our `dp` array. If `dp[n]` is not the initial value (e.g., -1), it means we've solved this subproblem before. Return the stored value `dp[n]` immediately.
4.  **Recursive Step:** If the result is not in our memo, calculate it using the recurrence relation: `solve(n-1, dp) + solve(n-2, dp)`.
5.  **Store the Result:** Before returning the newly calculated value, store it in `dp[n]` so we don't have to compute it again.

-----

### **5. Complexity Analysis**

  * **Time Complexity:** $O(n)$
      * Without memoization, the complexity would be exponential ($O(2^n)$) due to repeated calculations.
      * With memoization, each subproblem `solve(i)` for `i` from `1` to `n` is computed exactly once.
  * **Space Complexity:** $O(n)$
      * This space is used by the `dp` vector to store the results and by the recursion call stack (which can go `n` levels deep).

-----

### **6. Code**

```cpp
class Solution {
public:
    // Recursive helper function with memoization
    int solve(int n, vector<int>& dp) {
        // Base cases: the simplest problems we can solve directly
        if (n == 2) return 2;
        if (n == 1) return 1;

        // Memoization check: if we've solved this before, return the stored answer
        if (dp[n] != -1) return dp[n];

        // Recursive step: apply the recurrence relation
        // Store the result before returning to avoid re-computation
        return dp[n] = solve(n - 1, dp) + solve(n - 2, dp);
    }

    int climbStairs(int n) {
        // Initialize a DP array to store results of subproblems.
        // -1 indicates the subproblem hasn't been solved yet.
        vector<int> dp(n + 1, -1);
        return solve(n, dp);
    }
};
```

-----

### **7. Dry Run Example**

**Input:** `n = 4`

1.  `climbStairs(4)` calls `solve(4, dp)`.
2.  `solve(4)` calls `solve(3, dp)` + `solve(2, dp)`.
3.  `solve(3)` is called first. It calls `solve(2, dp)` + `solve(1, dp)`.
      * `solve(2)` is a base case. It returns `2`. Let's store `dp[2] = 2`.
      * `solve(1)` is a base case. It returns `1`. Let's store `dp[1] = 1`.
      * `solve(3)` returns `2 + 1 = 3`. We store `dp[3] = 3`.
4.  Now, back in `solve(4)`, we need `solve(2, dp)`.
      * We check `dp[2]`. It's `2` (not -1)\! We immediately return `2` without any more recursive calls.
5.  `solve(4)` returns the final result: `dp[3]` (which is 3) + `dp[2]` (which is 2) = `5`.

 **Final Answer: 5**

-----

### **8. Key Takeaways**

1.  **Fibonacci in Disguise:** This problem is a classic example of how the Fibonacci sequence can appear in unexpected places. Recognizing the pattern is key.
2.  **Power of Memoization:** This example clearly demonstrates how memoization transforms an inefficient, exponential-time recursive solution into a highly efficient, linear-time one.
3.  **Top-Down vs. Bottom-Up:** While this solution is top-down (memoization), the same problem can be solved bottom-up (tabulation) by filling a `dp` array from `dp[1]` up to `dp[n]`, which avoids recursion entirely. You can even optimize the space to $O(1)$ by only storing the last two results.