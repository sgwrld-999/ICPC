## \#\# Problem Name: Partition Equal Subset Sum

**Problem Link:** [LeetCode](https://leetcode.com/problems/partition-equal-subset-sum/)

-----

## \#\# Problem Understanding

You're given an array of positive integers `nums`.

**Task:**
Determine if the array can be partitioned into two **subsets** such that the sum of elements in both subsets is equal.

**Example:**

  * `nums = [1, 5, 11, 5]`
  * **Output:** `true`
  * **Explanation:** The array can be partitioned into `{1, 5, 5}` (sum=11) and `{11}` (sum=11).

-----

## \#\# When to Think of Dynamic Programming

This problem might not immediately look like a standard DP problem, but it has all the key ingredients:

1.  **Subset Problem:** The question involves partitioning the set, which means you're creating subsets.
2.  **Pick/Not Pick:** For every number in the array, you must decide which of the two subsets it belongs to. This is a variation of the classic "pick/not pick" pattern.
3.  **Reducible Problem:** The core challenge can be simplified into a more standard DP problem, which is a common strategy.

-----

## \#\# The Core Idea: Reducing to Subset Sum

The problem asks if we can find two subsets, let's call them `S1` and `S2`, such that `sum(S1) = sum(S2)`.

Here's the key insight:

1.  Let the total sum of all elements in the array be `totalSum`.
2.  If `sum(S1) = sum(S2)`, then `sum(S1) + sum(S2) = 2 * sum(S1)`.
3.  We also know that `sum(S1) + sum(S2) = totalSum`.
4.  Therefore, `totalSum = 2 * sum(S1)`, which means `sum(S1) = totalSum / 2`.

This reveals two crucial things:

  * If `totalSum` is **odd**, it's impossible to divide it into two equal integer halves, so we can immediately return `false`.
  * If `totalSum` is **even**, the problem is transformed into: **"Can we find a single subset in the original array that sums up to `totalSum / 2`?"**

If we can find such a subset, the remaining elements are guaranteed to form the other subset with the same sum. This is the classic **Subset Sum Problem**.

-----

## \#\# The Recurrence Relation (for Subset Sum)

We use the "pick vs. not pick" logic. Let `solve(idx, target)` be a function that returns `true` if we can make the `target` sum using elements from the array up to index `idx`.

For any element `nums[idx]`, we have two choices:

1.  **Don't Pick:** We ignore `nums[idx]` and try to make the `target` using the remaining elements: `solve(idx - 1, target)`.
2.  **Pick:** We include `nums[idx]` and now need to make a new, smaller `target - nums[idx]` using the remaining elements: `solve(idx - 1, target - nums[idx])`.

If either choice returns `true`, then a solution exists.

-----

## \#\# Code (C++ with Memoization)

This C++ code directly translates the logic from the Java solution you provided. It uses a top-down, memoized DP approach.

```cpp
#include <vector>
#include <numeric> // For std::accumulate
#include <iostream>

class Solution {
private:
    // This is the recursive helper for the "Subset Sum" problem
    bool solve(int idx, int target, std::vector<int>& nums, std::vector<vector<int>>& dp) {
        // Base case 1: Target achieved
        if (target == 0) return true;
        
        // Base case 2: Only the first element is left to consider
        if (idx == 0) return (nums[0] == target);
        
        // If this state has been computed, return the stored result
        // 1 for true, 0 for false
        if (dp[idx][target] != -1) return dp[idx][target] == 1;

        // Choice 1: Don't pick the current element
        bool notTake = solve(idx - 1, target, nums, dp);

        // Choice 2: Pick the current element (if possible)
        bool take = false;
        if (target >= nums[idx]) {
            take = solve(idx - 1, target - nums[idx], nums, dp);
        }

        // Store the result before returning
        dp[idx][target] = (take || notTake) ? 1 : 0;
        return dp[idx][target] == 1;
    }

public:
    bool canPartition(std::vector<int>& nums) {
        // 1. Calculate the total sum
        int totalSum = std::accumulate(nums.begin(), nums.end(), 0);

        // 2. If the sum is odd, partitioning is impossible
        if (totalSum % 2 != 0) return false;

        // 3. The target for our subset sum is half of the total
        int target = totalSum / 2;
        int n = nums.size();

        // Initialize DP table: -1 means not computed
        std::vector<vector<int>> dp(n, std::vector<int>(target + 1, -1));

        // 4. Reduce the problem to finding a subset with the target sum
        return solve(n - 1, target, nums, dp);
    }
};
```

-----

## \#\# Complexity Analysis

Let `N` be the number of elements and `S` be the total sum of the array.

  * **Time Complexity:** $O(N \times S)$
      * The problem is reduced to subset sum with a target of `S/2`.
      * The DP state is `(index, target_sum)`, leading to $N \times (S/2)$ unique states. Each state is computed once.
  * **Space Complexity:** $O(N \times S)$ for the DP table + $O(N)$ for the recursion stack.

-----

## \#\# Dry Run Example

**Input:** `nums = [1, 5, 11, 5]`

1.  **`canPartition` starts:**

      * `totalSum` = 1 + 5 + 11 + 5 = 22.
      * `totalSum` is even.
      * `target` = 22 / 2 = 11.
      * Call `solve(3, 11, nums, dp)`.

2.  **`solve(3, 11)` (for element `5`):**

      * **Pick `5`:** Call `solve(2, 11-5)`, i.e., `solve(2, 6)`.
      * **Don't Pick `5`:** Call `solve(2, 11)`.

3.  **`solve(2, 11)` (for element `11`):**

      * **Pick `11`:** Call `solve(1, 11-11)`, i.e., `solve(1, 0)`.
      * `solve(1, 0)` hits the base case `target == 0` and returns `true`.
      * Since one of the paths returned `true`, the final result is `true`.

The function will eventually determine that the subset `{11}` or `{1, 5, 5}` can be formed to make the sum 11.

 **Final Answer:** **true**

-----

## \#\# Key Takeaways

1.  **Problem Reduction:** This is a prime example of how a seemingly complex problem can be reduced to a standard, foundational DP problem. Recognizing these transformations is a key skill.
2.  **Preprocessing is Powerful:** The initial step of calculating the sum and checking for odd/even parity is a simple but crucial optimization that can solve the problem instantly in 50% of cases.
3.  **Subset Sum is a Building Block:** The "pick/not pick" logic used here is the basis for many other DP problems, including the famous Knapsack problem.