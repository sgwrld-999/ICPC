## **Problem Name:** Cherry Pickup

**Problem Link:** [LeetCode](https://leetcode.com/problems/cherry-pickup/)

-----

## \#\# Problem Understanding

You're given an `n x n` grid representing a field of cherries. You have two people starting at the top-left corner `(0, 0)`. Their goal is to travel to the bottom-right corner `(n-1, n-1)`.

**The Rules:**

  * **Movement:** They can only move **right** or **down**.
  * **Cherries:** When a person passes through a cell, they pick up all the cherries (`grid[i][j]`).
  * **Shared Cells:** If both people are in the same cell at the same time, they pick up the cherries only **once**.
  * **Thorns:** A cell with `-1` is a thorn; no one can pass through it.
  * **Simultaneous Movement:** Both people must make a move at the same time.

**Task:**
Find the **maximum** total number of cherries the two people can collect together.

-----

## \#\# When to Think of Dynamic Programming

This problem screams DP, but with a twist:

1.  **Optimization Problem:** The goal is to find the **maximum** number of cherries.
2.  **Grid Traversal:** It's a pathfinding problem on a grid.
3.  **Complex State:** The challenge is that we need to track two paths simultaneously. This suggests that our DP state must contain information about both people's positions.

-----

## \#\# The Recurrence Relation & The 3D State Trick

A naive approach would be to track the position of both people independently, leading to a 4D state: `f(row1, col1, row2, col2)`. This is too slow ($O(N^4)$).

The key insight is that since both people start at the same time and make one move at a time, they will **always have taken the same number of steps**.

  * Steps for Person 1 = `row1 + col1`
  * Steps for Person 2 = `row2 + col2`

Therefore, `row1 + col1 = row2 + col2`.

This allows us to get rid of one variable. If we know `row1`, `col1`, and `row2`, we can always calculate `col2`:
`col2 = row1 + col1 - row2`

This reduces our state from 4D to a manageable **3D state**: `f(row1, col1, row2)`.

From this state, each person can move down or right, creating `2 x 2 = 4` possible combined moves for the next step. The recurrence is to take the current cherries and add the maximum result from these four future possibilities.

`f(r1, c1, r2) = current_cherries + max( f(next_r1, next_c1, next_r2) )`

-----

## \#\# Code for All Methods

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
private:
    int n; // Grid size

    // -------------------- Recursive Approach --------------------
    int solveUsingRecursion(vector<vector<int>>& grid, int r1, int c1, int r2) {
        int c2 = r1 + c1 - r2; // total steps taken are equal (r1+c1 == r2+c2)

        // Out of bounds or thorn
        if (r1 >= n || c1 >= n || r2 >= n || c2 >= n ||
            grid[r1][c1] == -1 || grid[r2][c2] == -1)
            return -1e9;

        // Destination reached
        if (r1 == n - 1 && c1 == n - 1)
            return grid[r1][c1];

        int cherries = (r1 == r2 && c1 == c2)
                           ? grid[r1][c1]
                           : grid[r1][c1] + grid[r2][c2];

        // Explore 4 possible move combinations
        int bestNext = max({
            solveUsingRecursion(grid, r1 + 1, c1, r2 + 1), // both down
            solveUsingRecursion(grid, r1 + 1, c1, r2),     // P1 down, P2 right
            solveUsingRecursion(grid, r1, c1 + 1, r2 + 1), // P1 right, P2 down
            solveUsingRecursion(grid, r1, c1 + 1, r2)      // both right
        });

        return cherries + bestNext;
    }

    // --------------------  Memoization Approach (Top-Down DP) --------------------
    int solveUsingMemoization(vector<vector<int>>& grid, int r1, int c1, int r2,
                                  vector<vector<vector<int>>>& dp) {
        int c2 = r1 + c1 - r2;

        // Out of bounds or thorn
        if (r1 >= n || c1 >= n || r2 >= n || c2 >= n ||
            grid[r1][c1] == -1 || grid[r2][c2] == -1)
            return -1e9;

        // Destination reached
        if (r1 == n - 1 && c1 == n - 1)
            return grid[r1][c1];

        // Already computed
        if (dp[r1][c1][r2] != -1)
            return dp[r1][c1][r2];

        int cherries = (r1 == r2 && c1 == c2)
                           ? grid[r1][c1]
                           : grid[r1][c1] + grid[r2][c2];

        // Explore 4 possible combinations
        int bestNext = max({
            solveUsingMemoization(grid, r1 + 1, c1, r2 + 1, dp),
            solveUsingMemoization(grid, r1 + 1, c1, r2, dp),
            solveUsingMemoization(grid, r1, c1 + 1, r2 + 1, dp),
            solveUsingMemoization(grid, r1, c1 + 1, r2, dp)
        });

        return dp[r1][c1][r2] = cherries + bestNext;
    }

    // -------------------- Tabulation Approach (Bottom-Up DP) --------------------
    int solveUsingTabulation(vector<vector<int>>& grid) {
        int n = grid.size();
        vector<vector<int>> dp(n, vector<int>(n, -1e9));
        dp[n - 1][n - 1] = grid[n - 1][n - 1];

        for (int k = 2 * n - 3; k >= 0; --k) {
            vector<vector<int>> newDp(n, vector<int>(n, -1e9));

            for (int r1 = max(0, k - (n - 1)); r1 <= min(n - 1, k); ++r1) {
                for (int r2 = max(0, k - (n - 1)); r2 <= min(n - 1, k); ++r2) {
                    int c1 = k - r1;
                    int c2 = k - r2;

                    if (c1 >= n || c2 >= n || grid[r1][c1] == -1 || grid[r2][c2] == -1)
                        continue;

                    int cherries = grid[r1][c1];
                    if (r1 != r2) cherries += grid[r2][c2];

                    int bestNext = -1e9;
                    for (int dr1 : {0, 1})
                        for (int dr2 : {0, 1}) {
                            int nr1 = r1 + dr1, nr2 = r2 + dr2;
                            if (nr1 < n && nr2 < n)
                                bestNext = max(bestNext, dp[nr1][nr2]);
                        }

                    newDp[r1][r2] = cherries + bestNext;
                }
            }
            dp = newDp;
        }

        return max(0, dp[0][0]);
    }

public:
    int cherryPickup(vector<vector<int>>& grid) {
        n = grid.size();

        //  Recursion only
        int recursionAns = max(0, solveUsingRecursion(grid, 0, 0, 0));

        // Memoization
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(n, -1)));
        int memoAns = max(0, solveUsingMemoization(grid, 0, 0, 0, dp));

        // Tabulation
        int tabAns = solveUsingTabulation(grid);

        cout << "Using Recursion Only: " << recursionAns << endl;
        cout << "Using Memoization:    " << memoAns << endl;
        cout << "Using Tabulation:     " << tabAns << endl;

        return tabAns; // final answer
    }
};
```

-----

## \#\# Complexity Analysis

  * **Recursive Approach:**

      * **Time Complexity:** $O(4^{N \times N})$. This is a loose upper bound, but it's exponential and too slow for larger grids.
      * **Space Complexity:** $O(N+N)$ for the recursion stack depth.

  * **Memoization Approach:**

      * **Time Complexity:** $O(N^3)$. We have three state variables (`r1`, `c1`, `r2`), each ranging from `0` to `N-1`. This gives us $N \times N \times N = N^3$ possible states. With memoization, each state is computed only once.
      * **Space Complexity:** $O(N^3)$ for the 3D `dp` table.

  * **Tabulation Approach:**

      * **Time Complexity:** $O(N^3)$. The loops iterate through all possible combinations of `k`, `r1`, and `r2`.
      * **Space Complexity:** $O(N^2)$. Although the logic seems 3D, the space is optimized by only keeping track of the results for the next step (`dp`) and the current step (`newDp`), which are 2D tables.

-----

## \#\# Key Takeaways

1.  **State Reduction is Key:** The most important lesson from this problem is how to reduce the dimensions of your DP state. Recognizing the `r1 + c1 = r2 + c2` relationship is what makes the problem solvable within time limits.
2.  **Synchronous Movement:** This problem is a great example of tracking multiple entities moving in lockstep. The "same number of steps" logic is a powerful technique for these scenarios.
3.  **3D DP:** This serves as an excellent introduction to problems that require more than the standard 2D `dp` table, pushing you to think more abstractly about what defines a subproblem's state.
4.  **Bottom-Up Complexity:** The tabulation approach for this problem is significantly more complex to reason about and implement correctly compared to the top-down memoized recursion, which maps more directly to the problem's logic.