## \#\# Problem Name: Cherry Pickup

**Problem Link:** [LeetCode \#741](https://leetcode.com/problems/cherry-pickup/)

-----

## \#\# Problem Understanding

You're given an `n x n` grid representing a field of cherries. The problem is described as one person making a round trip:

1.  **Trip 1 (Go):** Start at `(0, 0)`, travel to `(n-1, n-1)` by only moving **right** or **down**.
2.  **Trip 2 (Return):** Travel from `(n-1, n-1)` back to `(0, 0)` by only moving **left** or **up**.

**The Rules:**

  * **Cherries:** When you pass through a cell with a cherry (`1`), you pick it up, and the cell becomes empty (`0`).
  * **Thorns:** A cell with `-1` is a thorn; you cannot pass through it.

**Task:**
Find the **maximum** total number of cherries you can collect from the entire round trip.

-----

## \#\# The Key Insight: Round Trip vs. Two People

A round trip is hard to model. However, a path from `(n-1,n-1)` to `(0,0)` using only `up` and `left` moves is the exact mirror of a path from `(0,0)` to `(n-1, n-1)` using `down` and `right` moves.

This means the problem can be reframed: **Find the best pair of paths for two people starting at `(0,0)` and travelling to `(n-1, n-1)` simultaneously.** This is much easier to model with DP and is exactly what your code does.

-----

## \#\# The Recurrence Relation & The 3D State Trick

A naive DP state would be `f(row1, col1, row2, col2)`, tracking both people's positions. This is a 4D state and too slow.

The crucial optimization comes from observing that since both people move simultaneously, they will **always have taken the same number of steps**.

  * Steps for Person 1 = `row1 + col1`
  * Steps for Person 2 = `row2 + col2`
  * Therefore, `row1 + col1 = row2 + col2`.

This allows us to calculate `col2` if we know the other three variables: `col2 = row1 + col1 - row2`. This insight reduces the state from 4D to a manageable **3D state**: `f(row1, col1, row2)`.

From this state, each person can move down or right, creating `2 x 2 = 4` possible combined moves. The recurrence is to take the current cherries and add the maximum result from these four future possibilities.

`f(r1, c1, r2) = current_cherries + max( f(all four next states) )`

-----

## \#\# Code for All Methods

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
private:
    int n; // Grid size

    // --------------------  Recursive Approach --------------------
    int solveUsingRecursion(vector<vector<int>>& grid, int r1, int c1, int r2) {
        int c2 = r1 + c1 - r2; // Key insight: total steps are equal

        // Base Case 1: Out of bounds or hit a thorn
        if (r1 >= n || c1 >= n || r2 >= n || c2 >= n ||
            grid[r1][c1] == -1 || grid[r2][c2] == -1)
            return -1e9; // Return a very small number for an invalid path

        // Base Case 2: Destination reached
        if (r1 == n - 1 && c1 == n - 1)
            return grid[r1][c1];

        // Calculate cherries at the current step (count once if on the same cell)
        int cherries = (r1 == r2 && c1 == c2)
                           ? grid[r1][c1]
                           : grid[r1][c1] + grid[r2][c2];

        // Explore the 4 possible combined moves for the next step
        int bestNext = max({
            solveUsingRecursion(grid, r1 + 1, c1, r2 + 1), // Both Down
            solveUsingRecursion(grid, r1 + 1, c1, r2),     // P1 Down, P2 Right
            solveUsingRecursion(grid, r1, c1 + 1, r2 + 1), // P1 Right, P2 Down
            solveUsingRecursion(grid, r1, c1 + 1, r2)      // Both Right
        });

        // If all future paths are invalid, bestNext will be -1e9.
        // We only add it if it's a valid path.
        if (bestNext == -1e9) return -1e9;

        return cherries + bestNext;
    }

    // --------------------  Memoization Approach (Top-Down DP) --------------------
    int solveUsingMemoization(vector<vector<int>>& grid, int r1, int c1, int r2,
                                  vector<vector<vector<int>>>& dp) {
        int c2 = r1 + c1 - r2;

        if (r1 >= n || c1 >= n || r2 >= n || c2 >= n ||
            grid[r1][c1] == -1 || grid[r2][c2] == -1)
            return -1e9;

        if (r1 == n - 1 && c1 == n - 1)
            return grid[r1][c1];

        if (dp[r1][c1][r2] != -1)
            return dp[r1][c1][r2];

        int cherries = (r1 == r2 && c1 == c2)
                           ? grid[r1][c1]
                           : grid[r1][c1] + grid[r2][c2];

        int bestNext = max({
            solveUsingMemoization(grid, r1 + 1, c1, r2 + 1, dp),
            solveUsingMemoization(grid, r1 + 1, c1, r2, dp),
            solveUsingMemoization(grid, r1, c1 + 1, r2 + 1, dp),
            solveUsingMemoization(grid, r1, c1 + 1, r2, dp)
        });

        if (bestNext == -1e9) return dp[r1][c1][r2] = -1e9;

        return dp[r1][c1][r2] = cherries + bestNext;
    }

    // --------------------  Tabulation Approach (Bottom-Up DP) --------------------
    int solveUsingTabulation(vector<vector<int>>& grid) {
        int n = grid.size();
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(n, -1e9)));

        // Base case: set starting point
        dp[0][0][0] = grid[0][0];

        // Iterate through all possible steps (k = r+c)
        for (int k = 1; k < 2 * n - 1; ++k) {
            for (int r1 = 0; r1 < n; ++r1) {
                for (int r2 = 0; r2 < n; ++r2) {
                    int c1 = k - r1;
                    int c2 = k - r2;

                    if (c1 < 0 || c1 >= n || c2 < 0 || c2 >= n || grid[r1][c1] == -1 || grid[r2][c2] == -1) {
                        continue;
                    }

                    int cherries = (r1 == r2) ? grid[r1][c1] : grid[r1][c1] + grid[r2][c2];
                    
                    int prev_max = -1e9;
                    if (r1 > 0 && r2 > 0) prev_max = max(prev_max, dp[r1 - 1][c1][r2 - 1]);
                    if (r1 > 0 && c2 > 0) prev_max = max(prev_max, dp[r1 - 1][c1][r2]);
                    if (c1 > 0 && r2 > 0) prev_max = max(prev_max, dp[r1][c1 - 1][r2 - 1]);
                    if (c1 > 0 && c2 > 0) prev_max = max(prev_max, dp[r1][c1 - 1][r2]);

                    if (prev_max != -1e9) {
                        dp[r1][c1][r2] = cherries + prev_max;
                    }
                }
            }
        }
        return max(0, dp[n - 1][n - 1][n - 1]);
    }


public:
    int cherryPickup(vector<vector<int>>& grid) {
        n = grid.size();
        if (n == 0) return 0;
        
        // Using Memoization is the most intuitive DP approach here
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(n, -1)));
        return max(0, solveUsingMemoization(grid, 0, 0, 0, dp));
    }
};
```

-----

## \#\# Complexity Analysis

  * **Memoization Approach:**

      * **Time Complexity:** $O(N^3)$. We have three state variables (`r1`, `c1`, `r2`), each ranging from `0` to `N-1`. This gives us $N \times N \times N = N^3$ possible states. With memoization, each state is computed only once.
      * **Space Complexity:** $O(N^3)$ for the 3D `dp` table.

  * **Tabulation Approach:**

      * **Time Complexity:** $O(N^3)$. The loops iterate through all possible combinations of `k`, `r1`, and `r2`.
      * **Space Complexity:** $O(N^3)$. A space-optimized tabulation is possible but significantly more complex.

-----

## \#\# Key Takeaways

1.  **Reframe the Problem:** The most critical step was reframing the "go and return" trip into a "two people go" trip. This simplification makes the DP state much easier to manage.
2.  **State Reduction is Key:** The most important technical lesson is how to reduce the dimensions of your DP state. Recognizing the `r1 + c1 = r2 + c2` relationship is what makes the problem solvable within time limits.
3.  **Synchronous Movement:** This problem is a great example of tracking multiple entities moving in lockstep. The "same number of steps" logic is a powerful technique for these scenarios.
4.  **3D DP:** This serves as an excellent introduction to problems that require more than the standard 2D `dp` table, pushing you to think more abstractly about what defines a subproblem's state.