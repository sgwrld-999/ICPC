Of course. This is a foundational dynamic programming problem, and the code you've provided perfectly illustrates the different ways to solve it. Here are the detailed notes.

-----

## **Problem Name:** Unique Paths

**Problem Link:** [LeetCode](https://leetcode.com/problems/unique-paths/)

### **1. Problem Understanding**

Imagine a robot on an `m x n` grid. The robot starts at the top-left corner, `(0, 0)`, and its goal is to reach the bottom-right corner, `(m-1, n-1)`.

**The Rules:**

  * The robot can only move **down** or **right** at any point in time.

**Task:**
Calculate how many possible **unique paths** the robot can take to reach the destination.

-----

### **2. When to Think of Dynamic Programming**

This problem is a textbook example of when to use DP:

1.  **Grid Traversal:** The problem is set on a grid and involves finding paths, a classic DP scenario.
2.  **Counting Problem:** It asks "how many possible... paths," which signals a counting DP approach.
3.  **Optimal Substructure:** The number of paths to reach any cell `(i, j)` is built directly from the solutions for the cells just above and to the left of it.
4.  **Overlapping Subproblems:** A naive recursive solution would re-calculate the number of paths to the same cell multiple times. DP eliminates this redundancy.

-----

### **3. The Recurrence Relation (The "Why")**

The core logic is simple and elegant. To reach any cell `(i, j)`, the robot's last move must have been from one of two places:

  * From the cell above: `(i-1, j)`
  * From the cell to the left: `(i, j-1)`

Therefore, the total number of unique paths to `(i, j)` is the sum of the paths to these two preceding cells. This gives us the recurrence relation:

`paths(i, j) = paths(i-1, j) + paths(i, j-1)`

-----

### **4. Three Approaches: From Slow to Fast**

Your code perfectly captures the journey from a naive to an optimal solution.

#### **Approach 1: Simple Recursion**

This is a direct translation of the recurrence relation. It's easy to understand but computationally expensive due to recalculating the same subproblems.

  * **Time Complexity:** Exponential, $O(2^{m+n})$
  * **Space Complexity:** $O(m+n)$ for the recursion stack.

#### **Approach 2: Memoization (Top-Down DP)**

We enhance the recursive solution with a memory (`dp` table). Before computing the paths for a cell, we check if we've already done it. If so, we return the stored value.

  * **Time Complexity:** $O(m \times n)$, as each cell's value is computed only once.
  * **Space Complexity:** $O(m \times n)$ for the `dp` table + $O(m+n)$ for the recursion stack.

#### **Approach 3: Tabulation (Bottom-Up DP)**

This is the most common and often most efficient approach. We build the solution iteratively from the ground up, filling a `dp` table. `dp[i][j]` stores the number of ways to reach cell `(i, j)`.

  * **Time Complexity:** $O(m \times n)$. We iterate through the grid once.
  * **Space Complexity:** $O(m \times n)$. This can be optimized to $O(n)$ because we only need the previous row's data to compute the current row.

-----

### **5. Dry Run Example (Tabulation)**

Let's find the number of paths for a `3 x 3` grid (`m=3, n=3`).

**DP Table (`dp[i][j]`):**

1.  **Initialize:** Create a 3x3 `dp` table. Set `dp[0][0] = 1`.

2.  **Fill Row 0 and Col 0:** Every cell in the first row/column can only be reached in one way (all right moves or all down moves).

      * DP Table: `[[1, 1, 1], [1, 0, 0], [1, 0, 0]]`

3.  **Fill the Rest:**

      * `dp[1][1] = dp[0][1] + dp[1][0] = 1 + 1 = 2`
      * `dp[1][2] = dp[0][2] + dp[1][1] = 1 + 2 = 3`
      * `dp[2][1] = dp[1][1] + dp[2][0] = 2 + 1 = 3`
      * `dp[2][2] = dp[1][2] + dp[2][1] = 3 + 3 = 6`

4.  **Final DP Table:**

    ```
    [[1, 1, 1],
     [1, 2, 3],
     [1, 3, 6]]
    ```

 **Final Answer:** The value at `dp[2][2]` is **6**.

-----

### **6. Bonus: The Combinatorial Solution**

This specific problem also has a direct mathematical solution\! ðŸ’¡

To reach `(m-1, n-1)`, the robot must make a total of `(m-1)` **down** moves and `(n-1)` **right** moves. The total number of moves is `(m-1) + (n-1)`.

The problem then becomes: out of this total number of moves, how many ways can we choose where to place the `(m-1)` down moves? This is a classic combinatorics problem.

The answer is "N choose K": `C(Total Moves, Down Moves)`
`Answer = C((m-1 + n-1), (m-1))`

This can be calculated in $O(m)$ or $O(n)$ time, which is even faster than the DP solution.

-----
### **7. C++ code**

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
private:
    // Recursive approach
    int countPathsRecursive(int row, int col) {
        if (row == 0 && col == 0) return 1;   // Base case
        if (row < 0 || col < 0) return 0;     // Out of bounds

        int up = countPathsRecursive(row - 1, col);
        int left = countPathsRecursive(row, col - 1);

        return up + left;
    }

    // Memoization approach
    int countPathsMemo(int row, int col, vector<vector<int>>& dp) {
        if (row == 0 && col == 0) return 1;
        if (row < 0 || col < 0) return 0;

        if (dp[row][col] != -1) return dp[row][col];

        int up = countPathsMemo(row - 1, col, dp);
        int left = countPathsMemo(row, col - 1, dp);

        return dp[row][col] = up + left;
    }

public:
    // Function using recursion
    int uniquePathsUsingRecursion(int m, int n) {
        return countPathsRecursive(m - 1, n - 1);
    }

    // Function using memoization
    int uniquePathsUsingMemoization(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, -1));
        return countPathsMemo(m - 1, n - 1, dp);
    }

    // Tabulation approach
    int uniquePathsUsingTabulation(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 0));

        // Base case initialization
        for (int row = 0; row < m; row++) {
            for (int col = 0; col < n; col++) {
                if (row == 0 && col == 0)
                    dp[row][col] = 1;
                else {
                    int up = (row > 0) ? dp[row - 1][col] : 0;
                    int left = (col > 0) ? dp[row][col - 1] : 0;
                    dp[row][col] = up + left;
                }
            }
        }

        return dp[m - 1][n - 1];
    }
};

int main() {
    Solution obj;
    int m = 3, n = 7;

    cout << "Using Recursion: " << obj.uniquePathsUsingRecursion(m, n) << endl;
    cout << "Using Memoization: " << obj.uniquePathsUsingMemoization(m, n) << endl;
    cout << "Using Tabulation: " << obj.uniquePathsUsingTabulation(m, n) << endl;

    return 0;
}

```

----

### **8. Key Takeaways**

1.  **Fundamental Pattern:** This problem establishes the core `dp[i][j] = dp[i-1][j] + dp[i][j-1]` pattern, which is a building block for many other grid-based DP problems.
2.  **Optimization Path:** It's a perfect illustration of how to take a slow, brute-force recursive solution and optimize it using memoization or transform it into a more efficient iterative tabulation solution.
3.  **Multiple Perspectives:** Sometimes a problem that looks like a classic DP problem can also be solved from a completely different perspective, like mathematics and combinatorics.