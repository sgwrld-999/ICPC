## **Nearly Sorted Array**

### **1. Problem Understanding**

We are given:

* An array `arr[]` of size `n`.
* A value `k` such that the array is **k-nearly sorted**.

**Definition:**
An array is **k-nearly sorted** if each element is **at most k positions away** from its correct sorted position.

**Task:** Sort the array efficiently.

**Example:**

```
Input: arr[] = {6, 5, 3, 2, 8, 10, 9}, k = 3
Output: 2 3 5 6 8 9 10
```

---

### **2. When to Think of Heap**

Heap is useful because:

1. Each element is **at most k distance away** from its correct position.
2. So, **the smallest element in any window of size k+1 will be at the top**.
3. This allows us to extract elements in **sorted order** using a **Min Heap**.

---

### **3. Why Min Heap**

* Push elements into a **Min Heap** of size at most `k+1`.
* The top of the heap is **the smallest among the next k+1 elements** → which is the correct element to place next in the sorted array.
* Pop from the heap and append to the answer.

---

### **4. Algorithm**

**Step-by-step:**

1. Initialize a **Min Heap** and an empty result array `ans`.
2. Traverse the array:

   * Push each element into the heap.
   * If the heap size > k:

     * Pop the top element (smallest among current window) and append to `ans`.
3. After traversal, pop all remaining elements from the heap and append to `ans`.
4. Return `ans`.

---

### **5. Time Complexity**

* Each push/pop operation in heap: `O(log k)`
* We do this for `n` elements → **O(n log k)**
* Much faster than sorting entire array **O(n log n)** if `k << n`.

---

### **6. C++ Syntax for Min Heap**

```cpp
priority_queue<int, vector<int>, greater<int>> minHeap; // min heap
minHeap.push(x);    // insert
minHeap.pop();      // remove smallest
minHeap.top();      // get smallest
```

---

### **7. Code**

```cpp
class Solution {
public:
    vector<int> nearlySorted(int arr[], int num, int k) {
        priority_queue<int, vector<int>, greater<int>> minHeap; // min heap
        vector<int> ans;

        for (int i = 0; i < num; i++) {
            minHeap.push(arr[i]);
            if (minHeap.size() > k) {
                ans.push_back(minHeap.top());
                minHeap.pop();
            }
        }

        while (!minHeap.empty()) {
            ans.push_back(minHeap.top());
            minHeap.pop();
        }

        return ans;
    }
};
```

---

### **8. Dry Run Example**

**Input:**

```
arr = [6, 5, 3, 2, 8, 10, 9], k = 3
```

**Execution:**

```
Heap: []

Push 6 → [6]
Push 5 → [5, 6]
Push 3 → [3, 6, 5]
Push 2 → [2, 3, 5, 6] → size > k → pop 2 → ans = [2]
Push 8 → [3, 6, 5, 8] → pop 3 → ans = [2, 3]
Push 10 → [5, 6, 8, 10] → pop 5 → ans = [2, 3, 5]
Push 9 → [6, 9, 8, 10] → pop 6 → ans = [2, 3, 5, 6]

Remaining heap → pop 8, 9, 10 → ans = [2, 3, 5, 6, 8, 9, 10]
```

✅ **Final Answer:** `[2, 3, 5, 6, 8, 9, 10]`

---

### **9. Key Takeaways**

1. For a nearly sorted array, we **don’t need full sorting** → use a heap.
2. Heap size is always **k+1** to maintain the smallest element in current window.
3. Time complexity → **O(n log k)**
4. Space complexity → **O(k)**

---

