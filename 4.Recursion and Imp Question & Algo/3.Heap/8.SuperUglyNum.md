## **Problem Name:** Super Ugly Number

**Problem Link:** [LeetCode](https://leetcode.com/problems/super-ugly-number/)

---

### **Problem Statement**

A **super ugly number** is a positive number whose prime factors are in the given prime list `primes`.

Given an integer `n` and a list of prime numbers `primes`, return the `n`-th super ugly number.

**Example:**

```
Input: n = 12, primes = [2,7,13,19]
Output: 32
Explanation: The sequence of super ugly numbers: 
[1,2,4,7,8,13,14,16,19,26,28,32]
```

---

### **Intuition**

* This is a generalization of the **Ugly Number II** problem, where ugly numbers only have factors 2, 3, 5.
* We can use **dynamic programming + multiple pointers** to generate numbers in increasing order.
* Keep track of the next multiple for each prime to generate new super ugly numbers.

---

### **Approach (DP + Heap / Multiple Pointers)**

#### **Variables**

1. `ugly`: array to store super ugly numbers in order.
2. `idx`: array of pointers, one for each prime, pointing to the current position in `ugly` array.
3. `nextMultiple`: array to store next multiple for each prime.

#### **Steps**

1. Initialize:

   ```
   ugly[0] = 1
   idx[i] = 0 for all primes
   nextMultiple[i] = primes[i]
   ```
2. For each position from 1 to n-1:

   * Find `nextUgly = min(nextMultiple)`
   * Append `nextUgly` to `ugly`
   * Update `nextMultiple[i]` if it contributed to `nextUgly`:

     ```
     idx[i]++
     nextMultiple[i] = primes[i] * ugly[idx[i]]
     ```
3. Return `ugly[n-1]`

---

### **Dry Run Example**

```
n = 12, primes = [2,7,13,19]
```

| Step | Ugly Numbers                      | nextMultiple for \[2,7,13,19] | min |
| ---- | --------------------------------- | ----------------------------- | --- |
| 0    | \[1]                              | \[2,7,13,19]                  | 2   |
| 1    | \[1,2]                            | \[4,7,13,19]                  | 4   |
| 2    | \[1,2,4]                          | \[8,7,13,19]                  | 7   |
| 3    | \[1,2,4,7]                        | \[8,14,13,19]                 | 8   |
| 4    | \[1,2,4,7,8]                      | \[16,14,13,19]                | 13  |
| 5    | \[1,2,4,7,8,13]                   | \[16,14,26,19]                | 14  |
| 6    | \[1,2,4,7,8,13,14]                | \[16,28,26,19]                | 16  |
| 7    | \[1,2,4,7,8,13,14,16]             | \[32,28,26,19]                | 19  |
| 8    | \[1,2,4,7,8,13,14,16,19]          | \[32,28,26,38]                | 26  |
| 9    | \[1,2,4,7,8,13,14,16,19,26]       | \[32,28,52,38]                | 28  |
| 10   | \[1,2,4,7,8,13,14,16,19,26,28]    | \[32,56,52,38]                | 32  |
| 11   | \[1,2,4,7,8,13,14,16,19,26,28,32] | ...                           | ... |

**Output:** 32

---

### **Code**

```cpp
class Solution {
public:
    int nthSuperUglyNumber(int n, vector<int>& primes) {
        int k = primes.size();
        vector<int> ugly(n);
        vector<int> idx(k, 0);
        vector<int> nextMultiple = primes;

        ugly[0] = 1;

        for(int i = 1; i < n; i++){
            int nextUgly = *min_element(nextMultiple.begin(), nextMultiple.end());
            ugly[i] = nextUgly;

            for(int j = 0; j < k; j++){
                if(nextMultiple[j] == nextUgly){
                    idx[j]++;
                    nextMultiple[j] = primes[j] * ugly[idx[j]];
                }
            }
        }

        return ugly[n-1];
    }
};
```

---

### **Time Complexity**

* Each step: `O(k)` to find min and update multiples.
* Total steps: `n`
* **Overall:** `O(n * k)`

---

### **Space Complexity**

* `ugly` array: `O(n)`
* `idx` and `nextMultiple` arrays: `O(k)`
* **Overall:** `O(n + k)`

---

### **Key Takeaways**

* Multiple pointers + dynamic programming is the standard way to generate **ordered sequences with given multiples**.
* Similar to **Ugly Number II**, but generalized for arbitrary prime factors.
* Efficiently generates numbers without generating duplicates.

---

