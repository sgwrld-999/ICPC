## **K Largest Elements**

### **1. Problem Understanding**

We are given:

* An array of `n` integers.
* An integer `k`.

We need to find the **k largest elements** in the array.

---

### **2. When to Think of Heap**

A problem is often a heap problem if:

1. It asks for **K smallest/largest** elements or the **K-th smallest/largest** element.
2. Sorting the entire array is possible but not optimal.
3. We can optimize from **O(n log n)** to **O(n log k)**.

---

### **3. Why Min Heap for K Largest?**

* We want to keep **only the largest k elements** in memory at any time.
* If we keep them in a **Min Heap**, the **smallest** among these k elements will always be at the top.
* This allows us to:

  * Quickly remove elements that are **smaller than needed**.
  * Ensure the top of the heap always represents the **smallest among the largest k**, so we can maintain exactly k largest elements.

---

### **4. Algorithm**

**Step-by-step:**

1. Create a **Min Heap** (priority queue with `greater<int>` in C++).
2. Traverse the array:

   * Push each element into the heap.
   * If heap size > k â†’ pop the smallest element (min heap top).
3. After traversal, the heap contains the **k largest elements**.
4. Pop all elements from the heap to get the answer.

---

### **5. Time Complexity**

* **Push** into heap: `O(log k)`
* We do this for `n` elements â†’ **O(n log k)** total.
* Better than sorting the entire array **O(n log n)** if `k << n`.

---

### **6. C++ Syntax for Min Heap**

```cpp
priority_queue<int, vector<int>, greater<int>> minHeap; // min heap
minHeap.push(x);    // insert
minHeap.pop();      // remove smallest
minHeap.top();      // get smallest
```

---

### **7. Code**

```cpp
class Solution {
public:
    vector<int> kLargestElement(vector<int>& inputVector, int k, int n) {
        priority_queue<int, vector<int>, greater<int>> minHeap; // min heap
        vector<int> ans;

        for (int i = 0; i < n; i++) {
            minHeap.push(inputVector[i]);
            if (minHeap.size() > k) {
                minHeap.pop();
            }
        }

        while (!minHeap.empty()) {
            ans.push_back(minHeap.top());
            minHeap.pop();
        }

        return ans;
    }
};
```

---

### **8. Dry Run Example**

**Input:**

```
n = 6, k = 3
Array = [7, 10, 4, 3, 20, 15]
```

**Execution:**

```
Heap: []

Push 7 â†’ [7]
Push 10 â†’ [7, 10]
Push 4 â†’ [4, 10, 7]
Heap size > 3? No

Push 3 â†’ [3, 4, 7, 10] â†’ pop 3 â†’ [4, 10, 7]
Push 20 â†’ [4, 10, 7, 20] â†’ pop 4 â†’ [7, 10, 20]
Push 15 â†’ [7, 10, 20, 15] â†’ pop 7 â†’ [10, 15, 20]

End â†’ Heap contains [10, 15, 20] (3 largest elements)
```

---

âœ… **Final Answer:** **\[10, 15, 20]**
ðŸ“Œ **Key takeaway:** Keep only the largest k numbers â†’ use Min Heap.

---
