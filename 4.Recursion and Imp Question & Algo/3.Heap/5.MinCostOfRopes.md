## **Problem Name:** Minimum Cost of Connecting Ropes

**Problem Link:** [GeeksforGeeks](https://practice.geeksforgeeks.org/problems/minimum-cost-of-ropes-1587115620/1)

---

### **Problem Statement**

Given `n` ropes of different lengths, you need to connect all the ropes into one rope.

* The cost of connecting two ropes is equal to the **sum of their lengths**.
* You need to **connect all ropes with minimum total cost**.

**Example:**

```
Input: arr = [4, 3, 2, 6]
Output: 29

Explanation:
Step 1: Connect 2 + 3 = 5 → new array: [4, 5, 6], cost = 5
Step 2: Connect 4 + 5 = 9 → new array: [9, 6], cost = 5 + 9 = 14
Step 3: Connect 9 + 6 = 15 → new array: [15], cost = 14 + 15 = 29
```

---

### **Intuition / Approach**

* To minimize the cost, **always connect the two smallest ropes first**.
* This is because connecting large ropes early increases the total cost unnecessarily.
* **Greedy Approach:** Use a **min-heap (priority queue)** to efficiently get the two smallest ropes at each step.

---

### **Step-by-Step Approach**

1. **Insert all ropes into a min-heap.**
2. Initialize `totalCost = 0`.
3. While heap size > 1:

   1. Pop the two smallest ropes `first` and `second`.
   2. Calculate `currentCost = first + second`.
   3. Add `currentCost` to `totalCost`.
   4. Push the combined rope (`currentCost`) back into the heap.
4. Return `totalCost`.

---

### **Dry Run Example**

Input: `arr = [4, 3, 2, 6]`

1. **Initial min-heap:** `[2, 3, 4, 6]`
2. **Step 1:**

   * Pop 2 and 3 → sum = 5
   * Push 5 → heap = `[4, 6, 5]`
   * Total cost = 5
3. **Step 2:**

   * Pop 4 and 5 → sum = 9
   * Push 9 → heap = `[6, 9]`
   * Total cost = 5 + 9 = 14
4. **Step 3:**

   * Pop 6 and 9 → sum = 15
   * Push 15 → heap = `[15]`
   * Total cost = 14 + 15 = 29

**Answer:** 29

---

### **Time Complexity**

* Building heap: `O(n)`
* Each operation: pop + push → `O(log n)`
* Total operations: `n-1`
* **Total Time Complexity:** `O(n log n)`

### **Space Complexity**

* Using a min-heap → `O(n)`

---

### **Code**

```cpp
class Solution
{
    public:
    long long minCost(long long arr[], long long n) {
        priority_queue<long long, vector<long long>, greater<long long>> pq(arr, arr + n);
        long long totalCost = 0;

        while(pq.size() > 1) {
            long long first = pq.top(); pq.pop();
            long long second = pq.top(); pq.pop();
            long long currentCost = first + second;
            totalCost += currentCost;
            pq.push(currentCost);
        }

        return totalCost;
    }
};
```

---

✅ **Key Takeaways**

* Always combine the **two smallest elements first** to minimize the cost.
* Min-heap is perfect for efficiently retrieving smallest elements.
* This is a classic **Greedy + Heap** problem.

---

