# **Heap – Complete Notes**

## **1. Introduction**

* **Heap** is a **complete binary tree** where:

  * Every level is completely filled except possibly the last.
  * Nodes are filled **from left to right**.
* It follows the **Heap Property**:

  * **Max-Heap**: Every parent node ≥ its children.
  * **Min-Heap**: Every parent node ≤ its children.

---

## **2. Why Heap?**

* Efficient way to get **minimum** or **maximum** element.
* Operations like insert, delete, extract-min/max work in **O(log n)**.
* Helps when:

  1. Repeatedly fetching smallest/largest element.
  2. Maintaining *k* smallest/largest elements.
  3. Implementing Priority Queues.
  4. Optimizing from **O(n log n)** sorting to **O(n log k)**.

---

## **3. Types of Heaps**

1. **Min Heap** – root is smallest, children larger.
2. **Max Heap** – root is largest, children smaller.
3. **Binary Heap** – implemented using arrays.
4. **Other Heaps** – Fibonacci Heap, Binomial Heap (used in special algorithms like Dijkstra’s).

---

### **4. Introduction to Identifying Heap Problems**

A problem often calls for a **Heap** (Priority Queue) if:

1. **Repeated sorting-like behavior**

   * The problem repeatedly asks for smallest/largest elements after updates.
   * Example: Continuously pick the next largest number in a sequence.

2. **Find *k*-th smallest/largest (or min/max)**

   * Example: Find the 3rd largest score, smallest *k* elements, etc.

3. **Optimization from O(n log n) → O(n log k)**

   * If you only need *k* items instead of all *n*, a heap reduces sorting overhead.
   * Example: Maintaining top *k* scores while reading a stream.

---

## **5. Array Representation**

For a node at index `i` (0-based):

* **Parent**: `(i - 1) / 2`
* **Left Child**: `2*i + 1`
* **Right Child**: `2*i + 2`

---

## **6. Basic Operations**

| Operation       | Time Complexity |
| --------------- | --------------- |
| Insert          | O(log n)        |
| Extract Min/Max | O(log n)        |
| Peek Min/Max    | O(1)            |
| Heapify         | O(log n)        |
| Build Heap      | O(n)            |

---

## **7. Heap in C++**

In C++, `priority_queue` from `<queue>` is used.

### **Max-Heap (default)**

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    priority_queue<int> pq; // Max-heap

    pq.push(10);
    pq.push(30);
    pq.push(20);

    cout << pq.top() << "\n"; // 30 (largest element)

    pq.pop(); // Removes 30
    cout << pq.top() << "\n"; // 20
}
```

### **Min-Heap**

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    priority_queue<int, vector<int>, greater<int>> pq; // Min-heap

    pq.push(10);
    pq.push(30);
    pq.push(20);

    cout << pq.top() << "\n"; // 10 (smallest element)

    pq.pop(); // Removes 10
    cout << pq.top() << "\n"; // 20
}
```

---

## **8. Heapify (Building Heap)**

* **Heapify**: Convert an array into a heap.
* C++ provides `make_heap`, `push_heap`, `pop_heap`.

Example:

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v = {10, 20, 30, 5, 15};

    make_heap(v.begin(), v.end()); // Max-heap
    cout << v.front() << "\n"; // 30

    pop_heap(v.begin(), v.end());
    v.pop_back();
}
```

---

## **9. When to Use Heap**

✅ Pick heap if:

* Need **fast access** to min/max repeatedly.
* Need **top K** elements from a stream.
* Problem says **“k-th largest/smallest”**.
* Need **priority scheduling** (like CPU tasks, Dijkstra’s).

---

## **10. Complexity Recap**

| Task            | Min/Max Heap |
| --------------- | ------------ |
| Insertion       | O(log n)     |
| Extract Min/Max | O(log n)     |
| Peek            | O(1)         |
| Build Heap      | O(n)         |

---

## **11. Example Problem – Kth Largest Element**

```cpp
int findKthLargest(vector<int>& nums, int k) {
    priority_queue<int, vector<int>, greater<int>> minHeap;

    for (int num : nums) {
        minHeap.push(num);
        if (minHeap.size() > k) minHeap.pop();
    }
    return minHeap.top();
}
```

**Idea**: Keep heap size `k`, smallest at top.

---

## **12. Dry Run for Min-Heap (Example above)**

**Input:** nums = \[3,2,1,5,6,4], k=2
Heap steps:

1. push 3 → \[3]
2. push 2 → \[2,3]
3. push 1 → pop 1 → \[2,3]
4. push 5 → pop 2 → \[3,5]
5. push 6 → pop 3 → \[5,6]
6. push 4 → pop 4 → \[5,6]

**Answer:** `5` (2nd largest)

---
