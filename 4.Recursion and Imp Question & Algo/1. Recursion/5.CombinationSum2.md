## **Combination Sum II: Handling Duplicates**

This problem is a follow-up to "Combination Sum," with two key twists: the input array can contain duplicates, and each number can be used only once.

-----

### **1. Problem Understanding**

We are given:

  * An array of integers, `candidates`, which may contain **duplicates**.
  * A target integer, `target`.

**Task:**
Find all **unique combinations** of numbers from `candidates` that sum up to `target`.

**Key Rules:**

1.  Each number in the `candidates` array may be used **only once** in each combination.
2.  The final list of combinations must not contain duplicates.

**Example:**

```
Input: candidates = [10, 1, 2, 7, 6, 1, 5], target = 8
Sorted Input: [1, 1, 2, 5, 6, 7, 10]
Output: [ [1, 1, 6], [1, 2, 5], [1, 7], [2, 6] ]
```

Notice that even though `1` appears twice in the input, the combination `[1, 7]` is only included once in the output.

-----

### **2. The Core Challenge: Avoiding Duplicate Combinations**

The main difficulty comes from the duplicate numbers in the input. A naive backtracking approach might generate the same combination multiple times. For an input like `[1a, 1b, 2]` with `target = 3`, a simple approach could generate `[1a, 2]` and `[1b, 2]`, which are duplicates. Our goal is to generate just `[1, 2]` once.

-----

### **3. Strategies for Handling Duplicates**

There are two common ways to solve this, both of which require **sorting the input array** as the first step.

#### **Approach 1: Brute-Force with a `set`**

This is the most straightforward way.

1.  Use a standard "Pick / Not Pick" recursive approach to generate every possible combination that sums to the target.
2.  Store all valid combinations in a `std::set`. The `set` data structure will automatically discard any duplicate combinations.
3.  Finally, convert the `set` back into a `vector` to return.

<!-- end list -->

  * **Pros:** Easy to understand and implement.
  * **Cons:** Can be slow. Inserting a vector into a `set` takes time (`O(k * logN)`, where `k` is the vector length and `N` is the set size), and we might generate many redundant combinations that are ultimately thrown away.

#### **Approach 2: Optimized Recursion (The Elegant Way)**

This approach is more efficient because it avoids generating duplicate combinations from the start.

1.  **Sort the `candidates` array.**
2.  Use a recursive helper function that iterates through the candidates.
3.  **The Key Trick:** When we are about to pick an element, we check if it's the same as the previous element. If it is, and we are not at the beginning of the consideration for the current recursion level, we **skip** it.

This prevents the algorithm from starting new recursive paths with the same number at the same decision level, effectively cutting off all redundant branches of the search.

-----

### **4. Algorithm Breakdown (Optimized Approach)**

Let's focus on the more efficient, second approach.

1.  **Sort** the `candidates` array. This is essential because it groups all duplicate numbers together.
2.  Define a recursive function, `find(index, target, currentCombination)`.
3.  **Base Case:** If `target` becomes `0`, we have found a valid combination. Add it to the results and return.
4.  Iterate through the candidates using a `for` loop starting from `index`.
5.  **Skip Duplicates:** This is the magic line.
    ```cpp
    if (i > index && candidates[i] == candidates[i - 1]) continue;
    ```
    This means "if this is not the first element I'm considering at this level (`i > index`), and it's the same as the previous element I considered, then skip it."
6.  **Prune Search:** If `candidates[i] > target`, we can `break` the loop. Since the array is sorted, all subsequent candidates will also be too large.
7.  **Recurse (Pick):**
      * Add `candidates[i]` to `currentCombination`.
      * Call the recursive function for the next index: `find(i + 1, ...)`. We use `i + 1` to ensure each element is used only once.
8.  **Backtrack:** Remove `candidates[i]` from `currentCombination` so it's clean for the next iteration of the loop.

-----

### **5. Code with Comments**

Here are the two solutions. `Solution2` is the optimized approach and is generally preferred.

#### **Approach 1: Brute-Force with `set`**

```cpp
class Solution {
public:
    void findCombinations(int index, int target, vector<int>& candidates, set<vector<int>>& results, vector<int>& currentCombination) {
        if (index == candidates.size()) {
            if (target == 0) {
                // Insert into set to handle uniqueness automatically
                results.insert(currentCombination);
            }
            return;
        }
        // Pick the element (if possible)
        if (candidates[index] <= target) {
            currentCombination.push_back(candidates[index]);
            // Move to next index because we can't reuse this element
            findCombinations(index + 1, target - candidates[index], candidates, results, currentCombination);
            currentCombination.pop_back(); // Backtrack
        }
        // Not pick the element
        findCombinations(index + 1, target, candidates, results, currentCombination);
    }

    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        set<vector<int>> results;
        vector<int> currentCombination;
        findCombinations(0, target, candidates, results, currentCombination);
        // Convert set to vector for final output
        return vector<vector<int>>(results.begin(), results.end());
    }
};
```

#### **Approach 2: Optimized Recursion (Recommended)**

```cpp
class Solution2 {
public:
    void findCombinations(int index, int target, vector<int>& candidates, vector<vector<int>>& results, vector<int>& currentCombination) {
        // Base case: a valid combination is found
        if (target == 0) {
            results.push_back(currentCombination);
            return;
        }

        // Iterate through the candidates starting from the current index
        for (int i = index; i < candidates.size(); i++) {
            // THE KEY: Skip duplicates. If this is not the first element at this level,
            // and it's the same as the previous one, skip it.
            if (i > index && candidates[i] == candidates[i - 1]) continue;

            // Pruning: if the current candidate is too large, stop.
            if (candidates[i] > target) break;

            // Pick, Recurse, Backtrack
            currentCombination.push_back(candidates[i]);
            findCombinations(i + 1, target - candidates[i], candidates, results, currentCombination);
            currentCombination.pop_back();
        }
    }

    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        vector<vector<int>> results; // No set needed!
        vector<int> currentCombination;
        findCombinations(0, target, candidates, results, currentCombination);
        return results;
    }
};
```

-----

### **6. Key Takeaways**

  * This problem is a great example of how to adapt a standard backtracking algorithm to handle constraints like duplicates.
  * **Sorting the input** is almost always the first step in problems involving duplicate elements and combinations.
  * The optimized approach of skipping duplicates within the recursion (`if (i > index && ... )`) is a powerful and common pattern that is more efficient than using a `set`. It avoids generating redundant work altogether.