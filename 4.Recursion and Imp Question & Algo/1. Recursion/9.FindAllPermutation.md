## **Finding All Permutations of a String**

Generating permutations is a classic combinatorial problem that asks for all possible orderings of a given set of items. It's a fundamental problem that serves as a great introduction to more complex backtracking scenarios.

-----

### **1. Problem Understanding**

We are given:

  * A string `S` containing **unique** characters.

**Task:**
The goal is to generate a list of all possible arrangements (permutations) of the characters in `S`.

**Example:**

```
Input: S = "ABC"

Output: ["ABC", "ACB", "BAC", "BCA", "CAB", "CBA"]
```

For a string of length **n**, there are always **n\!** (n-factorial) permutations. For `n=3`, this is `3 * 2 * 1 = 6`.

-----

### **2. Core Technique: Recursion & Backtracking**

Permutation is all about making a sequence of choices:

1.  Which character should I place in the first position?
2.  From the remaining characters, which one should I place second?
3.  And so on...

This sequence of choices is a perfect fit for a **recursive** solution. We build a permutation character by character. After we explore all possibilities stemming from one choice, we must "undo" that choice to explore others. This "undoing" step is called **backtracking**.

The general idea is:

  * **Choose**: Pick an available character.
  * **Explore**: Recursively find all permutations for the remaining characters.
  * **Un-choose**: Backtrack by making the character available again.

-----

### **3. Algorithm Breakdown (Frequency Map Approach)**

The provided code uses a map to keep track of which characters have been used in the current permutation being built.

1.  **State Management**: Use an auxiliary data structure (the code uses a `map<char, bool>`) to mark characters as "visited" or "not visited".
2.  **Base Case**: The recursion stops when the permutation we are building (`storeVec`) has the same length as the original string `S`. At this point, we have a complete, valid permutation, so we add it to our list of answers.
3.  **Recursive Step**:
      * Iterate through **all characters** of the original string `S` from beginning to end.
      * For each character `S[i]`, check if it has been visited (i.e., if it's already in our current permutation).
      * If `S[i]` has **not** been visited:
          * **Choose**: Add `S[i]` to our `storeVec` and mark it as visited in the map.
          * **Explore**: Make a recursive call to continue building the permutation from this new state.
          * **Un-choose (Backtrack)**: After the recursive call returns, **remove `S[i]`** from `storeVec` and **un-mark it** in the map. This is the most critical step, as it allows `S[i]` to be used in a different position in another permutation.

-----

### **4. Common Patterns for Permutation Problems**

This problem showcases a few important patterns in recursion and backtracking.

  * **Stateful Recursion**: The recursive function needs to know which elements have already been used. There are two primary patterns for managing this state:

    1.  **Using a Frequency/Visited Map (as in this code)**: An external map or boolean array tracks usage. This is intuitive and works well for problems where the input can have duplicates.
    2.  **The Swapping Pattern (More Space-Efficient)**: This is a clever alternative that avoids the extra space of a map. The idea is to generate permutations in place. For a given index `idx`, you iterate from `idx` to the end of the array. In each iteration, you `swap` the element with the one at `idx`, recurse for `idx + 1`, and then **swap back** to backtrack. This is a very common and efficient pattern for permutation generation.

  * **"For Loop" in Recursion**: The pattern of using a `for` loop inside a recursive function is very common for problems where you need to make a choice from a collection of items at each step (like permutations and some combination problems).

-----

### **5. Time and Space Complexity**

  * **Time Complexity: `O(n! * n)`**

      * There are `n!` permutations to generate. This is the dominant factor.
      * For each of the `n!` permutations, we perform `O(n)` work. This work comes from the `for` loop inside the recursion and the final step of creating a string from the character vector.

  * **Space Complexity: `O(n)`**

      * This is the auxiliary space required. It consists of `O(n)` for the recursion stack depth and `O(n)` for the data structures used to store the current state (`storeVec` and the map). This does not include the `O(n! * n)` space needed to store the final answer.

-----

### **6. Code with Comments**

```cpp
#include<bits/stdc++.h>
using namespace std;

class Solution {
public:
    // The recursive helper function
    void recursion(const string &S, vector<string> &ans, vector<char> &currentPermutation, map<char, bool> &visited, int sizeOfString) {
        // Base Case: If the current permutation is complete
        if (currentPermutation.size() == sizeOfString) {
            // Convert char vector to string and add to results
            string result(currentPermutation.begin(), currentPermutation.end());
            ans.push_back(result);
            return;
        }

        // Iterate through ALL original characters to decide which one to place next
        for (int i = 0; i < sizeOfString; i++) {
            // If the character S[i] has not been used yet...
            if (!visited[S[i]]) {
                // --- Choose ---
                visited[S[i]] = true; // Mark as visited
                currentPermutation.push_back(S[i]); // Add to current permutation

                // --- Explore ---
                recursion(S, ans, currentPermutation, visited, sizeOfString);

                // --- Un-choose (Backtrack) ---
                // After exploring, undo the choice to allow other possibilities
                currentPermutation.pop_back();
                visited[S[i]] = false;
            }
        }
    }

    vector<string> find_permutation(string S) {
        // Map to track which characters are already in the current permutation
        map<char, bool> visited;
        // Vector to store the final list of permutations
        vector<string> ans;
        // Vector to build the current permutation character by character
        vector<char> currentPermutation;

        // Start the recursive process
        recursion(S, ans, currentPermutation, visited, S.length());
        return ans;
    }
};
```

-----

### **7. Dry Run Visualization (`S = "ABC"`)**

Let's trace the first couple of steps to see the Choose-Explore-Unchoose pattern.

`f(perm=[])`

1.  **Loop `i=0` ('A')**: `visited['A']` is false.
      * **Choose 'A'**: `perm=['A']`, `visited['A']=true`.
      * **Explore**: Call `f(perm=['A'])`.
        1.  **Loop `i=0` ('A')**: `visited['A']` is true. Skip.
        2.  **Loop `i=1` ('B')**: `visited['B']` is false.
              * **Choose 'B'**: `perm=['A', 'B']`, `visited['B']=true`.
              * **Explore**: Call `f(perm=['A', 'B'])`.
                1.  ... eventually finds 'C', forms "ABC".
                2.  **Base Case Hit**: `ans.push_back("ABC")`. Returns.
              * **Un-choose 'B'**: `perm=['A']`, `visited['B']=false`.
        3.  **Loop `i=2` ('C')**: `visited['C']` is false.
              * **Choose 'C'**: `perm=['A', 'C']`, `visited['C']=true`.
              * **Explore**: Call `f(perm=['A', 'C'])`. -\> finds "ACB".
              * **Un-choose 'C'**: `perm=['A']`, `visited['C']=false`.
        4.  Loop ends. Returns.
      * **Un-choose 'A'**: `perm=[]`, `visited['A']=false`.
2.  **Loop `i=1` ('B')**: `visited['B']` is false.
      * **Choose 'B'**: `perm=['B']`, `visited['B']=true`.
      * **Explore**: Call `f(perm=['B'])`. -\> finds "BAC" and "BCA".
      * **Un-choose 'B'**: `perm=[]`, `visited['B']=false`.
3.  **Loop `i=2` ('C')**: ...and so on.

-----

### **8. Key Takeaways**

  * Permutations are a classic application of recursion and backtracking.
  * The essence of the solution is managing the "used" state of elements to ensure each one appears exactly once in every permutation.
  * The factorial time complexity (`O(n!)`) is a hallmark of permutation problems, making them computationally expensive for even moderately sized inputs (`n > 10`).