## **Print All Subsequences with Sum K**

### **1. Problem Understanding**

We are given:

  * An array of integers `arr[]`.
  * A target integer `k`.

**Task:**
The goal is to find and print all the **subsequences** of the given array whose elements add up to exactly `k`.

**What is a subsequence?**
A subsequence is a sequence that can be derived from the array by deleting zero or more elements without changing the order of the remaining elements.

**Example:**

```
Input: arr[] = {1, 2, 1}, k = 2
Output:
1 1
2
```

Here, the subsequences `{1, 1}` and `{2}` are the only ones that sum up to 2.

-----

### **2. When to Think of Recursion & Backtracking**

This type of problem is a classic candidate for recursion and backtracking. You should think of this approach when:

1.  The problem asks to generate **all possible** solutions (e.g., all subsequences, all permutations, all combinations).
2.  You can build a solution step-by-step by making a series of choices.
3.  The problem can be broken down into smaller, self-similar subproblems. For our problem, the choice is: "For the current element, do I **include it** in my subsequence or **not**?"

-----

### **3. The "Pick / Not Pick" Pattern**

The core of the solution is a recursive strategy often called the "Pick / Not Pick" or "Take / Not Take" pattern.

Imagine you're standing at an element in the array. You have two choices:

1.  **Pick:** Add the element to your current subsequence and recursively solve the problem for the rest of the array.
2.  **Not Pick:** Ignore the element and recursively solve the problem for the rest of the array.

By exploring both of these paths for every single element, you systematically generate every possible subsequence. The **base case** for the recursion is when you have considered every element in the array. At that point, you simply check if the subsequence you've built sums up to `k`.

This exploration of choices forms a decision tree, and the recursive function travels down every path of this tree. The "backtracking" step is crucial: after exploring the "Pick" path, we must remove the element to correctly explore the "Not Pick" path.

-----

### **4. Algorithm**

**Step-by-step:**

1.  Define a recursive function, for instance, `find(index, currentSum, tempSubsequence)`.
2.  **Base Case:** When the `index` goes beyond the array's bounds (`index >= n`):
      * Check if `currentSum == k`.
      * If they are equal, you have found a valid subsequence. Add the `tempSubsequence` to your final answer list.
      * Return from the function.
3.  **Recursive Step 1 (Pick the element):**
      * Add the element `arr[index]` to your `tempSubsequence`.
      * Make a recursive call for the next index: `find(index + 1, currentSum + arr[index], tempSubsequence)`.
4.  **Backtrack:**
      * After the above call returns, **remove** the element `arr[index]` from `tempSubsequence`. This is the most critical step of backtracking, as it undoes the choice and cleans the state for the next recursive path.
5.  **Recursive Step 2 (Do Not Pick the element):**
      * Make a recursive call for the next index without adding the current element: `find(index + 1, currentSum, tempSubsequence)`.

-----

### **5. Time and Space Complexity**

  * **Time Complexity: `O(2^n)`**
    For each of the `n` elements in the array, we have two choices (pick or not pick). This results in a total of `2^n` possible subsequences. The algorithm explores each of these possibilities.

  * **Space Complexity: `O(n)`**
    This is the auxiliary space used by the recursion call stack. In the worst case, the depth of the recursion tree can be `n`, where we pick every element. This does not include the space required to store the final answer, which could also be substantial.

-----

### **6. Code**

```cpp
#include<bits/stdc++.h>
using namespace std;

class Solution {
public:
    void printAllSubSequenceWhoseSumIsK(vector<vector<int>> &ans, vector<int> &arr, vector<int> &temp, int idx, int k, int sum, int sizeOfArr) {
        // Base Case: If we have considered all elements
        if (idx >= sizeOfArr) {
            // Check if the current subsequence sum equals k
            if (sum == k) {
                ans.push_back(temp);
            }
            return;
        }

        // --- Pick the element ---
        // Add the current element to the temporary subsequence
        temp.push_back(arr[idx]);
        // Recur for the next index with the updated sum
        printAllSubSequenceWhoseSumIsK(ans, arr, temp, idx + 1, k, sum + arr[idx], sizeOfArr);

        // --- Backtrack ---
        // Remove the element to explore the "Not Pick" path
        temp.pop_back();

        // --- Do Not Pick the element ---
        // Recur for the next index with the same sum
        printAllSubSequenceWhoseSumIsK(ans, arr, temp, idx + 1, k, sum, sizeOfArr);
    }
};

int main() {
    Solution s;
    vector<int> arr = {1, 2, 3, 4, 5};
    vector<int> temp;
    vector<vector<int>> ans;
    int k = 10;
    int sizeOfArr = arr.size();

    // Initial call to the recursive function
    s.printAllSubSequenceWhoseSumIsK(ans, arr, temp, 0, k, 0, sizeOfArr);

    // Print the results
    cout << "Subsequences with sum " << k << " are:" << endl;
    for (int i = 0; i < ans.size(); i++) {
        for (int j = 0; j < ans[i].size(); j++) {
            cout << ans[i][j] << " ";
        }
        cout << endl;
    }
    return 0;
}
```

-----

### **7. Dry Run Example**

**Input:** `arr = {1, 2, 3}`, `k = 3`

The recursion tree would explore paths like this:

1.  `f(idx=0, sum=0, temp={})`
      * **Pick 1**: `f(idx=1, sum=1, temp={1})`
          * **Pick 2**: `f(idx=2, sum=3, temp={1, 2})`
              * **Pick 3**: `f(idx=3, sum=6, ...)` -\> Base case, sum \!= k.
              * **Not Pick 3**: `f(idx=3, sum=3, ...)` -\> Base case, **sum == k**. Add `{1, 2}` to answer.
          * **Not Pick 2**: `f(idx=2, sum=1, temp={1})`
              * **Pick 3**: `f(idx=3, sum=4, ...)` -\> Base case, sum \!= k.
              * **Not Pick 3**: `f(idx=3, sum=1, ...)` -\> Base case, sum \!= k.
      * **Not Pick 1**: `f(idx=1, sum=0, temp={})`
          * **Pick 2**: `f(idx=2, sum=2, temp={2})`
              * **Pick 3**: `f(idx=3, sum=5, ...)` -\> Base case, sum \!= k.
              * **Not Pick 3**: `f(idx=3, sum=2, ...)` -\> Base case, sum \!= k.
          * **Not Pick 2**: `f(idx=2, sum=0, temp={})`
              * **Pick 3**: `f(idx=3, sum=3, ...)` -\> Base case, **sum == k**. Add `{3}` to answer.
              * **Not Pick 3**: `f(idx=3, sum=0, ...)` -\> Base case, sum \!= k.

âœ… **Final Answer:** `{1, 2}` and `{3}`.

-----

### **8. Key Takeaways**

1.  The **"Pick / Not Pick"** pattern is a powerful tool for solving any problem that involves generating all subsets or subsequences.
2.  **Backtracking** (the `pop_back()` step) is the key to making this work. It allows the algorithm to "undo" a choice and explore alternative paths.
3.  The **base case** is where the condition is checked and valid solutions are recorded.
4.  Be mindful of the **exponential time complexity**, which makes this approach suitable for small input sizes (`n` roughly up to 20-25).