## **Generating All Subsets (The Power Set)**

This is a fundamental problem in computer science. Given a set of elements, the goal is to find every single possible subset that can be formed from it, including the empty set. The collection of all subsets is known as the **power set**.

-----

### **1. Problem Understanding**

We are given:

  * An integer array `nums` containing **unique** elements.

**Task:**
Return all possible subsets of `nums`. The final list should not contain any duplicate subsets.

**Example:**

```
Input: nums = [1, 2, 3]

Output: [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]
```

For a set with **n** elements, its power set will always contain **2^n** subsets. For `n=3`, we get `2^3 = 8` subsets.

***Note on the Provided Code:*** The code correctly solves this problem. However, the function and variable names (`findSum`, `subSetSum`) might be a bit misleading. The algorithm generates all subsets, not just those with a particular sum. We'll clarify this in the "Code with Comments" section.

-----

### **2. Core Technique: Recursion & Backtracking**

Whenever a problem asks you to generate "all possible" configurations, combinations, or subsets, your first thought should be **recursion**.

The problem of finding all subsets can be broken down into a series of simple, identical decisions. For each element in the input array, we can make a choice. This is where the classic **"Pick / Not Pick"** pattern comes in.

-----

### **3. The "Pick / Not Pick" Pattern**

This is the heart of the solution and a cornerstone of backtracking algorithms.

Imagine you are iterating through the array `[1, 2, 3]`. For each number, you have two choices:

1.  **Pick**: Include the number in the subset you are currently building.
2.  **Not Pick**: Do not include the number.

By systematically exploring every branch of these decisions for every number, you are guaranteed to generate every single possible subset.

The recursive function will travel down every path of this decision tree. Each leaf of the tree represents a completed subset.

-----

### **4. Algorithm Breakdown**

1.  Define a recursive helper function, let's call it `findSubsets(index, currentSubset)`.
2.  **Base Case:** When our `index` has gone past the end of the array, it means we have made a decision (Pick or Not Pick) for every single element. The `currentSubset` we have built is now complete. We add a copy of it to our final list of results and return.
3.  **The "Pick" Path:**
      * Add the element `arr[index]` to `currentSubset`.
      * Make a recursive call to explore the consequences of this choice for the rest of the array: `findSubsets(index + 1, currentSubset)`.
4.  **The "Backtrack" Step:**
      * After the "Pick" path has been fully explored and the recursive call returns, we must **undo our choice**. We remove the element `arr[index]` from `currentSubset`. This is the most critical step of backtracking, as it resets the state, allowing us to explore the "Not Pick" path.
5.  **The "Not Pick" Path:**
      * Make another recursive call, but this time without adding the current element: `findSubsets(index + 1, currentSubset)`.

-----

### **5. Time and Space Complexity**

  * **Time Complexity: `O(n * 2^n)`**

      * We need to generate `2^n` subsets.
      * For each subset, we have to create a copy of it to store in our final answer list. In the worst case, a subset can have `n` elements. Therefore, the total time is proportional to the number of subsets multiplied by the average size of a subset.

  * **Space Complexity: `O(n)`**

      * This refers to the auxiliary space used by the system. The primary consumer of space is the recursion call stack, which can go `n` levels deep in the worst case. (This does not include the space required to store the output, which would be `O(n * 2^n)`).

-----

### **6. Code with Comments**

Here is the provided code, slightly refactored with clearer names and comments to better reflect its purpose.

```cpp
#include<bits/stdc++.h>
using namespace std;

class Solution {
public:
    // The recursive helper function to find all subsets
    void findSubsets(int index, vector<vector<int>>& allSubsets, vector<int>& currentSubset, vector<int>& arr, int n) {
        // Base Case: If we have considered all elements, this is a valid subset
        if (index >= n) {
            allSubsets.push_back(currentSubset);
            return;
        }

        // --- Path 1: Pick the element ---
        currentSubset.push_back(arr[index]);
        // Recur for the rest of the array
        findSubsets(index + 1, allSubsets, currentSubset, arr, n);
        
        // --- Backtrack ---
        // Undo the choice to explore the other path
        currentSubset.pop_back();

        // --- Path 2: Do NOT Pick the element ---
        // Recur for the rest of the array
        findSubsets(index + 1, allSubsets, currentSubset, arr, n);
    }

    // Main function to generate the power set
    vector<vector<int>> subsets(vector<int>& arr) {
        vector<vector<int>> allSubsets;
        vector<int> currentSubset;
        int n = arr.size();
        findSubsets(0, allSubsets, currentSubset, arr, n);
        return allSubsets;
    }
};

int main() {
    Solution s;
    vector<int> arr = {1, 2, 3};
    vector<vector<int>> ans = s.subsets(arr);

    // Sorting the final list of subsets just for a clean, predictable output
    sort(ans.begin(), ans.end()); 
    cout << "The power set is: " << endl;
    for (auto subset : ans) {
        cout << "{";
        for (size_t i = 0; i < subset.size(); ++i) {
            cout << subset[i] << (i < subset.size() - 1 ? ", " : "");
        }
        cout << "} ";
    }
    cout << endl;
    return 0;
}
```

-----

### **7. Dry Run Visualization (`arr = [1, 2]`)**

Let `f(index, subset)` be our recursive call.

1.  `f(0, {})`
      * **Pick 1**: `subset = {1}`. Call `f(1, {1})`.
          * **Pick 2**: `subset = {1, 2}`. Call `f(2, {1, 2})`. -\> **Base Case**. Add `{1, 2}` to answer.
          * *Backtrack*: `subset = {1}`.
          * **Not Pick 2**: Call `f(2, {1})`. -\> **Base Case**. Add `{1}` to answer.
      * *Backtrack*: `subset = {}`.
      * **Not Pick 1**: Call `f(1, {})`.
          * **Pick 2**: `subset = {2}`. Call `f(2, {2})`. -\> **Base Case**. Add `{2}` to answer.
          * *Backtrack*: `subset = {}`.
          * **Not Pick 2**: Call `f(2, {})`. -\> **Base Case**. Add `{}` to answer.

âœ… **Final Answer**: `{1, 2}, {1}, {2}, {}`

-----

### **8. Key Takeaways**

  * The "Pick / Not Pick" pattern is the most intuitive way to solve subset and subsequence generation problems.
  * **Backtracking** is not the algorithm itself, but the technique of "undoing" a choice to allow for the exploration of all other possibilities. The `pop_back()` step is the implementation of backtracking here.
  * Understanding the recursion tree is key to visualizing how every single possibility is systematically generated.