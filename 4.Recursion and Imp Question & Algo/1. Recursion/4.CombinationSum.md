Of course. Here are the notes explaining the "Combination Sum" problem and the provided C++ solution.

-----

## **Combination Sum**

### **1. Problem Understanding**

We are given:

  * An array of **distinct** integers, `candidates`.
  * A target integer, `target`.

**Task:**
The goal is to find all **unique combinations** of numbers from the `candidates` array that sum up to the `target`.

**Key Rules:**

1.  The **same number can be chosen multiple times**. This is a crucial detail.
2.  All numbers in `candidates` are positive.
3.  The solution set must not contain duplicate combinations (e.g., `[2, 3]` is the same as `[3, 2]`, and the algorithm should only produce one).

**Example:**

```
Input: candidates = [2, 3, 6, 7], target = 7
Output: [[2, 2, 3], [7]]
```

  * The combination `[2, 2, 3]` sums to `2 + 2 + 3 = 7`.
  * The combination `[7]` sums to `7`.

-----

### **2. Core Technique: Recursion & Backtracking**

This problem asks for "all possible combinations," which is a strong signal to use **recursion and backtracking**. We need to build a solution step-by-step, and at each step, we explore multiple choices.

The general idea is to make a choice, explore the consequences of that choice (by recursing), and then **undo the choice (backtrack)** so we can explore other options.

-----

### **3. The "Pick and Stay" vs. "Move On" Strategy**

Because we can reuse numbers, the classic "Pick/Not Pick" strategy needs a small but important modification. For each candidate number at a given `index`:

1.  **Pick and Stay**: We can choose to **pick** the current `candidates[index]`. If we do, we add it to our current combination and make a recursive call. Crucially, we call the function again for the **same index**. This allows us to pick the same number again.
2.  **Move On**: We can choose to **stop picking** the current `candidates[index]` and all subsequent combinations will be formed from the rest of the array. To do this, we make a recursive call for the **next index** (`index + 1`).

This structure ensures we generate all possibilities while naturally avoiding duplicate combinations. By only moving forward in the `candidates` array (from `index` to `index + 1`), we never generate `[3, 2]` after already having explored combinations starting with `2`.

-----

### **4. Algorithm Breakdown**

The logic is implemented in the `findCombinations` helper function.

1.  **Base Case:** The recursion stops when we have considered all candidates (`index == candidates.size()`).
      * At this point, if our `target` has been reduced to exactly `0`, it means the current combination is valid, and we add it to our results.
      * If `target` is not `0`, the path was a dead end.
2.  **Recursive Step 1 (Pick and Stay):**
      * First, we check if the current candidate is even usable (`candidates[index] <= target`). This is a smart optimization to "prune" the recursion tree and avoid exploring paths that will definitely exceed the target.
      * If it's usable, we **add** `candidates[index]` to our `currentCombination`.
      * We then make a recursive call with the updated target (`target - candidates[index]`) but for the **same index**.
      * **Backtrack**: After the recursive call returns, we **remove** the element (`currentCombination.pop_back()`). This is essential to clean up for the next path.
3.  **Recursive Step 2 (Move On):**
      * We make a separate recursive call for the **next index** (`index + 1`) with the same target. This represents the choice to no longer use the current `candidates[index]`.

-----

### **5. Time and Space Complexity**

  * **Time Complexity: `O(2^t * k)` (approximate)**

      * This is a rough upper bound where `t` is the target value and `k` is the average length of a combination.
      * The complexity is exponential because the recursion can branch, and the depth of the recursion can be up to `t` (in the case where the smallest candidate is 1). The `* k` factor accounts for the time it takes to copy a valid combination into the results vector.

  * **Space Complexity: `O(t)` (for recursion stack) + `O(number of combinations)` (for storing the answer)**

      * The depth of the recursion stack can go up to the target `t`.
      * The space needed to store the final `results` vector can be significant, depending on the input.

-----

### **6. Code with Comments**

Here is the provided code with detailed comments explaining the logic.

```cpp
class Solution {
private:
    // Helper function to find all combinations that sum up to the target
    void findCombinations(int index, int target, vector<int>& candidates, vector<vector<int>>& results, vector<int>& currentCombination) {
        // Base case: if we've moved past the last candidate
        if (index == candidates.size()) {
            // If the target has been reduced to exactly 0, we found a valid combination
            if (target == 0) {
                results.push_back(currentCombination);
            }
            return;
        }

        // --- Recursive Step 1: Pick and Stay ---
        // If the current candidate can be included without making the sum negative
        if (candidates[index] <= target) {
            // Include the current candidate in our combination
            currentCombination.push_back(candidates[index]);
            
            // Recur with the same index, since we can reuse this element
            findCombinations(index, target - candidates[index], candidates, results, currentCombination);
            
            // Backtrack: remove the element we just added to explore other paths
            currentCombination.pop_back();
        }

        // --- Recursive Step 2: Move On ---
        // Recur for the next candidate, effectively choosing to not use the current candidate anymore
        findCombinations(index + 1, target, candidates, results, currentCombination);
    }

public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> results;
        vector<int> currentCombination;
        // Start the recursion from the first element (index 0)
        findCombinations(0, target, candidates, results, currentCombination);
        return results;
    }
};
```

-----

### **7. Dry Run Example**

Let's trace one successful path for `candidates = [2, 3]`, `target = 7`.
`f(index, target, combination)`

1.  `f(0, 7, [])` -\> Current candidate is `2`.
      * **Pick 2**: `combination = [2]`. Call `f(0, 5, [2])`.
2.  `f(0, 5, [2])` -\> Current candidate is still `2`.
      * **Pick 2**: `combination = [2, 2]`. Call `f(0, 3, [2, 2])`.
3.  `f(0, 3, [2, 2])` -\> Current candidate is still `2`.
      * **Pick 2**: `combination = [2, 2, 2]`. Call `f(0, 1, [2, 2, 2])`.
4.  `f(0, 1, [2, 2, 2])` -\> Current candidate is `2`. `2 > 1`, so we can't pick it.
      * **Move On**: Call `f(1, 1, [2, 2, 2])`.
5.  `f(1, 1, [2, 2, 2])` -\> Current candidate is `3`. `3 > 1`, so we can't pick it.
      * **Move On**: Call `f(2, 1, [2, 2, 2])`.
6.  `f(2, 1, [2, 2, 2])` -\> Base case `index == 2`. `target != 0`. Return.
7.  (Backtracking all the way to step 3) ... We are now back at `f(0, 3, [2, 2])`. We have explored the "Pick 2" path.
      * **Move On**: Call `f(1, 3, [2, 2])`.
8.  `f(1, 3, [2, 2])` -\> Current candidate is `3`.
      * **Pick 3**: `combination = [2, 2, 3]`. Call `f(1, 0, [2, 2, 3])`.
9.  `f(1, 0, [2, 2, 3])` -\> Current candidate is `3`. `3 > 0`, so we can't pick it.
      * **Move On**: Call `f(2, 0, [2, 2, 3])`.
10. `f(2, 0, [2, 2, 3])` -\> Base case `index == 2`. `target == 0`.
      * âœ… **Success\!** Add `[2, 2, 3]` to the results. Return.

The process continues, backtracking and exploring all other paths until every possibility is checked.

-----

### **8. Key Takeaways**

  * This problem is a classic variation of the subset/subsequence pattern.
  * The key to allowing **element reuse** is making the recursive call on the **same index** after picking an element.
  * The choice to **move to the next index** (`index + 1`) signifies that we are done with the current element and will not use it again in that particular combination path.
  * **Backtracking** (`pop_back()`) is fundamental for cleaning up the state and ensuring all paths can be explored independently.