## **Palindrome Partitioning**

This problem is a classic recursive challenge that involves breaking down a string into smaller pieces, with each piece needing to satisfy a specific propertyâ€”in this case, being a palindrome. It's a great example of "front-partitioning" backtracking.

-----

## **1. Problem Understanding**

**Given:**

  * A string `s`.

**Task:**

  * [cite\_start]To split the string `s` into all possible combinations of substrings, where **every substring** in the combination is a palindrome. [cite: 1]

**Example:**

  * **Input**: `s = "aab"`
  * [cite\_start]**Output**: `[ ["a", "a", "b"], ["aa", "b"] ]` [cite: 1]

-----

## **2. Core Technique: Backtracking**

The problem asks for "all possible partitions," which is a strong signal to use **recursion and backtracking**. The core idea is to think about making "cuts" in the string.

We can stand at the beginning of a string (or substring) and decide where to make the first cut.

1.  **Choose**: Make a cut at an index `i`, creating a substring.
2.  **Constraint Check**: Check if this substring is a palindrome.
3.  [cite\_start]**Explore**: If it is a palindrome, we accept this piece and recursively try to partition the *rest* of the string. [cite: 1]
4.  **Un-choose (Backtrack)**: After the recursive call returns (meaning it has explored all possibilities from that point), we undo our choice. [cite\_start]We remove the substring we just added to our current partition, allowing us to explore making the cut at a later position (`i+1`). [cite: 1]

-----

## **3. Algorithm Breakdown**

The entire process is driven by a recursive function that keeps track of our current position in the string.

1.  Define a recursive helper function, `solve(index, currentPath, s)`.
2.  **Base Case**: If `index` reaches the end of the string (`index >= s.length()`), it means we have successfully partitioned the entire string into a sequence of palindromes. [cite\_start]We add the `currentPath` to our final list of answers and return. [cite: 1]
3.  **Recursive Step**:
      * Start a `for` loop that iterates from `i = index` to the end of the string. This loop represents trying all possible "cut" points for the current segment.
      * For each `i`, consider the substring from `index` to `i`.
      * [cite\_start]Check if this substring is a palindrome using an `isPalindrome(s, index, i)` helper function. [cite: 1]
      * If it **is a palindrome**:
          * [cite\_start]**Place**: Add this valid palindromic substring to the `currentPath`. [cite: 1]
          * [cite\_start]**Recurse**: Make a recursive call to partition the rest of the string, starting from the next character: `solve(i + 1, ...)`. [cite: 1]
          * [cite\_start]**Backtrack**: After the recursive call returns, remove the substring from `currentPath` so we can try the next possible cut point in the `for` loop. [cite: 1]

-----

## **4. Patterns**

  * **Front Partitioning Backtracking**: This is a very common pattern for problems that involve splitting a sequence into valid segments. Unlike a simple "Pick / Not Pick" for individual elements, the choice here is "where do I end the current segment?". The recursive call then solves for the remainder of the input.
  * **`for` Loop in Recursion**: The pattern of using a `for` loop starting from the current `index` inside a recursive function `solve(index, ...)` is standard for this type of partitioning problem. It allows you to generate segments of all possible lengths (`s[index...index]`, `s[index...index+1]`, etc.).

-----

## **5. Time and Space Complexity**

  * **Time Complexity**: **O($n \\cdot 2^n$)**
      * In the worst case (a string like `"aaaaa"`), there can be up to $2^n$ possible partitions. [cite\_start]For each partition, we perform palindrome checks which can take up to $O(n)$ time. [cite: 1]
  * **Space Complexity**: **O($n$)**
      * The depth of the recursion can go up to `n`. [cite\_start]The space required to store the `currentPath` being built is also proportional to `n`. [cite: 1]

-----

## **6. Code with Comments**

Here is a complete C++ solution based on the described approach.

```cpp
#include <vector>
#include <string>

class Solution {
public:
    // Main function to start the partitioning process.
    std::vector<std::vector<std::string>> partition(std::string s) {
        std::vector<std::vector<std::string>> ans;
        std::vector<std::string> path;
        solve(0, s, path, ans);
        return ans;
    }

private:
    // The recursive backtracking function.
    void solve(int index, std::string s, std::vector<std::string>& path, std::vector<std::vector<std::string>>& ans) {
        // Base Case: If we've reached the end of the string, we have a valid partition.
        if (index == s.size()) {
            ans.push_back(path);
            return;
        }

        // Iterate through the string to create all possible partitions (cuts).
        for (int i = index; i < s.size(); ++i) {
            // Check if the substring from 'index' to 'i' is a palindrome.
            if (isPalindrome(s, index, i)) {
                // Choose: Add the palindromic substring to our current path.
                path.push_back(s.substr(index, i - index + 1));
                
                // Explore: Recurse on the rest of the string.
                solve(i + 1, s, path, ans);
                
                // Un-choose (Backtrack): Remove the substring to explore other partitions.
                path.pop_back();
            }
        }
    }

    // Helper function to check if a substring is a palindrome.
    bool isPalindrome(std::string s, int start, int end) {
        while (start <= end) {
            if (s[start++] != s[end--]) {
                return false;
            }
        }
        return true;
    }
};
```

-----

## **7. Dry Run (`s = "aab"`)**

[cite\_start]This visualization shows how the recursion explores different partitions. [cite: 1]

`solve(index=0, path=[])`

  * `i = 0`: Substring `"a"` (from 0 to 0) is a palindrome.
      * **Place**: `path = ["a"]`.
      * **Recurse**: `solve(index=1, path=["a"])`.
          * `i = 1`: Substring `"a"` (from 1 to 1) is a palindrome.
              * **Place**: `path = ["a", "a"]`.
              * **Recurse**: `solve(index=2, path=["a", "a"])`.
                  * `i = 2`: Substring `"b"` (from 2 to 2) is a palindrome.
                      * **Place**: `path = ["a", "a", "b"]`.
                      * **Recurse**: `solve(index=3, path=["a", "a", "b"])`.
                          * **Base Case**: `index == 3`. **Add `["a", "a", "b"]` to answers**.
                      * **Backtrack**: `path = ["a", "a"]`.
              * **Backtrack**: `path = ["a"]`.
          * `i = 2`: Substring `"ab"` (from 1 to 2) is not a palindrome.
      * **Backtrack**: `path = []`.
  * `i = 1`: Substring `"aa"` (from 0 to 1) is a palindrome.
      * **Place**: `path = ["aa"]`.
      * **Recurse**: `solve(index=2, path=["aa"])`.
          * `i = 2`: Substring `"b"` (from 2 to 2) is a palindrome.
              * **Place**: `path = ["aa", "b"]`.
              * **Recurse**: `solve(index=3, path=["aa", "b"])`.
                  * **Base Case**: `index == 3`. **Add `["aa", "b"]` to answers**.
              * **Backtrack**: `path = ["aa"]`.
      * **Backtrack**: `path = []`.
  * `i = 2`: Substring `"aab"` (from 0 to 2) is not a palindrome.

-----

## **8. Key Takeaways**

  * Palindrome Partitioning is a classic backtracking problem that combines substring manipulation with recursion.
  * The key is the "partitioning" mindset: at any point `index`, you try to form a valid (palindromic) first piece and then recursively solve for the rest of the string.
  * The `for` loop inside the recursion is essential for trying all possible lengths of the current substring partition.