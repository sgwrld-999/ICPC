## Problem: Palindrome Partitioning

[LeetCode 131](https://leetcode.com/problems/palindrome-partitioning/)

We need to split string `s` into all possible partitions such that **every substring** in the partition is a palindrome.

**Example**
Input: `s = "aab"`
Output:

```
[
  ["a","a","b"],
  ["aa","b"]
]
```

---

## Intuition

* We need to break the string into substrings.
* At each index `idx`, we try every possible substring `s[idx..i]`.
* If that substring is a **palindrome**, include it in the current path and recurse further.
* Once we reach the end of the string (`idx == s.size()`), push the current path to the answer.
* Use **backtracking** to undo last choice and explore new partitions.

---

## Approach Explanation (Your Code)

### Recursive Function:

```cpp
void solve(vector<vector<string>>& ans, vector<string>& path, string s, int idx)
```

* `ans` → stores all valid partitions.
* `path` → current partition being built.
* `idx` → current starting index in string.

Steps:

1. **Base Case**: If `idx == s.size()`, push `path` to `ans`.
2. **Loop**: For `i` from `idx` to end of string:

   * If `s[idx..i]` is palindrome → add to path, recurse with `i+1`.
   * Backtrack after recursion (`pop_back`).

---

### Palindrome Check Function

```cpp
bool isPalindrome(string s, int start, int end) {
    while (start < end) {
        if (s[start] != s[end]) return false;
        start++;
        end--;
    }
    return true;
}
```

* Expands inward from both ends of substring.
* Returns `true` if all characters match.

---

## Dry Run (s = "aab")

* Start idx=0, path=\[]

1. Try `"a"` (s\[0..0]) → palindrome
   path = \["a"]
   → Recurse idx=1

   * Try `"a"` (s\[1..1]) → palindrome
     path = \["a","a"]
     → Recurse idx=2

     * Try `"b"` (s\[2..2]) → palindrome
       path = \["a","a","b"]
       → Recurse idx=3 (end of string) → push to ans

   * Backtrack → path=\["a"]

   * Try `"ab"` (s\[1..2]) → not palindrome ❌

2. Backtrack → path=\[]
   Try `"aa"` (s\[0..1]) → palindrome
   path = \["aa"]
   → Recurse idx=2

   * Try `"b"` (s\[2..2]) → palindrome
     path = \["aa","b"]
     → Recurse idx=3 (end) → push to ans

3. Backtrack → path=\[]
   Try `"aab"` (s\[0..2]) → not palindrome ❌

Final ans = `[["a","a","b"], ["aa","b"]]`

---

## Complexity

* **Time**: $O(n \cdot 2^n)$

  * Each index may branch into two (cut or not cut), and palindrome check costs up to $O(n)$.
* **Space**: $O(n)$ recursion + path storage.

---

## Key Idea

At each index `idx` in the string:

* We try **every possible substring starting at `idx`** → `s[idx..i]`
* If it is a palindrome → we **include it in the path** and recurse further.
* Once we reach the end of the string → we push the current partition (`path`) to the final answer.
* Backtracking removes the last choice so other partitions can be explored.

So partitioning happens by **cutting the string into palindromic chunks** recursively.

---

## Example: `"aab"`

Start: `idx=0`, `path=[]`

---

### Step 1: Partition starting at index 0

* `s[0..0] = "a"` ✅ palindrome
  → path = \["a"], recurse from idx=1

* `s[0..1] = "aa"` ✅ palindrome
  → path = \["aa"], recurse from idx=2

* `s[0..2] = "aab"` ❌ not palindrome

---

### Step 2: Partition inside `"a"` branch (`path=["a"]`)

From idx=1:

* `s[1..1] = "a"` ✅ palindrome
  → path=\["a","a"], recurse from idx=2

* `s[1..2] = "ab"` ❌ not palindrome

---

### Step 3: Partition inside `"a","a"` branch (`path=["a","a"]`)

From idx=2:

* `s[2..2] = "b"` ✅ palindrome
  → path=\["a","a","b"] → reached end → add to answer

Backtrack → remove last `"b"`

---

### Step 4: Partition inside `"aa"` branch (`path=["aa"]`)

From idx=2:

* `s[2..2] = "b"` ✅ palindrome
  → path=\["aa","b"] → reached end → add to answer

---

## Final Answer

All collected partitions:

```
["a","a","b"]
["aa","b"]
```

---

## Visualization as a Recursion Tree

```
              ""
             /  \
          "a"    "aa"
           |        \
          "a"        "b"
           |          
          "b"         
```

Each path from root → leaf = one valid partition.

* Path 1: \["a","a","b"]
* Path 2: \["aa","b"]

---

✅ So the partitioning happens by **trying substrings of increasing length starting from `idx`**, and **only cutting at positions where the substring is a palindrome**.

---
