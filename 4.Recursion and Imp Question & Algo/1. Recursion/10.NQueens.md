## **The N-Queens Puzzle**

The N-Queens puzzle is a famous chessboard problem that challenges you to place **N** queens on an **NÃ—N** chessboard in such a way that no two queens threaten each other. It's a perfect example of a problem that can be solved elegantly with recursion and backtracking.

-----

### **1. Problem Understanding**

**Given:**

  * An integer `n`, representing the size of the chessboard (`n x n`) and the number of queens to place.

**Task:**

  * Find all distinct arrangements of `n` queens on the board where no two queens are in a position to attack one another.

**Rules of Attack:**

  * A queen can attack any piece along its same **row**, **column**, or any of its **diagonals**.

-----

### **2. Core Technique: Backtracking**

This is a classic **constraint satisfaction** problem. We need to place items (queens) while adhering to a set of rules (no attacks). This is where backtracking shines.

The strategy is to build a valid solution one step at a time. We'll try placing one queen in each column, moving from left to right.

1.  **Choose**: Pick a square in the current column to place a queen.
2.  **Constraint Check**: Verify if this placement is "safe" (i.e., it doesn't violate the rules).
3.  **Explore**: If it's safe, recursively move to the next column to place the next queen.
4.  **Un-choose (Backtrack)**: If the recursive call returns (either because a solution was found or it hit a dead end), we **remove the queen** from our chosen square. This frees up that square and allows us to explore placing the queen in a *different* row of the same column.

-----

### **3. Algorithm Breakdown**

The provided code follows this backtracking strategy perfectly.

**1. [cite\_start]`solveNQueens(n)` - The Main Function** [cite: 1]

  * [cite\_start]Initializes an empty `n x n` board (a `vector<string>` filled with '.'). [cite: 1]
  * [cite\_start]Creates a `vector` to store the final solutions. [cite: 1]
  * [cite\_start]Makes the initial call to the recursive helper function, starting with the first column (`col = 0`). [cite: 1]

**2. [cite\_start]`solve(col, ans, board, n)` - The Recursive Helper** [cite: 1]

  * **Base Case**: If `col == n`, we have successfully placed a queen in every column. [cite\_start]This is a valid solution, so we add the current `board` configuration to our answer list (`ans`) and return. [cite: 1]
  * [cite\_start]**Recursive Step**: Iterate through every `row` (from `0` to `n-1`) in the current `col`. [cite: 1]
      * [cite\_start]For each `(row, col)` position, check if it's a safe place for a queen using `isSafe(row, col, board, n)`. [cite: 1]
      * If it is safe:
          * [cite\_start]**Place Queen**: Set `board[row][col] = 'Q'`. [cite: 1]
          * [cite\_start]**Explore**: Make a recursive call for the next column: `solve(col + 1, ...)`. [cite: 1]
          * [cite\_start]**Backtrack**: After the call returns, undo the choice: `board[row][col] = '.'`. [cite: 1]

**3. [cite\_start]`isSafe(row, col, board, n)` - The Constraint Checker** [cite: 1]

  * This function checks if placing a queen at `(row, col)` is valid. Since we are placing queens column by column from left to right, we only need to check for attacks from queens already placed (i.e., to the left).
    1.  [cite\_start]**Check Upper-Left Diagonal**: Scans backward from `(row-1, col-1)`. [cite: 1]
    2.  [cite\_start]**Check Left Row**: Scans backward from `(row, col-1)` to `(row, 0)`. [cite: 1]
    3.  [cite\_start]**Check Lower-Left Diagonal**: Scans backward from `(row+1, col-1)`. [cite: 1]
  * If a queen is found in any of these three directions, the position is not safe; return `false`. [cite\_start]Otherwise, return `true`. [cite: 1]

-----

### **4. Patterns & Optimizations**

  * **Backtracking Pattern**: This problem is the quintessential example of the **"Choose, Explore, Un-choose"** backtracking pattern for solving constraint satisfaction problems.

  * **Optimization Pattern**: The `isSafe` function in the code, which scans the board repeatedly, has a time complexity of O(n). A common and significant optimization is to replace this scanning with **hashing or boolean arrays** to check for attacks in **O(1)** time.

      * We can use three arrays to keep track of attacked lines:
          * `leftRow[n]` to mark attacked rows.
          * `upperDiagonal[2*n - 1]` to mark attacked upper-left-to-lower-right diagonals.
          * `lowerDiagonal[2*n - 1]` to mark attacked lower-left-to-upper-right diagonals.
      * Before placing a queen at `(row, col)`, we would just check if `leftRow[row]`, `upperDiagonal[n-1 + col-row]`, or `lowerDiagonal[row+col]` are marked. This is much faster.

-----

### **5. Time and Space Complexity**

  * **Time Complexity: `O(n!)`**

      * This is a loose upper bound. In the first column, we have `n` choices, in the second at most `n-1`, and so on. Backtracking prunes the search space significantly, but the complexity remains factorial in nature.

  * **Space Complexity: `O(n^2)`**

      * [cite\_start]We need `O(n^2)` space to store the chessboard. [cite: 1]
      * The recursion stack will go at most `n` levels deep, contributing `O(n)` space. The board is the dominant factor.

-----

### **6. Code with Comments**

Here is your provided code with detailed comments explaining each step.

```cpp
#include<bits/stdc++.h>
using namespace std;
#include<string>

class Solution {
public:
    // Helper function to check if placing a queen at board[row][col] is safe.
    bool isSafe(int row, int col, vector<string>& board, int n){
        // We only need to check 3 directions: left row, upper-left diagonal, and lower-left diagonal,
        // because we are filling the board from left to right (column by column).

        int dupRow = row;
        int dupCol = col;

        // Check upper-left diagonal
        while(row >= 0 && col >= 0){
            if(board[row][col] == 'Q'){
                return false;
            }
            row--;
            col--;
        }

        // Reset row and col for the next check
        row = dupRow;
        col = dupCol;

        // Check left side of the row
        while(col >= 0){
            if(board[row][col] == 'Q'){
                return false;
            }
            col--;
        }

        // Reset row and col for the final check
        row = dupRow;
        col = dupCol;

        // Check lower-left diagonal
        while(row < n && col >= 0){
            if(board[row][col] == 'Q'){
                return false;
            }
            row++;
            col--;
        }

        // If no queens are found in any of the 3 directions, the position is safe.
        return true;
    }

    // The recursive backtracking function
    void solve(int col, vector<vector<string>>& ans, vector<string>& board, int n){
        // Base Case: If we have successfully placed a queen in every column (0 to n-1),
        // we have found a valid solution.
        if(col == n){
            ans.push_back(board);
            return;
        }

        // Iterate through all rows in the current column to find a safe spot.
        for(int row = 0; row < n; row++){
            // Check if it's safe to place a queen at (row, col).
            if(isSafe(row, col, board, n)){
                // Choose: Place the queen.
                board[row][col] = 'Q';
                // Explore: Recurse for the next column.
                solve(col + 1, ans, board, n);
                // Un-choose (Backtrack): Remove the queen to explore other possibilities.
                board[row][col] = '.';
            }
        }
    }

    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>> ans;
        vector<string> board(n);
        string s(n,'.');
        // Initialize the board with empty spaces ('.')
        for(int i = 0; i < n; i++){
            board[i] = s;
        }

        // Start the recursive process from the first column (col = 0).
        solve(0, ans, board, n);
        return ans;
    }
};
```

-----

### **7. Key Takeaways**

  * N-Queens is a canonical backtracking problem perfect for interviews.
  * The core idea is to build a solution incrementally (`col` by `col`), checking constraints (`isSafe`) at each step.
  * The most important concept is **backtracking** (removing the queen), which allows the algorithm to correct itself from a dead end and explore the entire search space for all possible solutions.
  * Knowing the `O(1)` optimization for the `isSafe` check using hashing/boolean arrays can impress an interviewer by showing a deeper understanding of algorithmic trade-offs.