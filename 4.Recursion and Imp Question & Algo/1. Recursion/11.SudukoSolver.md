## Problem: Sudoku Solver

[LeetCode 37. Sudoku Solver](https://leetcode.com/problems/sudoku-solver/)

We need to fill a `9x9` board with numbers `1–9` such that:

1. Each row has digits `1–9` without repetition.
2. Each column has digits `1–9` without repetition.
3. Each `3x3` sub-box has digits `1–9` without repetition.

---

## Intuition

* Think of Sudoku as a **constraint satisfaction problem**.
* For each empty cell `.`:

  * Try placing digits `1–9`.
  * If it satisfies row, col, and 3×3 box constraints → proceed recursively.
  * If at some point no number can be placed → **backtrack** (undo last step).

---

## Approach

1. **Find Empty Cell**

   * Traverse board row-wise, col-wise.
   * If `board[i][j] == '.'`, it’s empty.

2. **Try Numbers (1–9)**

   * For each number, check validity:

     * Same row? ❌
     * Same column? ❌
     * Same `3x3` box? ❌

3. **Recursion + Backtracking**

   * Place number if valid.
   * Recurse for next cell.
   * If stuck later → reset (`board[i][j] = '.'`) and try another number.

4. **End Condition**

   * If all cells filled → return `true`.

---

## Key Helper Function

```cpp
bool isValid(vector<vector<char>>& board, int row, int col, char ch) {
    for (int i = 0; i < 9; i++) {
        if (board[i][col] == ch) return false; // check column
        if (board[row][i] == ch) return false; // check row
        int boxRow = 3 * (row / 3) + i / 3;
        int boxCol = 3 * (col / 3) + i % 3;
        if (board[boxRow][boxCol] == ch) return false; // check 3x3 box
    }
    return true;
}
```

---

## Dry Run (Mini Example)

Suppose cell `(0,2)` is empty.

* Try `1` → fails (already in row).
* Try `2` → fails (already in col).
* Try `3` → passes ✅

  * Place `3`.
  * Recurse for next empty cell.

If recursion later fails:

* Undo placement (`board[0][2] = '.'`) → try next number.

---

## Complexity

* **Time**: \~ $O(9^{m})$, where $m$ = number of empty cells.
  (Because at worst, for each empty cell we try `1–9` possibilities).
* **Space**: $O(1)$ (in-place board modification, recursion depth ≤ 81).

---


### Function Header

```cpp
bool isValid(vector<vector<char>>& board, int row, int col, char ch)
```

* `board`: the 9×9 sudoku grid
* `(row, col)`: the cell where we want to place digit `ch`
* Returns:

  * `true` → safe to place `ch`
  * `false` → violates Sudoku rules

---

### Loop Breakdown

```cpp
for (int i = 0; i < 9; i++) {
    if (board[i][col] == ch) return false;  // check column
    if (board[row][i] == ch) return false;  // check row
```

* We loop `i = 0 to 8`.
* First `if`: checks the **column** → if `ch` already exists anywhere in column `col`.
* Second `if`: checks the **row** → if `ch` already exists anywhere in row `row`.

---

### Checking the 3×3 Sub-Box

```cpp
    int boxRow = 3 * (row / 3) + i / 3;
    int boxCol = 3 * (col / 3) + i % 3;
    if (board[boxRow][boxCol] == ch) return false; // check 3x3 box
```

* Sudoku is divided into **9 sub-boxes**, each 3×3.
* To identify which sub-box `(row, col)` belongs to:

  * `row/3` and `col/3` → find the **block index** (0, 1, or 2).
  * Multiply by 3 to find the **top-left corner** of that sub-box.

Example:
If `(row=5, col=7)` → that’s in sub-box `(row/3=1, col/3=2)`,
top-left corner = `(3*1=3, 3*2=6)` → `(3,6)`.

* Then, using `i/3` and `i%3`, we iterate through all 9 cells in this 3×3 box:

  * `i/3` → row offset inside the box.
  * `i%3` → column offset inside the box.

So `(boxRow, boxCol)` walks through all 9 cells of that sub-box.

---

### Return

If no conflict found → `return true`.

---

### Mini Example

Suppose we want to place `'5'` at `(4,4)`.

1. Check row 4 → is `'5'` already there? ❌
2. Check col 4 → is `'5'` already there? ❌
3. Check 3×3 sub-box (center box, top-left = (3,3))

   * Loop over 9 cells in that box → if `'5'` exists, ❌

If all clear → ✅ return `true`.

---

## Step 1: Sudoku board structure

The board is a `9x9` grid, split into **9 sub-boxes (3x3 each)**:

```
+-------+-------+-------+
| (0,0) | (0,1) | (0,2) |
| (1,0) | (1,1) | (1,2) |
| (2,0) | (2,1) | (2,2) |
+-------+-------+-------+
| (3,0) | (3,1) | (3,2) |
| (4,0) | (4,1) | (4,2) |
| (5,0) | (5,1) | (5,2) |
+-------+-------+-------+
| (6,0) | (6,1) | (6,2) |
| (7,0) | (7,1) | (7,2) |
| (8,0) | (8,1) | (8,2) |
+-------+-------+-------+
```

Each `(row/3, col/3)` tells you **which box** you’re in.

* Top-left 3×3 → `(0,0)`
* Middle 3×3 → `(1,1)`
* Bottom-right 3×3 → `(2,2)`

---

## Step 2: Formula

For a cell `(row, col)`:

```
boxRow = 3 * (row / 3) + i / 3
boxCol = 3 * (col / 3) + i % 3
```

* `(row/3, col/3)` → which 3×3 block
* Multiply by `3` → get top-left corner of that block
* `(i/3, i%3)` → iterate inside the 3×3 block

---

## Step 3: Example

Say we want to check cell `(4,4)` (row=4, col=4).

* `row/3 = 1`, `col/3 = 1` → block (1,1)
* Top-left corner = `(3,3)`

So this block is:

```
(3,3) (3,4) (3,5)
(4,3) (4,4) (4,5)
(5,3) (5,4) (5,5)
```

---

### Iteration inside block

Loop `i = 0 → 8`

* `i=0 → (3,3)`
* `i=1 → (3,4)`
* `i=2 → (3,5)`
* `i=3 → (4,3)`
* `i=4 → (4,4)`
* `i=5 → (4,5)`
* `i=6 → (5,3)`
* `i=7 → (5,4)`
* `i=8 → (5,5)`

✅ This way, all 9 cells in the 3×3 block are checked.

---

So in summary:

* `row/3` and `col/3` identify the block.
* `3*(row/3)` and `3*(col/3)` jump to top-left corner.
* `(i/3, i%3)` iterates inside the block.

---
