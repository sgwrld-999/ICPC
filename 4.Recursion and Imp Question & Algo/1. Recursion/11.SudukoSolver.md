## **Solving Sudoku with Backtracking**

The Sudoku puzzle is a classic logic-based number-placement puzzle. Solving it algorithmically is a quintessential example of a problem that can be tackled efficiently with recursion and backtracking.

-----

### **1. Problem Understanding**

**Given:**

  * A 9x9 grid (often a `vector<vector<char>>`) representing a Sudoku board.
  * Some cells are filled with digits `'1'` through `'9'`, while others are empty, marked with a `'.'`.

**Task:**

  * Fill all the empty cells on the board to complete the puzzle according to Sudoku rules.

[cite\_start]**Constraints:** [cite: 1]

1.  Each **row** must contain the digits 1–9 without repetition.
2.  Each **column** must contain the digits 1–9 without repetition.
3.  Each of the nine **3x3 sub-boxes** of the grid must contain the digits 1–9 without repetition.

-----

### **2. Core Technique: Backtracking**

Think of solving a Sudoku as navigating a maze of choices. [cite\_start]This makes it a perfect **constraint satisfaction problem** for backtracking[cite: 1].

The strategy is to build the solution incrementally by making a series of choices. If a choice leads to a dead end, we reverse it and try a different path.

1.  **Choose**: Find an empty cell and place a valid number (`'1'`-`'9'`) in it.
2.  **Explore**: Recursively call the function to try and solve the rest of the board from this new state.
3.  [cite\_start]**Un-choose (Backtrack)**: If the exploration hits a dead end (a future cell can't be filled), undo the initial choice by resetting the cell to `'.'` and try the next number[cite: 1].

-----

### **3. Algorithm Breakdown**

The entire process can be driven by a single recursive function.

1.  [cite\_start]Traverse the board (e.g., row by row, column by column) to find the first empty cell (`.`)[cite: 1].
2.  **Base Case**: If no empty cells are found, the board is completely and correctly filled. The puzzle is solved, so we can return `true`.
3.  **Recursive Step**: For the first empty cell found at `(row, col)`:
      * Loop through numbers `'1'` to `'9'`.
      * For each number, check if placing it at `(row, col)` is valid using a helper function, `isValid()`.
      * If the number is valid:
          * **Place it** on the board.
          * **Recurse**: Call the main solve function again. If this recursive call returns `true`, it means a solution was found down the line, so we propagate `true` up the call stack.
          * **Backtrack**: If the recursive call returns `false`, our placement was a mistake. [cite\_start]We must undo it by resetting the cell to `'.'` and continue our loop to try the next number[cite: 1].
4.  If the loop for numbers `'1'`-`'9'` finishes without finding any number that leads to a solution, it means we've reached a dead end from the previous state. We must return `false` to trigger backtracking in the prior function call.

-----

### **4. The Key `isValid()` Function**

The `isValid()` function checks if placing a character `ch` at `(row, col)` violates any of the three Sudoku rules.

```cpp
bool isValid(vector<vector<char>>& board, int row, int col, char ch);
```

It performs three checks inside a single loop from `i = 0` to `8`:

1.  [cite\_start]**Column Check**: `board[i][col] == ch` checks if the character `ch` already exists anywhere in the current column[cite: 1].
2.  [cite\_start]**Row Check**: `board[row][i] == ch` checks if `ch` already exists anywhere in the current row[cite: 1].
3.  **3x3 Sub-Box Check**: This is the trickiest part. [cite\_start]The formula `board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch` cleverly iterates through all 9 cells of the correct sub-box[cite: 1].
      * [cite\_start]`(row / 3, col / 3)` identifies which of the nine 3x3 blocks we are in (from block `(0,0)` to `(2,2)`)[cite: 1].
      * [cite\_start]Multiplying by 3 (`3 * (row / 3)`) gives the coordinate of the top-left corner of that block[cite: 1].
      * [cite\_start]`i / 3` and `i % 3` provide the offsets (0, 1, or 2) to visit every cell within that block as `i` goes from 0 to 8[cite: 1].

-----

### **5. Time and Space Complexity**

  * **Time Complexity**: Approximately **$O(9^m)$**, where `m` is the number of empty cells. [cite\_start]In the worst-case scenario, we might have to explore 9 number choices for each of the `m` empty cells[cite: 1].
  * **Space Complexity**: **$O(1)$** (ignoring the recursion stack). The board is modified in-place. [cite\_start]The recursion depth is at most `m` (i.e., 81), which is a constant, so the auxiliary space is constant[cite: 1].

-----

### **6. Code with Comments**

Here is a complete C++ solution that combines the recursive solver with the `isValid` helper function.

```cpp
#include <vector>

class Solution {
public:
    // Main function to initiate the solving process.
    void solveSudoku(std::vector<std::vector<char>>& board) {
        solve(board);
    }

    // The recursive backtracking function.
    bool solve(std::vector<std::vector<char>>& board) {
        // Traverse the board to find an empty cell.
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                // If a cell is empty...
                if (board[i][j] == '.') {
                    // ...try placing digits '1' through '9'.
                    for (char c = '1'; c <= '9'; c++) {
                        // Check if the placement is valid.
                        if (isValid(board, i, j, c)) {
                            // Choose: Place the digit.
                            board[i][j] = c;

                            // Explore: Recurse to solve the rest of the board.
                            // If a solution is found, propagate 'true' back up.
                            if (solve(board)) {
                                return true;
                            } else {
                                // Un-choose (Backtrack): If not solved, undo the choice.
                                board[i][j] = '.';
                            }
                        }
                    }
                    // If no digit from '1'-'9' leads to a solution, this path is a dead end.
                    return false;
                }
            }
        }
        // Base Case: If the loops complete, no empty cells were found. The board is solved.
        return true;
    }

    // Helper function to check if placing 'ch' at (row, col) is valid.
    bool isValid(std::vector<std::vector<char>>& board, int row, int col, char ch) {
        for (int i = 0; i < 9; i++) {
            [cite_start]// Check if 'ch' is already in the current column. [cite: 1]
            if (board[i][col] == ch) return false;
            [cite_start]// Check if 'ch' is already in the current row. [cite: 1]
            if (board[row][i] == ch) return false;
            [cite_start]// Check if 'ch' is already in the current 3x3 sub-box. [cite: 1]
            int boxRow = 3 * (row / 3) + i / 3;
            int boxCol = 3 * (col / 3) + i % 3;
            if (board[boxRow][boxCol] == ch) return false;
        }
        return true;
    }
};
```

-----

### **7. Key Takeaways**

  * Sudoku is a canonical backtracking problem that frequently appears in technical interviews.
  * The pattern is simple: find an empty spot, try all valid options, recurse, and backtrack if the recursion fails.
  * The `isValid` function is the core of the constraints. Understanding the math to check the 3x3 sub-box is a key implementation detail.
  * The solution explores a decision tree, pruning branches that violate the rules, until a complete and valid solution is found.