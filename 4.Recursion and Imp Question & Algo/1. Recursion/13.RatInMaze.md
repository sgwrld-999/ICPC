## **Rat in a Maze**

This is a classic pathfinding problem set on a grid, and it serves as a perfect illustration of how backtracking can be used to explore and map out all possible routes through a constrained environment.

-----

## **1. Problem Understanding**

**Given:**

  * An `n x n` binary matrix representing a maze.
  * A value of `1` indicates an open cell where the rat can move.
  * A value of `0` indicates a blocked cell or wall.

**Task:**

  * Find **all possible paths** for a rat to travel from the starting cell **(0, 0)** to the destination cell **(n-1, n-1)**.

**Rules:**

1.  The rat can move in four directions: **Up (U), Down (D), Left (L), and Right (R)**.
2.  The rat cannot move into a blocked cell (a cell with a `0`).
3.  The rat cannot move outside the maze boundaries.
4.  The rat cannot visit the same cell more than once within a single path.

-----

## **2. Core Technique: Backtracking**

The request to find "all possible paths" is a strong indicator that **recursion and backtracking** is the right approach. We can think of the maze as a graph where each cell is a node, and our goal is to find all paths from the source node to the destination node.

The strategy is to explore one path as far as possible. If we hit a dead end or the destination, we retrace our steps to the last decision point and try a different direction.

1.  **Choose**: Make a move to an adjacent, valid cell.
2.  **Explore**: Recursively call the function from this new cell to continue the path.
3.  **Un-choose (Backtrack)**: When the recursive call returns, we must undo our last move. This means marking the cell as unvisited so that other paths can potentially use it.

-----

## **3. Algorithm Breakdown**

The solution is centered around a recursive function that explores the maze.

1.  Define a recursive helper function, for example, `solve(row, col, maze, n, path, visited)`.
2.  **Base Case**: If the rat's current position (`row`, `col`) is the destination `(n-1, n-1)`, we have found a complete, valid path. We add the `path` string (e.g., "DDRR") to our final list of answers and return.
3.  **Recursive Step (The "Choose, Explore, Un-choose" Cycle):**
      * Mark the current cell `(row, col)` as visited to avoid cycles.
      * **Try each of the 4 directions (Down, Left, Right, Up) in a specific order (e.g., lexicographical: D, L, R, U).**
      * For each direction:
          * Check if the move is **safe**:
              * Is the new cell within the `n x n` bounds?
              * Is the new cell an open path (`maze[newRow][newCol] == 1`)?
              * Has the new cell **not** been visited yet?
          * If the move is safe:
              * **Choose**: Append the corresponding character ('D', 'L', 'R', or 'U') to the `path` string.
              * **Explore**: Make a recursive call from the new cell: `solve(newRow, newCol, ...)`.
              * **Un-choose**: After the call returns, you must backtrack. The provided code does this implicitly by passing new strings, but in many implementations, you would `pop_back()` the character you just added.
      * After trying all four directions from `(row, col)`, **un-mark the current cell as visited**. This is the most crucial backtracking step, as it makes the cell available for other potential paths.

-----

## **4. Patterns**

  * **Grid/Matrix Backtracking**: This problem is a canonical example of backtracking on a 2D grid. The pattern involves checking boundaries and cell properties before making a recursive move. This applies to many similar problems like word searches, Sudoku, and knight's tours.
  * **Visited Array for Pathfinding**: Using an auxiliary `visited` matrix of the same dimensions is a fundamental technique in graph and grid traversal algorithms (including DFS, which this is a form of) to prevent infinite loops and adhere to the "visit each cell once per path" rule.
  * **Path String Construction**: Building up a result (like the `path` string) as an argument through the recursion is a standard way to record the sequence of choices that leads to a valid solution.

-----

## **5. Time and Space Complexity**

  * **Time Complexity**: **O(4^(n^2))**
      * In the worst case, from each cell in the `n*n` grid, we have up to 4 potential moves. While many paths are pruned by walls and the visited check, the upper bound is exponential.
  * **Space Complexity**: **O(n^2)**
      * This is dominated by the space needed for the `visited` matrix and the depth of the recursion stack. In a worst-case scenario where the path snakes through every cell, the stack depth can be `n^2`.

-----

## **6. Code with Comments**

Here is a complete C++ solution that implements the described algorithm.

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

class Solution {
public:
    void solve(int row, int col, std::vector<std::vector<int>>& maze, int n, 
               std::vector<std::string>& ans, std::string& currentPath, std::vector<std::vector<bool>>& visited) {
        
        // Base Case: If we have reached the destination.
        if (row == n - 1 && col == n - 1) {
            ans.push_back(currentPath);
            return;
        }

        // Mark the current cell as visited for this path.
        visited[row][col] = true;

        // --- Explore in 4 directions: Down, Left, Right, Up ---

        // Try Down
        if (row + 1 < n && !visited[row + 1][col] && maze[row + 1][col] == 1) {
            currentPath.push_back('D');
            solve(row + 1, col, maze, n, ans, currentPath, visited);
            currentPath.pop_back(); // Backtrack
        }

        // Try Left
        if (col - 1 >= 0 && !visited[row][col - 1] && maze[row][col - 1] == 1) {
            currentPath.push_back('L');
            solve(row, col - 1, maze, n, ans, currentPath, visited);
            currentPath.pop_back(); // Backtrack
        }

        // Try Right
        if (col + 1 < n && !visited[row][col + 1] && maze[row][col + 1] == 1) {
            currentPath.push_back('R');
            solve(row, col + 1, maze, n, ans, currentPath, visited);
            currentPath.pop_back(); // Backtrack
        }

        // Try Up
        if (row - 1 >= 0 && !visited[row - 1][col] && maze[row - 1][col] == 1) {
            currentPath.push_back('U');
            solve(row - 1, col, maze, n, ans, currentPath, visited);
            currentPath.pop_back(); // Backtrack
        }

        // Un-mark the cell as visited to make it available for other paths.
        visited[row][col] = false;
    }

    std::vector<std::string> findPath(std::vector<std::vector<int>>& m, int n) {
        std::vector<std::string> ans;
        std::string currentPath = "";
        std::vector<std::vector<bool>> visited(n, std::vector<bool>(n, false));

        // The starting cell must be open to begin.
        if (m[0][0] == 1) {
            solve(0, 0, m, n, ans, currentPath, visited);
        }
        
        // The problem often asks for sorted results.
        std::sort(ans.begin(), ans.end());
        return ans;
    }
};
```

-----

## **7. Key Takeaways**

  * Rat in a Maze is a quintessential backtracking problem that elegantly demonstrates pathfinding on a grid.
  * The `visited` array is a non-negotiable component for preventing infinite loops and ensuring path validity.
  * The two-part backtracking process is key:
    1.  Backtracking the **move** (e.g., `path.pop_back()`) to try other directions from the *same cell*.
    2.  Backtracking the **cell state** (e.g., `visited[row][col] = false`) so that the cell can be part of a completely different path later.