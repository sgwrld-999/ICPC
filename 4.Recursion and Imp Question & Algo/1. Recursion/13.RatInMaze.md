### Problem 
#### Rat in a Maze

[GeeksforGeeks - Rat in a Maze Problem](https://www.geeksforgeeks.org/rat-in-a-maze-backtracking-2/)

### ðŸ“Œ Key Idea:

We need to move from **top-left (0,0)** â†’ **bottom-right (n-1, n-1)** in an `n x n` grid.

* `1` â†’ open cell (rat can move).
* `0` â†’ blocked cell.
* Moves allowed: **Down (D), Right (R), Left (L), Up (U)**.
* We must find **all possible paths**.

---

### ðŸ“Œ Parameters:

```cpp
void solve(vector<vector<bool>>& visited, vector<string>& ans, 
           vector<vector<int>>& a, string s, int row, int col, int n)
```

* `visited` â†’ tracks cells weâ€™ve already used in current path.
* `ans` â†’ stores all successful paths.
* `a` â†’ input maze.
* `s` â†’ current path string (`"DRLU..."`).
* `row, col` â†’ ratâ€™s current position.
* `n` â†’ maze size.

---

### ðŸ“Œ Base Case:

```cpp
if (row == n-1 && col == n-1) {
    ans.push_back(s);
    return;
}
```

ðŸ‘‰ If we reach destination `(n-1, n-1)`, add current path string to `ans`.

---

### ðŸ“Œ Recursive Exploration:

For each possible move, we check:

1. Is the next cell **inside maze boundaries**?
2. Is it **not visited yet**?
3. Is it an **open cell (1)**?

If yes, we:

* Mark it visited.
* Recurse with updated path.
* Backtrack (unmark visited).

---

### ðŸ“Œ Example Maze

```
n = 4
maze = [
  [1, 0, 0, 0],
  [1, 1, 0, 1],
  [1, 1, 0, 0],
  [0, 1, 1, 1]
]
```

### Path Discovery (step-by-step)

* Start at `(0,0)` with path `""`.
* First move possible â†’ **Down** â†’ `(1,0)` with path `"D"`.
* Again **Down** â†’ `(2,0)` with path `"DD"`.
* Again **Right** â†’ `(2,1)` with path `"DDR"`.
* Again **Down** blocked â†’ try **Right** blocked â†’ try **Up** (backtrack).
* Later, valid path `"DDRDRR"` is found reaching destination.

---

### ðŸ“Œ Why `visited` is needed?

Without it, the rat could go in circles:
`(2,1) â†’ (1,1) â†’ (2,1)` ... infinite loop.

Backtracking ensures:

* Mark visited before recursion.
* Unmark after recursion.

---

âœ… So, **strings are built step by step (`s + 'D'`, `s + 'R'`, â€¦) as rat moves**,
and when destination is reached, that complete string is pushed into results.

---

### ðŸ”¹ Key Idea

* Rat starts at `(0,0)` (top-left).
* Goal is `(n-1,n-1)` (bottom-right).
* Moves allowed: **Down (D), Right (R), Left (L), Up (U)**.
* At each step, we **append the chosen move** to the string `s` and recurse further.
* When we reach the goal, we push the completed string into `ans`.

---

### ðŸ”¹ Example Walkthrough

Suppose the maze (`m`) is:

```
1 0 0
1 1 0
0 1 1
```

Here, `1` means open, `0` means blocked.

---

#### Step 1: Start at `(0,0)`

* `s = ""`
* Possible move â†’ **Down (D)**, because `(1,0)` is open.

Call:
`solve(..., "D", row=1, col=0)`

---

#### Step 2: At `(1,0)`

* `s = "D"`
* Possible moves:

  * **Right (R)** â†’ `(1,1)` is open.

Call:
`solve(..., "DR", row=1, col=1)`

---

#### Step 3: At `(1,1)`

* `s = "DR"`
* Possible moves:

  * **Down (D)** â†’ `(2,1)` is open.

Call:
`solve(..., "DRD", row=2, col=1)`

---

#### Step 4: At `(2,1)`

* `s = "DRD"`
* Possible moves:

  * **Right (R)** â†’ `(2,2)` is open (this is the destination!).

Call:
`solve(..., "DRDR", row=2, col=2)`

---

#### Step 5: Reached Destination `(2,2)`

* Path `"DRDR"` is added to `ans`.

---

### ðŸ”¹ Backtracking in Action

After finishing one path, recursion **backtracks**:

* It removes the last move (`pop_back`-like effect using string slicing).
* It tries **other directions** (if available).
* This ensures **all paths are explored**.

---

### ðŸ”¹ Summary

* `s` is the **path string** being built.
* At each step:

  * Add a move (`s + 'D'`, `s + 'R'`, etc.).
  * Recurse to the new cell.
  * If destination reached â†’ save `s`.
  * Backtrack â†’ undo the move, try other directions.
* Final `ans` contains **all possible valid paths**.

---