## **Subsets II: Handling Duplicate Elements**

This problem is a direct follow-up to generating all subsets, but with an important twist: the input array can now contain duplicate numbers. The goal remains to find all possible subsets, but the final output must be unique.

-----

### **1. Problem Understanding**

We are given:

  * An integer array `nums` that may contain **duplicates**.

**Task:**
Return all possible **unique** subsets (the power set). The solution set must not contain duplicate subsets.

**Example:**

```
Input: nums = [1, 2, 2]

Output: [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]
```

Notice that even though there are two `2`s in the input, the subset `[1, 2]` appears only once in the output. A naive approach might generate it twice.

-----

### **2. The Core Challenge: Avoiding Duplicate Subsets**

The main difficulty arises from the duplicate elements. If we use the simple "Pick / Not Pick" approach from the first subsets problem, we will generate duplicate subsets.

Consider `[1, 2a, 2b]`.

  * Picking `1` and `2a` gives `[1, 2]`.
  * Picking `1` and `2b` also gives `[1, 2]`.

We need a strategy to ensure that each unique subset is generated exactly once.

-----

### **3. The Strategy: Sort and Skip**

The most elegant and efficient way to solve this is a two-step process:

1.  **Sort the Input Array**: First and foremost, sort the `nums` array. This is a critical step because it groups all identical elements together (e.g., `[4, 1, 4]` becomes `[1, 4, 4]`).
2.  **Skip Redundant Paths**: In our recursion, we will use a loop to decide which element to add next. The rule is simple: **at any given decision level, we will only consider picking the *first* occurrence of a number**. If we encounter the same number again at the same level, we skip it, because it would only lead to duplicate subsets.

This "Sort and Skip" logic prunes the recursion tree, preventing the algorithm from ever exploring redundant paths.

-----

### **4. Algorithm Breakdown**

The provided code uses a slightly different but equally effective recursive structure.

1.  **Sort** the `nums` array.
2.  Define a recursive helper function `solve(index, currentSubset)`.
3.  **Add the current state as a subset.** In this pattern, every recursive call represents a valid subset. We add `currentSubset` to our final answer at the beginning of each call.
4.  **Iterate and Recurse:** Use a `for` loop that starts from the current `index`. This loop represents the choices we can make to extend the `currentSubset`.
5.  **The Magic Line (Skip Duplicates):**
    ```cpp
    if (i != idx && nums[i] == nums[i-1]) continue;
    ```
    This condition checks: "Is this the first element I am considering at this level (`i == idx`), OR is it different from the previous element I just considered (`nums[i] != nums[i-1]`)?". If we are looking at a duplicate element that is not the first one in the sequence for this level, we `continue`, effectively skipping it.
6.  **Pick:** Add `nums[i]` to `currentSubset`.
7.  **Recurse:** Make a recursive call for the next level, starting from the next index: `solve(i + 1, ...)`.
8.  **Backtrack:** After the recursive call returns, remove `nums[i]` from `currentSubset` to explore other possibilities in the `for` loop.

-----

### **5. Time and Space Complexity**

  * **Time Complexity: `O(n * 2^n)`**

      * Sorting takes an initial `O(n log n)`.
      * The recursive function generates `2^n` unique subsets in the worst case. For each subset, we copy it to the answer list, which takes an average of `O(n)` time.

  * **Space Complexity: `O(n)`**

      * This is the auxiliary space used by the recursion call stack, which can go up to `n` levels deep. This does not include the `O(n * 2^n)` space required to store the final answer.

-----

### **6. Code with Comments**

Here is the provided code with comments explaining the key parts of the optimized algorithm.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    void solve(int idx, vector<int>& nums, vector<int>& currentSubset, vector<vector<int>>& ans, int N) {
        // Add the subset formed so far to the final answer
        ans.push_back(currentSubset);

        // Iterate through the remaining elements to extend the current subset
        for (int i = idx; i < N; i++) {
            // THE KEY: Skip duplicates.
            // If this is not the first element in our consideration (i != idx)
            // AND it's the same as the previous element, then skip it.
            // This prevents forming duplicate subsets.
            if (i != idx && nums[i] == nums[i - 1]) continue;

            // Pick the element
            currentSubset.push_back(nums[i]);
            // Recurse to find subsets starting with the current combination
            solve(i + 1, nums, currentSubset, ans, N);
            // Backtrack: remove the element to try other combinations
            currentSubset.pop_back();
        }
    }

    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<vector<int>> ans;
        int N = nums.size();
        vector<int> currentSubset;
        // CRITICAL STEP: Sorting groups duplicates together.
        sort(nums.begin(), nums.end());
        solve(0, nums, currentSubset, ans, N);
        return ans;
    }
};
```

-----

### **7. Dry Run Visualization (`nums = [1, 2, 2]`)**

Let `f(index, subset)` be our recursive call.

1.  `f(0, [])`: **ans.push(`[]`)**.
      * `i = 0` (num=1): `sub = [1]`. Call `f(1, [1])`.
          * `f(1, [1])`: **ans.push(`[1]`)**.
              * `i = 1` (num=2): `sub = [1, 2]`. Call `f(2, [1, 2])`.
                  * `f(2, [1, 2])`: **ans.push(`[1, 2]`)**.
                      * `i = 2` (num=2): `sub = [1, 2, 2]`. Call `f(3, [1, 2, 2])`.
                          * `f(3, [1, 2, 2])`: **ans.push(`[1, 2, 2]`)**. Loop doesn't run. Return.
                      * Backtrack. `sub = [1, 2]`.
                  * Loop ends. Return.
              * Backtrack. `sub = [1]`.
              * `i = 2` (num=2): **SKIP\!** Because `i(2) != idx(1)` and `nums[2] == nums[1]`.
          * Loop ends. Return.
      * Backtrack. `sub = []`.
      * `i = 1` (num=2): `sub = [2]`. Call `f(2, [2])`.
          * `f(2, [2])`: **ans.push(`[2]`)**.
              * `i = 2` (num=2): `sub = [2, 2]`. Call `f(3, [2, 2])`.
                  * `f(3, [2, 2])`: **ans.push(`[2, 2]`)**. Loop doesn't run. Return.
              * Backtrack. `sub = [2]`.
          * Loop ends. Return.
      * Backtrack. `sub = []`.
      * `i = 2` (num=2): **SKIP\!** Because `i(2) != idx(0)` and `nums[2] == nums[1]`.

âœ… **Final Answer**: `[ [], [1], [1, 2], [1, 2, 2], [2], [2, 2] ]`

-----

### **8. Key Takeaways**

  * This problem is a perfect blend of the subset generation pattern and the duplicate-handling pattern.
  * **Sorting the input** is the essential first step to enable efficient duplicate checking.
  * The `if (i > index && ...)` check inside a `for` loop is a standard, powerful technique for handling duplicates in many backtracking problems, including combinations and permutations.